<a href="https://medium.freecodecamp.org/the-right-way-to-test-react-components-548a4736ab22">https://medium.freecodecamp.org/the-right-way-to-test-react-components-548a4736ab22</a><div id="articleHeader"><h1>The Right Way to Test React Components</h1></div><div><figure id="ae1f"><div><div><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*Ef724ZqepSMHk8AhRCCM7A.jpeg" /></div></figure><p id="f94d">There’s a lot of confusion right now about the “right” way to test your React components. Should you write all your tests by hand, or only use snapshots, or some of both? Should you test props? State? Styles/Layout?</p><p id="5b26">I don’t think there’s one “right” way, but I’ve found a few patterns and tips that work really well for me that I’d like to share.</p><h3 id="fada">Background: The App We’ll Test</h3><p id="03b1">Suppose you want to test a <code>LockScreen</code> component, which behaves like a phone’s lock screen. It:</p><ul><li id="c4b1">Shows the current time</li><li id="57ea">Can show a user-defined message</li><li id="ae23">Can show a user-defined background image</li><li id="0240">Has a slide-to-unlock widget at the bottom</li></ul><p id="5126">It looks something like this:</p><figure id="da31"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*z_dRikEoV22y7d87sBU_Ww.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*z_dRikEoV22y7d87sBU_Ww.gif" /></div></div></div></figure><p id="8577">You can try it out <a href="https://suchipi.github.io/react-testing-example-lockscreen" target="_blank">here</a>, and view the code <a href="https://github.com/suchipi/react-testing-example-lockscreen" target="_blank">on GitHub</a>.</p><p id="c9f1">Here’s the code for the top-level <code>App</code> component:</p><figure id="f95b"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><p id="64dd">As you can see, <code>LockScreen</code> receives three props: <code>wallpaperPath</code>, <code>userInfoMessage</code>, and <code>onUnlocked</code>.</p><p id="f5d9">Here’s the code for <code>LockScreen</code>:</p><figure id="8f21"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><p id="ebc5"><code>LockScreen</code> pulls in a few other components, but since we’re only testing <code>LockScreen</code>, let’s focus on it right now.</p><h3 id="12e8">Component Contracts</h3><p id="a451">In order to test <code>LockScreen</code>, you must first understand what its <strong>Contract </strong>is. Understanding a component’s contract is the most important part of testing a React component. A contract defines the expected behavior of your component and what assumptions are reasonable to have about its usage. Without a clear contract, your component may be hard to understand. Writing tests is a great way to formally define your component’s contract.</p><p id="8ca1">Every React component has at least one thing that contributes to the definition of its contract:</p><ul><li id="f881"><strong>What it renders </strong>(which may be nothing)</li></ul><p id="7a96">Additionally, most component contracts are affected by these things as well:</p><ul><li id="95af">The <strong>props the component receives</strong></li><li id="29c7">The <strong>state the component holds</strong> (if any)</li><li id="cca0">What the component does when the <strong>user interacts with it</strong> (via clicking, dragging, keyboard input, etc)</li></ul><p id="c7a4">Some less common things that affect component contracts are:</p><ul><li id="6d7e">The <strong>context the component is rendered in</strong></li><li id="8cd6">What the component does when you call <strong>methods on its instance</strong> (public ref interface)</li><li id="64ef"><strong>Side effects </strong>that occur as part of the component lifecycle (componentDidMount, componentWillUnmount, etc)</li></ul><p id="7a25">To find your component’s contract, ask yourself questions like:</p><ul><li id="9aeb">What does my component render?</li><li id="793c">Does my component render different things under different circumstances?</li><li id="7bc7">When I pass a function as a prop, what does my component use it for?Does it call it, or just give it to another component? If it calls it, what does it call it with?</li><li id="3dcc">When the user interacts with my component, what happens?</li></ul><h3 id="e79b">Finding LockScreen's Contract</h3><p id="40ae">Let’s go through <code>LockScreen</code>’s <code>render</code> method and add comments at places where its behavior can differ. You’ll look for ternaries, if statements, and switch statements as our clues. This will help us find variations in its contract.</p><figure id="fb41"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><p id="8011">We’ve learned three constraints that describe <code>LockScreen</code>'s contract:</p><ul><li id="482d">If a <code>wallpaperPath</code> prop is passed, the outermost wrapping <code>div</code> that the component renders should have a <code>background-image</code> CSS property in its inline styles, set to whatever the value of <code>wallpaperPath</code> was, wrapped within <code>url(...)</code>.</li><li id="ac33">If a <code>userInfoMessage</code> prop is passed, it should be passed as children to a <code>TopOverlay</code>, which should be rendered with a particular set of inline styles.</li><li id="76eb">If a <code>userInfoMessage</code> prop is <em>not</em> passed, <em>no</em> <code>TopOverlay</code> should be rendered.</li></ul><p id="e8b3">You can also find some constraints of the contract that are always true:</p><ul><li id="a387">A <code>div</code> is always rendered, which contains everything else. It has a particular set of inline styles.</li><li id="ce24">A <code>ClockDisplay</code> is always rendered. It does not receive any props.</li><li id="25bd">A <code>SlideToUnlock</code> is always rendered. It receives the value of the passed <code>onUnlocked</code> prop as its <code>onSlide</code> prop, regardless of if it was defined or not.</li></ul><p id="6478">The component’s <code>propTypes</code> are also a good place to look for clues about its contract. Here’s some more constraints I notice:</p><ul><li id="b638"><code>wallpaperPath</code> is expected to be a string, and is optional.</li><li id="5f73"><code>userInfoMessage</code> is expected to be a string, and is optional.</li><li id="00f7"><code>onUnlocked</code> is expected to be a function, and is optional.</li></ul><p id="6e54">This is a good starting point for our component contract. There may be more constraints within this component’s contract, and in production code you will want to find as many as you can, but for the purposes of this example, let’s just work with these. You can always add tests later if you discover additional constraints.</p><h3 id="78fb">What’s Worth Testing?</h3><p id="87c1">Let’s look over the contract we found:</p><ul><li id="cf79"><code>wallpaperPath</code> is expected to be a string, and is optional.</li><li id="0364"><code>userInfoMessage</code> is expected to be a string, and is optional.</li><li id="1520"><code>onUnlocked</code> is expected to be a function, and is optional.</li><li id="f74e">A <code>div</code> is always rendered, which contains everything else. It has a particular set of inline styles.</li><li id="9b82">A <code>ClockDisplay</code> is always rendered. It does not receive any props.</li><li id="398c">A <code>SlideToUnlock</code> is always rendered. It receives the value of the passed <code>onUnlocked</code> prop as its <code>onSlide</code> prop, regardless of if it was defined or not.</li><li id="3102">If a <code>wallpaperPath</code> prop is passed, the outermost wrapping div that the component renders should have a <code>background-image</code> css property in its inline styles, set to whatever the value of <code>wallpaperPath</code> was, wrapped within <code>url(...)</code>.</li><li id="efe0">If a <code>userInfoMessage</code> prop is passed, it should be passed as children to a <code>TopOverlay</code>, which should be rendered with a particular set of inline styles.</li><li id="57b0">If a <code>userInfoMessage</code> prop is <em>not</em> passed, <em>no</em> <code>TopOverlay</code> should be rendered.</li></ul><p id="dff4">Some of these constraints are worth testing, and others are not. Here are three rules of thumb I use to determine that something is <strong>not worth testing</strong>:</p><ol><li id="21cb">Will the test have to <strong>duplicate <em>exactly</em> the application code</strong>? This will make it brittle.</li><li id="69de">Will making assertions in the test duplicate any behavior that is <strong>already covered by (and the responsibility of) library code</strong>?</li><li id="8cc9">From an outsider’s perspective,<strong> is this detail important, or is it only an internal concern</strong>? Can the effect of this internal detail be described using only the component’s public API?</li></ol><p id="0510">These are only rules of thumb, so be careful not to use them to justify not testing something just because it’s hard. <strong>Often, things that seem hard to test are the most important to test</strong>, because the code under test is making many assumptions about the rest of the application.</p><p id="c5ca">Let’s go through our constraints and use these rules of thumb to determine which need to be tested. Here’s the first three:</p><ul><li id="898b"><code>wallpaperPath</code> is expected to be a string, and is optional.</li><li id="06f6"><code>userInfoMessage</code> is expected to be a string, and is optional.</li><li id="ddd5"><code>onUnlocked</code> is expected to be a function, and is optional.</li></ul><p id="0b4a">These constraints are a concern of React’s <code>PropTypes</code> mechanism, and so writing tests around prop types fails rule #2 (already covered by library code). As such, <strong>I don’t test prop types</strong>. Because tests often double as documentation, I might decide to test something that failed rule #2 if the application code didn’t document the expected types very well, but <code>propTypes</code> are already nice and human-readable.</p><p id="e967">Here’s the next constraint:</p><ul><li id="0d47">A <code>div</code> is always rendered, which contains everything else. It has a particular set of inline styles.</li></ul><p id="3b09">This can be broken down into three constraints:</p><ul><li id="e451">A <code>div</code> is always rendered.</li><li id="b44d">The rendered <code>div</code> contains everything else that gets rendered.</li><li id="f17f">The rendered <code>div</code> has a particular set of inline styles.</li></ul><p id="52a4">The first two constraints that we broke this down into do not fail any of our rules of thumb, so <strong>we will test them</strong>. However, let’s look at the third one.</p><p id="f055">Ignoring the background-image property that is covered by another constraint, the wrapping <code>div</code> has these styles:</p><pre id="8159">height: "100%",<br />display: "flex",<br />justifyContent: "space-between",<br />flexDirection: "column",<br />backgroundColor: "black",<br />backgroundPosition: "center",<br />backgroundSize: "cover",</pre><p id="33c2">If we wrote a test that these styles were on the div, we would have to test the value of each style <em>exactly</em> in order to make useful assertions. So our assertions might be something like:</p><ul><li id="7eb0">The wrapping div should have a height style property of 100%</li><li id="9459">The wrapping div should have a display style property of flex</li><li id="17f6">…And so on for each style property</li></ul><p id="1c97">Even if we used something like <code><a href="https://facebook.github.io/jest/docs/expect.html#tomatchobjectobject" target="_blank">toMatchObjec</a>t</code> to keep this test succinct, this would duplicate the same styles in the application code, and be brittle. If we added another style, we would have to put the exact same code in our test. If we tweaked a style, we would have to tweak it in our test, even though the component’s behavior may not have changed. Therefore, this constraint fails rule #1 (duplicates application code; brittle). For this reason, <strong>I don’t test inline styles, unless they can change at runtime.</strong></p><p id="5480">Often, if you are writing a test that amounts to “it does what it does”, or “it does exactly this, which happens to be duplicated in the application code”, then the test is either unnecessary or too broad.</p><p id="811b">Here’s the next two constraints:</p><ul><li id="948b">A <code>ClockDisplay</code> is always rendered. It does not receive any props.</li><li id="7eac">A <code>SlideToUnlock</code> is always rendered. It receives the value of the passed <code>onUnlocked</code> prop as its <code>onSlide</code> prop, regardless of if it was defined or not.</li></ul><p id="d81e">These can be broken down into:</p><ul><li id="0ce5">A <code>ClockDisplay</code> is always rendered.</li><li id="7abc">The rendered <code>ClockDisplay</code> does not receive any props.</li><li id="43f9">A <code>SlideToUnlock</code> is always rendered.</li><li id="2e42">When the passed <code>onUnlocked</code> prop is defined, the rendered <code>SlideToUnlock</code> receives that prop’s value as its <code>onSlide</code> prop.</li><li id="c146">When the passed <code>onUnlocked</code> prop is <code>undefined</code>, the rendered <code>SlideToUnlock</code>'s <code>onSlide</code> prop should also be set to <code>undefined</code>.</li></ul><p id="d6a6">These constraints fall into two categories: “Some composite component is rendered”, and “the rendered component receives these props”. <strong>Both are very important to test</strong>, as they describe how your component interacts with other components. We will test all of these constraints.</p><p id="1f62">The next constraint is:</p><ul><li id="1f35">If a <code>wallpaperPath</code> prop is passed, the outermost wrapping div that the component renders should have a <code>background-image</code> css property in its inline styles, set to whatever the value of <code>wallpaperPath</code> was, wrapped within <code>url(...)</code>.</li></ul><p id="7269">You may think that, because this is an inline style, we do not need to test it. However, <strong>because the value of </strong><code><strong>background-image</strong></code><strong> can change based on the </strong><code><strong>wallpaperPath prop</strong></code><strong>, it needs to be tested.</strong> If we did not test it, then there would be no test around the effect of the <code>wallpaperPath</code> prop, which is part of the public interface of this component. You should always test your public interface.</p><p id="3a17">The final two constraints are:</p><ul><li id="3ca6">If a <code>userInfoMessage</code> prop is passed, it should be passed as children to a <code>TopOverlay</code>, which should be rendered with a particular set of inline styles.</li><li id="6b59">If a <code>userInfoMessage</code> prop is <em>not</em> passed, <em>no</em> <code>TopOverlay</code> should be rendered.</li></ul><p id="036d">These can be broken down into:</p><ul><li id="bc68">If a <code>userInfoMessage</code> prop is passed, a <code>TopOverlay</code> should be rendered.</li><li id="53d8">If a <code>userInfoMessage</code> prop is passed, its value should be passed as children to the rendered <code>TopOverlay.</code></li><li id="73f4">If a <code>userInfoMessage</code> prop is passed, the rendered <code>TopOverlay</code> should be rendered with a particular set of inline styles.</li><li id="4499">If a <code>userInfoMessage</code> prop is <em>not</em> passed, <em>no</em> <code>TopOverlay</code> should be rendered.</li></ul><p id="978c">The first and fourth constraints (a <code>TopOverlay</code> should/should not be rendered) <strong>describe what we render, so we will test them.</strong></p><p id="df41">The second constraint verifies that the <code>TopOverlay</code> receives a particular prop based on the value of <code>userInfoMessage</code>. <strong>It is important to write tests around the props that rendered components receive, so we will test it.</strong></p><p id="479e">The third constraint verifies that <code>TopOverlay</code> receives a particular prop, so you might think that we should test it. However, this prop is just some inline styles. Asserting that props are passed is important, but making assertions about inline styles is brittle and duplicates application code (fails rule #1). Because it’s important to test passed props, it’s not clear whether this should be tested just by looking at rule #1 alone; luckily, that’s why I have rule #3. As a reminder, it’s:</p><blockquote id="b20b">From an outsider’s perspective, <strong>is this detail important, or is it only an internal concern</strong>? Can the effect of this internal detail be described using only the component’s public API?</blockquote><p id="02f3">When I write component tests, I <strong>only test the public API of the component</strong> (including side effects that API has on the application) where possible. <strong>The exact layout of this component is not impacted by this component’s public API; it is a concern of the CSS engine.</strong> Because of this, this constraint fails rule #3. Because it fails rule #1 and rule #3, <strong>we will not test this constraint</strong>, even though it verifies that <code>TopOverlay</code> receives a prop, which is normally important.</p><p id="694a">It was hard to determine whether that final constraint should be tested or not. Ultimately, it is up to you to decide which parts are important to test; these rules of thumb I use are only guidelines.</p><p id="fa27">Now we’ve gone through all of our constraints, and know which ones we are going to write tests for. Here they are:</p><ul><li id="ee58">A <code>div</code> is always rendered.</li><li id="22e6">The rendered <code>div</code> contains everything else that gets rendered.</li><li id="cc7b">A <code>ClockDisplay</code> is always rendered.</li><li id="ff95">The rendered <code>ClockDisplay</code> does not receive any props.</li><li id="95de">A <code>SlideToUnlock</code> is always rendered.</li><li id="6929">When the passed <code>onUnlocked</code> prop is defined, the rendered <code>SlideToUnlock</code> receives that prop’s value as its <code>onSlide</code> prop.</li><li id="ad22">When the passed <code>onUnlocked</code> prop is <code>undefined</code>, the rendered <code>SlideToUnlock</code>'s <code>onSlide</code> prop should also be set to <code>undefined</code>.</li><li id="41e9">If a <code>wallpaperPath</code> prop is passed, the outermost wrapping div that the component renders should have a <code>background-image</code> css property in its inline styles, set to whatever the value of <code>wallpaperPath</code> was, wrapped within <code>url(...)</code>.</li><li id="131d">If a <code>userInfoMessage</code> prop is passed, a <code>TopOverlay</code> should be rendered.</li><li id="6720">If a <code>userInfoMessage</code> prop is passed, its value should be passed as children to the rendered <code>TopOverlay.</code></li><li id="1d05">If a <code>userInfoMessage</code> prop is <em>not</em> passed, <em>no</em> <code>TopOverlay</code> should be rendered.</li></ul><p id="3261">By examining our constraints and putting them to scrutiny, we broke many of them down into multiple, smaller constraints. <strong>This is great!</strong> This will make it easier to write our test code.</p><h3 id="df5e">Setting Up Some Test Boilerplate</h3><p id="5c92">Let’s start scaffolding out a test for this component. I will be using <a href="https://facebook.github.io/jest/" target="_blank">Jest</a> with <a href="http://airbnb.io/enzyme/" target="_blank">enzyme</a> in my tests. Jest <a href="https://facebook.github.io/jest/docs/tutorial-react.html" target="_blank">works great with React</a> and is also the test runner included in apps created with <a href="https://github.com/facebookincubator/create-react-app" target="_blank">create-react-app</a>, so you may already be set up to use it. Enzyme is a mature React testing library that works in both node and the browser.</p><p id="5779">Even though I’m using Jest and enzyme in my tests, you can apply the concepts here to almost any test configuration.</p><figure id="b24c"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><p id="1309">This is a lot of boilerplate. Let me explain what I’ve set up here:</p><ul><li id="f8da">I create <code>let</code> bindings for <code>props</code> and <code>mountedLockScreen</code>, so that those variables will be available to everything within the <code>describe</code> function.</li><li id="bac7">I create a <code><strong>lockScreen</strong></code><strong> function</strong> that is available anywhere within the <code>describe</code> function, that uses the <code>mountedLockScreen</code> variable to either <code>mount</code> a <code>LockScreen</code> with the current <code>props</code> or return the one that has already been mounted. This function returns an enzyme <code><a href="http://airbnb.io/enzyme/docs/api/mount.html" target="_blank">ReactWrapper</a></code>. <strong>We will use it in every test.</strong></li><li id="420d">I set up a <code>beforeEach</code> that resets the <code>props</code> and <code>mountedLockScreen</code> variables before every test. Otherwise, state from one test would leak into another. By setting <code>mountedLockScreen</code> to <code>undefined</code> here, when the next test runs, if it calls <code>lockScreen</code>, a new <code>LockScreen</code> will be mounted with the current <code>props</code>.</li></ul><p id="7c3d">This boilerplate may seem like a lot just to test a component, but it lets us build up our props incrementally before we mount our component, which will help keep our tests dry. I use it for all of my component tests, and I hope you will find it useful; its utility will become more apparent as we write the test cases.</p><h3 id="4307">Writing the Tests!</h3><p id="767e">Let’s go through our list of constraints and add a test for each. Every test will be written such that it can be inserted at the <code>// All tests will go here</code> comment in the boilerplate.</p><ul><li id="ef17">A <code>div</code> is always rendered.</li></ul><figure id="528e"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><ul><li id="aa98">The rendered <code>div</code> contains everything else that gets rendered.</li></ul><figure id="5b1b"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><ul><li id="0785">A <code>ClockDisplay</code> is always rendered.</li></ul><figure id="4502"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><ul><li id="3ffa">The rendered <code>ClockDisplay</code> does not receive any props.</li></ul><figure id="4d73"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><ul><li id="2d88">A <code>SlideToUnlock</code> is always rendered.</li></ul><figure id="5871"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><p id="e392">All of the constraints thus far have been things that are <em>always</em> true, so their tests were relatively simple to write. However, the remaining constraints begin with words like “If” and “When”. These are clues that they are <em>conditionally</em> true, and so we will pair <code>describe</code> with <code>beforeEach</code> to test them. This is where all that testing boilerplate we wrote earlier comes in handy.</p><ul><li id="4d09">When the passed <code>onUnlocked</code> prop is defined, the rendered <code>SlideToUnlock</code> receives that prop’s value as its <code>onSlide</code> prop.</li><li id="6263">When the passed <code>onUnlocked</code> prop is <code>undefined</code>, the rendered <code>SlideToUnlock</code>'s <code>onSlide</code> prop should also be set to <code>undefined</code>.</li></ul><figure id="aedf"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><p id="68ef">When we need to describe behavior that only occurs within a certain condition, we can <code>describe</code> that condition, and then use <code>beforeEach</code> within that <code>describe</code> to set that condition up.</p><ul><li id="e0d7">If a <code>wallpaperPath</code> prop is passed, the outermost wrapping div that the component renders should have a <code>background-image</code> CSS property in its inline styles, set to whatever the value of <code>wallpaperPath</code> was, wrapped within <code>url(...)</code>.</li></ul><figure id="84ff"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><ul><li id="8b40">If a <code>userInfoMessage</code> prop is passed, a <code>TopOverlay</code> should be rendered.</li><li id="5a7b">If a <code>userInfoMessage</code> prop is passed, its value should be passed as children to the rendered <code>TopOverlay.</code></li></ul><figure id="82d0"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><ul><li id="d27c">If a <code>userInfoMessage</code> prop is <em>not</em> passed, <em>no</em> <code>TopOverlay</code> should be rendered.</li></ul><figure id="bd1e"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F1341513%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></div></figure><p id="2577">That’s all of our constraints! You can view the final test file <a href="https://gist.github.com/suchipi/8f8d7de60e8e4ae48153db0c36133e63" target="_blank">here</a>.</p><h3 id="c877">“Not My Job”</h3><p id="41d1">When looking at the animated gif at the beginning of the article, you may have expected our test cases to end up as something like:</p><ul><li id="8497">When the user drags the slide-to-unlock handle all the way to the right, the unlock callback is called</li><li id="ac6c">If the user drags the slide-to-unlock handle partway to the right and then releases it, the handle is animated back to its original position</li><li id="be6d">The clock at the top of the screen should always show the current time</li></ul><p id="7ade">This intuition is natural. From an application perspective, these are some of the most noticeable features.</p><p id="92db">However, we didn’t end up writing tests for any of that functionality. Why? They were <strong>not the concern of </strong><code><strong>LockScreen</strong></code>.</p><p id="5305">Because React components are reusable units, unit tests are a natural fit for them. And when unit testing, <strong>you should only test what your actual unit cares about</strong>. It is better to see the trees than the forest when writing React component tests.</p><p id="cab5">Here is a handy cheat sheet that outlines <strong>the concerns of most React components:</strong></p><ul><li id="492d">What do I do with the props I receive?</li><li id="eebc">What components do I render? What do I pass to those components?</li><li id="e611">Do I ever keep anything in state? If so, do I invalidate it when receiving new props? When do I update state?</li><li id="bae6">If a user interacts with me or a child component calls a callback I passed to it, what do I do?</li><li id="73ef">Does anything happen when I’m mounted? When I’m unmounted?</li></ul><p id="4e0c">The features described above are the concerns of <code>SlideToUnlock</code> and <code>ClockDisplay</code>, so tests around those features would go in the tests for those components, not here.</p>