<a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318">https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</a><div id="articleHeader"><h1>Index as a key is an anti-pattern</h1></div><p id="fe8e">So many times I have seen developers use the <em>index</em> of an item as its <em>key</em> when they render a list.</p><pre id="ebfa">{todos.map((todo, index) =&gt;<br />  &lt;Todo<br />    {...todo}<br />    key={index}<br />  /&gt;<br />)}</pre><p id="a668">It looks elegant and it does get rid of the warning (which was the ‘real’ issue, right?). What is the danger here?</p><blockquote id="4289">It may break your application and display wrong data!</blockquote><p id="0eb6">Let me explain, a <em>key</em> is the only thing React uses to identify DOM elements. What happens if you push an item to the list or remove something in the middle? If the <em>key</em> is same as before React assumes that the DOM element represents the same component as before. But that is no longer true.</p><figure id="c6d2"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*9N62zUlyJcQet8kr7e_FVg.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*9N62zUlyJcQet8kr7e_FVg.png" /></div><figcaption>Stephen describes the problem he run into on <a href="https://egghead.io/forums/lesson-discussion/topics/break-up-components-into-smaller-pieces-using-functional-components#post-6310" target="_blank">egghead.io</a></figcaption></figure></section><section><div><div><p id="e237">To demonstrate the potential danger I created <a href="http://output.jsbin.com/wohima" target="_blank">a simple example</a> (<a href="http://jsbin.com/wohima/edit?js,output" target="_blank">with source</a>).</p><figure id="b9d3"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*GFYGPdDFLYcLFzx-E-GEcw.jpeg?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*GFYGPdDFLYcLFzx-E-GEcw.jpeg" /></div><figcaption>Screenshot of the example showing the danger of using the index as key.</figcaption></figure><p id="1917">It turns out, when nothing is passed React uses the <em>index </em>as <em>key</em> because it is the best guess at the moment. Moreover, it will warn you that it is suboptimal (it says that in a bit confusing words, yes). If you provide it by yourself React just thinks that you know what you are doing which — remember the example — can lead to unpredictable results.</p><h4 id="0c01">Better</h4><p id="b33d">Each such item should have a <em>permanent</em> and <em>unique</em> property. Ideally, it should be assigned when the item is created. Of course, I am speaking about an <em>id</em>. Then we can use it the following way:</p><pre id="c722">{todos.map((todo) =&gt;<br />  &lt;Todo {...todo}<br />    key={todo.id} /&gt;<br />)}</pre><blockquote id="82b2"><strong>Note:</strong> First look at the existing properties of the items. It is possible they already have something that can be used as an <em>id</em>.</blockquote><p id="99a0">One way to do so it to just move the numbering one step up in the abstraction. Using a global index makes sure any two items would have different <em>id</em>s.</p><pre id="119a">todoCounter = 1;</pre><pre id="0f76">function createNewTodo(text) {<br />  return {<br />    completed: false,<br />    id: todoCounter++,<br />    text<br />  }<br />}</pre><h4 id="c00d">Much better</h4><p id="fc51">A production solution should use a more robust approach that would handle distributed creation of items. For such, I recommend <a href="https://www.npmjs.com/package/shortid" target="_blank">shortid</a>. It quickly generates ‘short non-sequential url-friendly unique’ ids. The code could look like the following:</p><pre id="8576">var shortid <strong>=</strong> require('shortid');</pre><pre id="4e02">function createNewTodo(text) {<br />  return {<br />    completed: false,<br />    id: shortid.generate(),<br />    text<br />  }<br />}</pre></section><section><div><div><blockquote id="b9e8"><strong>TL;DR: </strong>Generate a unique <em>id</em> for every item and use it as <em>key</em> when rendering the list.</blockquote></div></section><section><div><div><h4 id="a4ca">Update: Exception from the rule</h4><p id="e46c">Many people asked if they always, <em>always</em> have to generate ids. Others have suggested use cases when using the index as a key seems justifiable.</p><p id="b65c">It is true that sometimes generating new ids is redundant and may be avoided. For example translation of license terms or list of contributors.</p><p id="e949">To help you decide, I put together three conditions which these examples have in common:</p><ol><li id="7ed4">the list and items are static–they are not computed and do not change;</li><li id="fae9">the items in the list have no ids;</li><li id="e0f3">the list is <em>never</em> reordered or filtered.</li></ol><p id="cf7c">When <em>all</em> of them are met, you <strong>may safely use the index as a key</strong>.</p><h4 id="7e36">Update 2: React, Preact, and *react</h4><p id="9f24">Although in this article I write about React, the problem is not exclusive to it. In similar libraries, like Preact, the danger is present, too. However, the effects can be different.</p><p id="b4d6">See the following StackOverflow question, where the last element disappears. Also please note the explanation in the answers provided by the creator of Preact, <a href="https://medium.com/@developit" target="_blank">Jason Miller</a>.</p></div></section>