<a href="https://dev-blog.apollodata.com/reducing-our-redux-code-with-react-apollo-5091b9de9c2a">https://dev-blog.apollodata.com/reducing-our-redux-code-with-react-apollo-5091b9de9c2a</a><div id="articleHeader"><h1>Reducing our Redux code with React¬†Apollo</h1></div><h2 id="1a47">Switching to a declarative approach at Major League¬†Soccer</h2><p id="8675">I‚Äôm a firm believer that the best code is no code. More code often leads to more bugs and more time spent maintaining it. At Major League Soccer, we‚Äôre a very small team, so we take this principle to heart. We try to optimize where we can, either through maximizing code reuse or lightening our maintenance burden.</p><p id="3dad">In this article, you‚Äôll learn how we offloaded data fetching management to Apollo, which allowed us to delete nearly <strong>5,000 lines of code</strong>. Not only is our application a lot slimmer since switching to Apollo, it‚Äôs also more <strong>declarative</strong> since our components only request the data that they need.</p><p id="e0e1">What do I mean by declarative and why is that a good thing? Declarative programming focuses on the end goal, while imperative programming focuses on the steps it took to get there. React itself is declarative.</p><h3 id="417b">Fetching data with¬†Redux</h3><p id="3a1d">Let‚Äôs look at a simple Article component:</p><figure id="b6d1"><figcaption>A basic Article component</figcaption></figure><p id="ab59">Now, let‚Äôs say we want to render <code>&lt;Article/&gt;</code> in a connected <code>&lt;MatchDetail/&gt;</code> view, which takes a match ID as a prop. If we were accomplishing this without a GraphQL client, our process to retrieve the data necessary to render <code>&lt;Article/&gt;</code> might look something like this:</p><ol><li id="a870">When <code>&lt;MatchDetail/&gt;</code> mounts, invoke action creator to fetch match by ID. Action creator dispatches action to tell Redux we‚Äôre fetching.</li><li id="1369">We hit an endpoint and receive data back. We normalize the data into the structure we need.</li><li id="f225">Once the data is in the structure we need, we dispatch an action to tell Redux we‚Äôre done fetching.</li><li id="612a">Redux processes the action in our reducer and updates our state tree</li><li id="f1f2"><code>&lt;MatchDetail/&gt;</code> receives all of the match data via props and filters it down to render the article.</li></ol><p id="c14e">That‚Äôs a lot of steps to get the data for <code>&lt;Article/&gt;</code>! Without a GraphQL client, our code is much more <em>imperative</em> because we have to focus on <em>how</em> we‚Äôre retrieving our data. What if we don‚Äôt want to pull down all of the match data just to render <code>&lt;Article/&gt;</code>? You could build another endpoint and create a separate set of action creators for hitting it, but that can quickly become unmaintainable.</p><p id="b5e8">Let‚Äôs contrast with how you could approach this with GraphQL:</p><ol><li id="0379"><code>&lt;MatchDetail/&gt;</code> is connected with a higher order component that fetches the following query:</li></ol><pre id="54cf">query Article($id: Float!) {<br />  match(id: $id) {<br />    article {<br />      title<br />      body<br />    }<br />  }<br />}</pre><p id="7b21">‚Ä¶and that‚Äôs it! Once the client receives the data, it will map it to props that can be passed down to <code>&lt;Article/&gt;</code>. Much more <em>declarative</em>, because we‚Äôre only focusing on <em>what </em>data we need to render the component.</p><p id="b5d3">This is the beauty of delegating data fetching to a GraphQL client, whether it‚Äôs Relay or Apollo. When you start ‚Äú<a href="https://facebook.github.io/relay/docs/thinking-in-graphql.html" target="_blank">thinking in GraphQL</a>,‚Äù you become more concerned with <em>what</em> props your component needs to render and less concerned with <em>how</em> you‚Äôre going to get them.</p><p id="a16e">At some point, you will need to take care of the ‚Äúhow,‚Äù but this concern is now server-side and the complexity is drastically reduced. If you‚Äôre new to GraphQL server architecture, make sure you check out <code><a href="http://dev.apollodata.com/tools/graphql-tools/index.html" target="_blank">graphql-tools</a></code>, Apollo‚Äôs library that helps you structure your schema in a modular way. For brevity‚Äôs sake, we will be focusing on the front-end today.</p><p id="90c9">Although this post will teach you how to reduce your Redux code, you won‚Äôt be getting rid of it entirely! Apollo uses Redux under the hood, so you still get the benefit of immutability and all of your favorite Redux Dev Tools features like time-travel debugging. During <a href="http://dev.apollodata.com/react/redux.html" target="_blank">setup</a>, you can hook Apollo into your existing Redux store to maintain one source of truth. Once your store is configured, you pass it into a <code>&lt;ApolloProvider/&gt;</code> component that wraps your application. Sound familiar? This component replaces your existing <code>&lt;Provider /&gt;</code> from Redux, except you also need to pass down your <code>ApolloClient</code> instance through the client prop.</p><p id="139d">Before we start slicing up our Redux code, I want to call out one of the best features of GraphQL: <strong>incremental adoption</strong>. You don‚Äôt have to commit to refactoring your entire application at once. Since Apollo integrates into your existing Redux store, you can switch over your reducers incrementally. The same thing applies to the backend‚Ää‚Äî‚Ääif you‚Äôre working on a large scale application, you can use GraphQL side by side with your existing REST endpoints until you‚Äôre ready to convert them. Fair warning: once you try it, you will fall in love with it and want to refactor your entire application. üòâ</p></section><section><div><div><h3 id="20ab">Our requirements</h3><p id="60fa">Prior to switching from Redux, we thought carefully about whether Apollo would meet our needs. Here‚Äôs what we looked at when making our decision:</p><ul><li id="4a49"><strong>Aggregating data from multiple sources:</strong> A match is comprised of data from 4 different sources: content from our REST API, stats from our MySQL database, media from our video API, and social data from our Redis store. Originally, we were using a server plugin to gather all of the data into one match object to send to the client. It almost functioned just like a GraphQL layer! As soon as we realized this, it became apparent that our application would be a perfect candidate for GraphQL.</li><li id="dcd1"><strong>Near realtime updates:</strong> During a live match, we typically receive updates every minute. Before Apollo, we were handling live updates with sockets and dispatching them to our match reducer. This wasn‚Äôt a terrible solution, but it wasn‚Äôt the most elegant as we were sending down an entire match object to avoid complicated sequencing. With Apollo, we can easily customize a polling interval per component depending on the game‚Äôs status.</li><li id="9d3c"><strong>Simple pagination:</strong> Since we were building out a schedule page with an infinitely scrolling list of matches, we needed a way to handle pagination that wasn‚Äôt headache inducing. Sure, we could have built a custom reducer. But why write it ourselves when Apollo‚Äôs <code>fetchMore</code> function does all the heavy lifting for us? üí™</li></ul><p id="6071">Not only did Apollo satisfy our current requirements, it also covered some of our future needs, especially since enhanced personalization is on our roadmap. While our server is currently ‚Äúread only,‚Äù we may need to introduce <strong>mutations</strong> in the future to save a user‚Äôs favorite team. If we decide to add realtime commenting or fan interaction that can‚Äôt be solved with polling, Apollo supports <strong>subscriptions</strong>.</p><h3 id="44e0">From Redux to Apollo¬†üöÄ</h3><p id="1cd0">The moment you‚Äôve been waiting for! Originally, when I thought of writing this post, I was going to show before/after code samples, but I think it‚Äôs difficult to directly compare the two approaches, especially if you‚Äôre new to Apollo. Instead, I‚Äôm going to quantify what we deleted entirely and walk you through familiar concepts in Redux that you can apply to building your container components in Apollo.</p><h4 id="c063">What we¬†deleted</h4><ul><li id="001a">Matches reducer (~300 lines of code)</li><li id="432a">Data fetching action creators & epics (~800 LOC)</li><li id="9c5f">Action creators & business logic for batching & receiving socket updates for live matches (~750 LOC)</li><li id="bf57">Local storage action creators & epics (~1000 LOC). This is a bit unfair to count in the total because offline support for our project is postponed, but it‚Äôs achievable if we want to add it back in by customizing the Apollo <code>fetchPolicy</code> & exposing the reducer to <code>redux-persist</code>.</li><li id="3f94">Redux container components that separated our Redux logic from our presentational components (~1000 LOC)</li><li id="d81c">Tests associated with all of the above (~1000 LOC)</li></ul><h4 id="b59a">connect() ‚Üí graphql()</h4><p id="b312">If you know how to use <code>connect</code>, then Apollo‚Äôs <code>graphql</code> higher order component will seem very familiar! Just like <code>connect</code> returns a function that takes a component and connects it to your Redux store, <code>graphql</code> returns a function that takes a component and ‚Äúconnects‚Äù it to Apollo Client. Let‚Äôs see it in action!</p><figure id="e44a"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F18017067%3Fv%3D3%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="8373">The first argument supplied to <code>graphql</code> is our <code>MatchSummaryQuery</code>. This is the data we want to receive back from our server. We‚Äôre using a <a href="https://github.com/apollographql/graphql-tag" target="_blank">Webpack loader</a> to parse our query into the GraphQL AST, but if you‚Äôre not using Webpack, you will need to wrap your query in a template string and pass it into the <code><a href="http://dev.apollodata.com/react/api.html#gql" target="_blank">gql</a></code> function exported from Apollo. Here‚Äôs an example of the query to fetch the data needed for this component:</p><figure id="8fdb"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F18017067%3Fv%3D3%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="47ab">Great, we have our query! In order for this query to execute, we‚Äôre going to need to supply it with two variables, <code>$id</code> and <code>$season</code>. Where are we going to get those variables from? ü§î That‚Äôs where the second argument to <code>graphql</code> comes in, our config object.</p><p id="8601">The config object has several properties that you can specify to customize the behavior of your HOC. One of the most important is the <code>options</code> property, which takes a function that receives your container component‚Äôs props. This function returns an object with properties like <code>variables</code>, which supplies your variables to your query, and <code>pollInterval</code>, which allows you to customize your component‚Äôs polling behavior. Notice how we‚Äôre using our container component‚Äôs props to supply <code>id</code> and <code>season</code> to our <code>MatchSummaryQuery</code>. If this function gets too long to write it in the decorator, we‚Äôll break it out into its own function called <code>mapPropsToOptions</code>.</p><h4 id="ef62">mapStateToProps() ‚Üí mapResultsToProps()</h4><p id="0770">In your Redux containers, you probably wrote a function called <code>mapStateToProps</code> that you passed to <code>connect</code> in order to map data from your state tree into props to pass down to the component. Apollo allows you to define a similar function. Remember the config object from earlier that we passed into our <code>graphql</code> function? The config object also has another property, <code>props</code>, that receives a function that takes props and maps them before passing them down to your container. You can define it inline if you want, but we like to call ours <code>mapResultsToProps</code>.</p><p id="a8fc">Why would you want to map your props? Your results from your GraphQL query will be attached to the <code>data</code> prop. Sometimes, you might need to flatten this data before passing it to your component. Here‚Äôs an example:</p><figure id="80fd"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F18017067%3Fv%3D3%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="8da8">Not only does the data object contain your query results, it also contains properties like <code>data.loading</code> to let you know if your query still hasn‚Äôt returned a response. This can be useful if you want to display another component to your user, like we‚Äôre doing with <code>&lt;NoDataSummary /&gt;</code>.</p><h4 id="85aa">compose()</h4><p id="b67a">Compose isn‚Äôt a function that‚Äôs unique to Redux, but I do want to point out that Apollo includes it for your convenience. This is super useful if you want to compose several <code>graphql</code> functions to be used by one container. You can even use <code>compose</code> with Redux <code>connect</code> and <code>graphql</code> together! Here‚Äôs how we use <code>compose</code> to display different match tile states:</p><figure id="ee84"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F18017067%3Fv%3D3%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="3422"><code>compose</code> is great for when your container has multiple states. What if you need to execute a different query depending on its state? That‚Äôs where <code>skip</code> comes in, as you can see above on the config object. The <code>skip</code> property takes a function that receives props and allows you to skip the query if it doesn‚Äôt meet the criteria you specify. <code>compose</code> + <code>skip</code> = üòç</p><p id="0641">All of these examples demonstrate that if you know Redux, you‚Äôll pick up Apollo quickly! Its API draws upon many Redux concepts while reducing the code you need to write to achieve the same results.</p></section><section><div><div><p id="946f">I hope learning about Major League Soccer‚Äôs experience switching to Apollo was helpful! As with any library decision, the best solution to manage your application‚Äôs data fetching will depend on your project‚Äôs requirements. If you have any questions about our experience, please feel free to leave a comment or reach out to me on <a href="https://twitter.com/peggyrayzis" target="_blank">Twitter</a>! üôã</p><figure id="3891"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Fupscri.be%2Fmedia%2Fform.jpg&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure></section>