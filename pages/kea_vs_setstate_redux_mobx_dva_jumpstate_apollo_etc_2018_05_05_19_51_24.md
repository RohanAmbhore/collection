<a href="https://medium.com/@mariusandra/kea-vs-setstate-redux-mobx-dva-jumpstate-apollo-etc-4aa26ea11d02">https://medium.com/@mariusandra/kea-vs-setstate-redux-mobx-dva-jumpstate-apollo-etc-4aa26ea11d02</a><div id="articleHeader"><h1>Kea vs setState, Redux, Mobx, Dva, JumpState, Apollo, etc.</h1></div><p id="ef39"><a href="https://kea.js.org/" target="_blank">Kea</a> is the name of the latest state management library for React that you have never heard of.</p><p id="739e">It’s also the name of the <a href="https://www.youtube.com/results?search_query=kea+parrot" target="_blank">smartest parrot</a> in the world.</p><figure id="54a5"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FNpF1HKsrA28%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="671a">Much like kea the parrot, kea the library doesn’t invent anything new. Instead it manipulates existing tools to get results in the shortest time possible.</p><p id="3a95"><a href="https://kea.js.org/" target="_blank">Kea the library</a> is an abstraction over Redux, Redux-Saga and Reselect. It provides a framework for your app’s actions, reducers, selectors and sagas.</p><p id="38fd">It empowers Redux, making it as simple to use as <em>setState</em>. It reduces boilerplate and redundancy, while retaining composability and making your code easier to read. It works especially well with React.</p><p id="9f59">Because it’s just Redux, it’s immediately compatible with a large array of tools and libraries.</p><p id="060c">Enough talk, let’s see some code!</p><h3 id="9cd4">Kea vs setState</h3><p id="f5ec">So how well does the claim “It empowers Redux, making it as simple to use as setState” hold up?</p><p id="b5f1">Before Kea 0.19, which introduced this feature, I repeatedly went through this process when writing a new page: I’d first write the JSX+CSS to get the page to look right. While doing so, I’d add a few <em>setState</em> calls here and there to open panes, fill input elements or do any other interactivity that was needed.</p><p id="ae2d">Later, after the state object had already grown to multiple keys, I would realise that I need access to this data from some other component or from the code that handles side effects.</p><p id="b0c6">Have you ever been there?</p><p id="e996">At this point I’d curse my decision to go for the simple solution in the beginning and rewrite the code to use Redux’s action creators and reducers. This way all my data would be in Redux and I could use selectors to access it wherever I needed.</p><p id="dac3">It was too much work in the beginning, yet at some point it became unavoidable. I dreaded that point.</p><p id="2af9">Now that’s a thing of the past. I haven’t written a setState call since Kea v0.19.</p><p id="fe13">How come?</p><p id="65dc">Let’s look at Kea vs <em>setState</em> for the simplest possible situation: a counter that we can increment and decrement with the push of a button!</p><p id="8100">Built with React’s <em>setState</em>, the code would look something like this:</p><figure id="ff6f"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F53387%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="b7dc">While this code is definitely good enough for an example as simple as this, the issues outlined above still remain:</p><ul><li id="eb56">What if a component or saga outside &lt;<em>Counter /&gt;</em> needs access to the variable “<em>counter</em>”? It’s not uncommon to build the simplest solution with <em>setState</em>, only to have to rewrite it for Redux when the scope changes.</li><li id="d355">What if your UX changes and you need to show the counter in one component and the buttons in another? Move the state up?</li><li id="fc90"><em>setState</em> can be called from anywhere in your component. How can you have an overview when does “<em>counter”</em> change? Could there be a rouge inlined <em>this.setState({ counter: “banana” })</em> somewhere in <em>render()</em>?</li></ul><p id="45f6">Let’s rewrite the same code to use Kea instead:</p><figure id="fad0"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F53387%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="34c3">The same number of lines and the same functionality, yet it’s fundamentally different:</p><ul><li id="17d4">Your code is clearly separated into actions and reducers, so you have a clear idea where data mutations happen. (Read <a href="http://redux.js.org/docs/introduction/ThreePrinciples.html" target="_blank">Redux’s Three Principles</a> if these concepts are unfamiliar to you). This means less bugs and happier developers!</li><li id="eec6">Your data is stored in Redux. It takes 2 lines of code to change this example to one where other components can directly access “<em>counter</em>”, “<em>increment</em>” and “<em>decrement</em>”.</li><li id="2c86">Because of the nature of Kea, if the logic above grows too big, you can rip it out of your <em>index.js</em> and place it in a separate <em>logic.js</em> with no changes between the brackets of <em>kea({ … })</em>. It would just work.</li><li id="4937">We haven’t even gotten to selectors or sagas yet.</li></ul><p id="4824">Win-win-win!</p><h3 id="d98f">Kea vs vanilla Redux</h3><p id="972d">It’s hard to compare Kea and Redux, because <em>Kea is Redux</em>:</p><ul><li id="ad12">Kea stores its state in Redux’s store</li><li id="86fd">To change the state you must emit an action</li><li id="b2d0">Reducers “listen to” actions and change the state accordingly</li></ul><p id="6607">However Kea adds a lot of cream on top of vanilla Redux:</p><ul><li id="9d9d">Your actions are automatically bound, so there’s no need to call <em>dispatch</em>, although it is available if you need it, e.g. for <em>foreign</em> actions.</li><li id="be58">Your action creators are your action types. Using some nifty <em>toString()</em> magic, inspired by <a href="https://github.com/pauldijou/redux-act" target="_blank">redux-act</a>, you can use the functions themselves directly as input keys to the reducer.</li><li id="0496">There is no need to create and duplicate <em>type</em> constants between files, nor is there a need to have 4+ different files. This is where most of Redux’s boilerplate comes from.</li><li id="54b4">Using structure inspired by <a href="https://github.com/erikras/ducks-modular-redux" target="_blank">ducks</a>, there is a clear and concise way to define actions and reducers.</li><li id="2b3c">Support for selectors is built in. All reducers automatically create selectors that you can use.</li><li id="00bc">Sagas are a <a href="https://kea.js.org/guide/sliders" target="_blank">first class citizen</a>, so you can handle side effects with ease.</li><li id="de72">Import, <a href="https://kea.js.org/guide/connected" target="_blank">connect</a> and use props and actions from other logic stores without trouble. You can seamlessly connect actions and reducers defined in one file with a component in another.</li></ul><p id="9160">Let’s look at a bigger example that combines all of the above.</p><p id="4291">We will create a component that lets the user enter a username and then asks Github for all the repositories of that user.</p><p id="b0d0">The result will look like this:</p><figure id="623f"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/66/1*6Fjxt1gHS-jmMhOd8XPzRQ.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/1760/1*6Fjxt1gHS-jmMhOd8XPzRQ.png" /></div></figure><p id="f24e">And here’s the code:</p><figure id="3080"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F53387%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="4f1c">It’s highly likely that without any explanation, you were able to read and grasp this code. However for a full breakdown, read the <a href="https://kea.js.org/guide/github" target="_blank">Github chapter</a> in the Kea guide.</p><p id="bfe0">Let’s assume your application grows and you want to access reducers defined in one logic file from multiple components. How would you do that?</p><p id="91c6">Like this:</p><figure id="8f7e"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F53387%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="8d59">Using these building blocks, I’ve been able to build very complex applications with ease. The final results have always been very refactorable (I could move code around with minimal effort) and very maintainable (newcomers to the project know immediately what is happening and where things come from).</p><p id="e82c">There are many more aspects of Kea I could get into, but to keep this post from exploding in size, I’ll just direct you to <a href="https://kea.js.org/" target="_blank">the documentation</a> if you’re curious to learn more.</p><h3 id="e70b">Kea vs MobX</h3><p id="a4d8">One of the selling points of <a href="https://mobx.js.org/" target="_blank">MobX</a> has always been that it’s really easy to get started with, compared to Redux.</p><blockquote id="b219">For a lot of JavaScript developers, the biggest complaint with Redux is the amount of boilerplate code needed to implement features. A better alternative is MobX which provides similar functionality but with lesser code to write. — <a href="https://www.sitepoint.com/redux-vs-mobx-which-is-best/" target="_blank">Sitepoint</a></blockquote><p id="b6b5">As we saw above, using Kea that’s no longer the case with Redux: it’s very easy to get started and there’s virtually no boilerplate. That said, the simple example from above would still have <a href="https://medium.com/@mweststrate/note-that-you-are-making-quite-a-stretch-here-you-removed-boilerplate-compared-to-plain-redux-but-2ca5ea2b0a15" target="_blank">fewer lines</a> in MobX.</p><p id="f52f">With that out of the way, let’s look at the bigger picture.</p><p id="0dcf">The thing that always bothered me with MobX is that it seems to take a step back in the evolution of software programming. It’s like writing EmberJS when everyone has switched to React.</p><p id="72d2">I mean that literally. MobX reminds me of Ember-Data.</p><p id="3369">Probably the biggest legacy of React and Redux is making functional programming <em>cool</em>and mainstream on the frontend.</p><p id="0eb5">Who would have thought that by reducing the amount of operations you’re allowed to perform and strictly limiting the flow of data, your code becomes clearer, weird errors cease to exist and you get more done in the end?</p><p id="eae3">Quoting Sir <a href="https://www.reddit.com/r/reactjs/comments/6pni2i/kea_high_level_abstraction_between_react_and_redux/dkr3q8y/?st=j6560ts2&sh=621ea9f9" target="_blank">BenjiSponge</a> on Reddit:</p><blockquote id="d61e">“MobX with React is taking a FP inspired library (React) and throwing a two-way [edit: <a href="https://medium.com/@mweststrate/please-check-facts-mobx-doesnt-offer-two-way-data-binding-b2132374fb24" target="_blank">not two-way</a>!], mutable data store on top.”</blockquote><p id="f036">It <em>feels</em> like a bad idea. Scattering your code with @observer, @computed, @observable and @action annotations, relying on magic and watching out for all the <a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/react.md" target="_blank">weird edge cases</a> seems like going backwards to me.</p><p id="77ec">Sure you can <a href="https://www.quora.com/Is-MobX-going-to-kill-Redux-js/answer/Will-Stern-1" target="_blank">force yourself</a> to use MobX like Redux, much like you can force yourself to write EmberJS like React. But a library’s legacy is not defined by what seasoned veterans of <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=as_li_ss_tl?ie=UTF8&linkCode=sl1&tag=su0d-20&linkId=0d0273671a10ee6d571a5ad9bbd501aa" target="_blank">clean code</a> <em>can</em> write. It’s defined by what the junior developers on your team who have no experience <em>will</em> write.</p><p id="1412">MobX is an <a href="https://www.reddit.com/r/reactjs/comments/6pni2i/kea_high_level_abstraction_between_react_and_redux/dkxvdj9/?st=j656ekk1&sh=84bd4ab0" target="_blank">impressive feat of engineering</a>, no doubt!</p><p id="81a5">Yet I believe that the single most important technical topic in programming is <a href="https://mariusandra.com/blog/2012/09/two-strategies-for-writing-better-code/" target="_blank">managing complexity</a>. As humans we can only store about 7 ± 2 concepts in our short term memory. Every platform quirk you need to account for reduces the slots available to reason about your application. This means more bugs.</p><p id="cf1c">I could be proven wrong, but with Redux, Kea and other state libraries that operate according to functional programming paradigms, your code is simple on every level. With MobX you need to go a few levels deeper to grasp the full picture.</p><figure id="de7d"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/66/1*NEI0IA1cLZsJrL_6wf7ALw.jpeg?q=20" /><div class="readableLargeImageContainer"><img /></div></figure><h3 id="f434">Kea vs Dva, JumpState, etc.</h3><p id="83cb">Two other libraries for managing state are <a href="https://github.com/dvajs/dva/blob/master/docs/GettingStarted.md#all-code-together" target="_blank">Dva</a> and <a href="https://github.com/jumpsuit/jumpstate" target="_blank">JumpState</a>. They operate similarly to Kea:</p><ul><li id="bc4f">They provide a layer on top of Redux</li><li id="1f4d">They help you structure your actions, reducers and side effects</li></ul><p id="4ad0">The main differences between them and Kea are, as far as I can see:</p><ul><li id="dd9a">They introduce new concepts that are not present in redux, redux-saga and reselect, such as <em>effects</em>, <em>hooks</em> and <em>subscriptions</em>.</li><li id="332d">It’s harder to get started. You can’t just add something like <em>@kea({})</em> and be done with it.</li><li id="92bf">Actions seem to be tied to just one reducer, versus in Kea actions are shared among all the reducers in a logic store and even with external logic stores.</li><li id="ed13">It’s not as easy to share actions and props between components as it is with Kea’s <em>connect</em></li></ul><p id="17fc">There are a few small benefits in dva, such as the ability to easily subscribe to any action, such as a key press or an incoming websocket connection, but those are not hard to bootstrap on your own.</p><p id="481b">I found a few other React state libraries out there, but none which seemed as widely used or still maintained as the ones mentioned above. If I missed anything important, let me know!</p><h3 id="17ca">Kea vs React-Apollo</h3><p id="f079">Finally, there’s <a href="https://github.com/apollographql/react-apollo" target="_blank">React-Apollo</a>, <a href="https://facebook.github.io/relay/" target="_blank">Relay</a> and other GraphQL-based libraries.</p><p id="4e2d">Kea doesn’t intend to compete with them. In fact, you can use Kea and Apollo together <a href="https://github.com/keajs/kea/issues/18" target="_blank">seamlessly</a>. Use Apollo to fetch your data and Kea to manage all the other interactivity your application needs. Win-win!</p><h3 id="6257">In conclusion</h3><p id="001c">If you haven’t already, please give <a href="https://kea.js.org/" target="_blank">Kea</a> a try. Tell your friends about it, share this post, give a <a href="https://github.com/keajs/kea" target="_blank">star on Github</a> and keep being awesome!</p><p id="f236">You should also follow me on twitter at <a href="https://twitter.com/mariusandra" target="_blank">@mariusandra</a>.</p><p id="01b0">Thanks for reading! :)</p>