<a href="https://medium.com/powtoon-engineering/a-complete-guide-to-testing-javascript-in-2017-a217b4cd5a2a">https://medium.com/powtoon-engineering/a-complete-guide-to-testing-javascript-in-2017-a217b4cd5a2a</a><div id="articleHeader"><h1>An Overview of JavaScript Testing in 2017</h1></div><figure id="fc52"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*aOpmwNadqHgJYum2DT9mZw.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*aOpmwNadqHgJYum2DT9mZw.png" /></div></figure><p id="f62d">This short guide is intended to catch you up with the most important reasoning, terms, tools, and approaches to JavaScript testing. It combines information from many great recently written articles and adds a little more from our own experience.</p><blockquote id="ae9f">***** Important update: ****</blockquote><blockquote id="0edd"><a href="https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2018-f68950900bc3" target="_blank">A new version of this guide for 2018 was released.</a></blockquote><p id="36d3">Look at the logo of Jest, a testing framework by Facebook:</p><figure id="9c6d"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*MvrDMspvVYwVpmupxJVWRg.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*MvrDMspvVYwVpmupxJVWRg.png" /></div></figure><p id="66dc">As you can see, their slogan promises a “painless” JavaScript Testing, but as <a href="https://news.ycombinator.com/item?id=13128146#13128900" target="_blank">“some guy from the comments” said</a>:</p><figure id="5fd5"><div><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*pnzf1V-QrauJf9gaGDYFFQ.png" /></div></figure><p id="20ec">And indeed, Facebook have an excellent reason to use this slogan. In general, JS developers are <a href="http://stateofjs.com/2016/testing/" target="_blank">not too happy with website testing</a>. JS tests tend to be limited, hard to implement, and slow.</p><p id="c213">Nevertheless, with the right strategy and the right combination of tools a nearly full coverage can be achieved and tests can be very organized, simple, and relatively fast.</p><p id="254a">Here it is worth mentioning there are many great unmaintained libraries I came across when writing this blog post, with unique features that can potentially be very useful in various situations if a company decides to resurrect and maintain them such as- <a href="http://dalekjs.com/" target="_blank"><strong>DalekJS</strong></a>.</p><p id="87fd">I’ll hopefully create a summary of those in a future blog post, but for now, let’s focus on the trending maintained libraries.</p><h3 id="bfd4">Test Types</h3><p id="8db5">You can read about different test types in more depth <a href="http://stackoverflow.com/questions/520064/what-is-unit-test-integration-test-smoke-test-regression-test" target="_blank">here</a> and <a href="https://www.sitepoint.com/javascript-testing-unit-functional-integration/" target="_blank">here</a> and <a href="https://codeutopia.net/blog/2015/04/11/what-are-unit-testing-integration-testing-and-functional-testing/" target="_blank">here</a>.<br />In general, the most important test types are:</p><ul><li id="c901"><strong>Unit Tests</strong>- Testing of individual functions or classes by mocking input and making sure the output is as expected.</li><li id="8eab"><strong>Integration Tests</strong>- Testing several modules to ensure they work together as expected.</li><li id="6d18"><strong>Functional Tests</strong>- Testing a scenario on the product itself (on the browser, for example) regardless of the internal structure to ensure expected behavior.</li></ul><h3 id="9d84"><strong>Test Tools Types</strong></h3><p id="0688">Test tools can be divided into the following functionalities. Some provide us with only one functionality, and some provide us with a combination.</p><p id="f931">It’s common to use a combination of tools even if one can achieve the same using a single tool in order to get a more flexible functionality.</p><ol><li id="e0ca">Provide a test <strong>environment </strong>(<a href="https://mochajs.org/" target="_blank">Mocha</a>, <a href="http://jasmine.github.io/" target="_blank">Jasmine</a>, <a href="https://facebook.github.io/jest/" target="_blank">Jest</a>, <a href="https://karma-runner.github.io/" target="_blank">Karma</a>)</li><li id="2222">Provide a <strong>testing structure</strong> (<a href="https://mochajs.org/" target="_blank">Mocha</a>, <a href="http://jasmine.github.io/" target="_blank">Jasmine</a>, <a href="https://facebook.github.io/jest/" target="_blank">Jest</a>, <a href="https://github.com/cucumber/cucumber-jshttps://github.com/cucumber/cucumber-js" target="_blank">Cucumber</a>)</li><li id="40ee">Provide <strong>assertions functions</strong> (<a href="http://chaijs.com/" target="_blank">Chai</a>, <a href="http://jasmine.github.io/" target="_blank">Jasmine</a>, <a href="https://facebook.github.io/jest/" target="_blank">Jest</a>, <a href="http://unexpected.js.org" title="http://unexpected.js.org" target="_blank">Unexpected</a>)</li><li id="af4a">Generate, <strong>display, and watch </strong>test results (<a href="https://mochajs.org/" target="_blank">Mocha</a>, <a href="http://jasmine.github.io/" target="_blank">Jasmine</a>, <a href="https://facebook.github.io/jest/" target="_blank">Jest</a>, <a href="https://karma-runner.github.io/" target="_blank">Karma</a>)</li><li id="0cda">Generate and compare <strong>snapshots </strong>of component and data structures to make sure changes from previous runs are intended (<a href="https://facebook.github.io/jest/" target="_blank">Jest</a>, <a href="https://github.com/avajs/ava" target="_blank">Ava</a>)</li><li id="57ad">Provide <strong>mocks, spies, and stubs</strong> (<a href="http://sinonjs.org/" target="_blank">Sinon</a>, <a href="http://jasmine.github.io/" target="_blank">Jasmine</a>, <a href="http://airbnb.io/enzyme/docs/api/" target="_blank">enzyme</a>, <a href="https://facebook.github.io/jest/" target="_blank">Jest</a>, <a href="https://github.com/testdouble/testdouble.js" target="_blank">testdouble</a>)</li><li id="635f">Generate<strong> code coverage</strong> reports (<a href="https://gotwarlost.github.io/istanbul/" target="_blank">Istanbul</a>, <a href="https://facebook.github.io/jest/" target="_blank">Jest</a>)</li><li id="ea92">Provide a<strong> browser or browser-like environment</strong> with a control on their scenarios execution (<a href="http://www.protractortest.org" target="_blank">Protractor</a><strong>, </strong><a href="http://nightwatchjs.org" target="_blank">Nightwatch</a>, <a href="http://phantomjs.org/" target="_blank">Phantom</a><strong>, </strong><a href="http://casperjs.org/" target="_blank">Casper</a>)</li></ol><p id="8cce">Let’s explain some of the terms mentioned above:</p><p id="e65d"><strong>Testing structure </strong>refers to the organization of your tests. Tests are usually organized in a <strong>BDD structure </strong>that supports <a href="https://en.wikipedia.org/wiki/Behavior-driven_development" title="Behavior-driven development" target="_blank">behavior-driven development</a> (BDD). It often looks like this:</p><pre id="b218"><code>describe('calculator', <strong>function</strong>() {</code></pre><pre id="578b"><code>  // describes a module with nested "describe" functions<br />  describe('add', <strong>function</strong>() {</code></pre><pre id="6a7f"><code>    // specify the expected behavior<br />    it('should add 2 numbers', <strong>function</strong>() {</code></pre><pre id="6b06"><code>       //Use assertion functions to test the expected behavior    <br />    })</code></pre><pre id="5fb8"><code>  })</code></pre><pre id="dc54"><code>})</code></pre><p id="6dde"><strong>Assertion functions</strong> are functions that make sure tests result as expected where the most popular are the first two:</p><pre id="67c5">// Chai expect<br />expect(foo).to.be.a('string')<br />expect(foo).to.equal('bar')</pre><pre id="0b87">// Jasmine expect<br />expect(foo).toBeString()<br />expect(foo).toEqual('bar')</pre><pre id="b4e1">// Chai assert<br />assert.typeOf(foo, 'string')<br />assert.equal(foo, 'bar')</pre><pre id="63ba">// Unexpected expect<br />expect(foo, 'to be a', 'string')<br />expect(foo, 'to be', 'bar<strong>'</strong>)</pre><p id="1108"><strong><em>TIP: </em></strong><a href="https://medium.com/@boriscoder/the-hidden-power-of-jest-matchers-f3d86d8101b0" target="_blank"><em>Here is a nice article</em></a><em> about advanced Jasmine assertions.</em></p><p id="9e23"><a href="http://sinonjs.org/releases/v2.1.0/spies/" target="_blank"><strong>Spies</strong></a>provide us with <strong>information about functions</strong> that are used in the application or created for tests- How many times they are called, in what cases, and by who? They are especially useful in integration tests where we want to ensure certain behaviors when running an internal scenario. For example, how many times was a calculation function called during some process?</p><pre id="32d7"><code>it('should call method once with the argument 3', () =&gt; {<br />  <strong>const </strong>spy = sinon.spy(object, 'method')</code></pre><pre id="bb6e"><code>  spy.withArgs(3)</code></pre><pre id="ef7c"><code>  object.method(3)</code></pre><pre id="8425"><code>  assert(spy.withArgs(3).calledOnce)<br />})</code></pre><p id="15bf"><a href="http://sinonjs.org/releases/v2.1.0/stubs/" target="_blank"><strong>Stubbing </strong>or <strong>dubbing</strong></a><strong> (</strong>like doubles in movies)<strong> replaces selected functions </strong>with our own to ensure an expected behavior on selected modules.</p><p id="329c">If we want to ensure <code>user.isValid()</code> always returns true during a test, for example, you can do this:</p><pre id="7b8d"><code>sinon.stub(user, 'isValid').returns(<strong>true</strong>) <em>// Sinon</em></code></pre><pre id="2804"><code>spyOn(user, 'isValid').andReturns(<strong>true</strong>) <em>// Jasmine</em></code></pre><p id="69c5">This also works with promises:</p><pre id="7a56"><code>it('resolves with the right name', done =&gt; {</code></pre><pre id="9190"><code><strong>  const </strong>stub <strong>=</strong> sinon.stub(User.prototype, 'fetch')<br />    .resolves({ name: 'David' })<br /><br />User.fetch()<br />    .then(user =&gt; {<br />      expect(user.name).toBe('David')<br />      done()<br />    })</code></pre><pre id="b70a"><code>})</code></pre><p id="7aa9"><a href="http://sinonjs.org/releases/v2.1.0/mocks/" target="_blank"><strong>Mocks </strong>or <strong>Fakes</strong></a>are <strong>faking certain modules or behaviors</strong> to ensure a test runs with known inputs. Sinon can, for example, <a href="http://sinonjs.org/releases/v2.1.0/fake-xhr-and-server/" target="_blank"><strong>fake a server</strong></a> to ensure fast and expected results.</p><pre id="b161"><code>it('returns an object containing all users', done =&gt; {</code></pre><pre id="e6bb"><code>  <strong>const </strong>server <strong>=</strong> sinon.fakeServer.create()</code></pre><pre id="0a98"><code>  server.respondWith('GET', '/users', [<br />    200,<br />    { 'Content-Type': 'application/json' },<br />    '[{ "id": 1, "name": "Gwen" },  { "id": 2, "name": "John" }]'<br />  ])</code></pre><pre id="a424"><code>  Users.all()<br />    .done(collection =&gt; {<br />      <strong>const </strong>expectedCollection = [<br />        { id: 1, name: 'Gwen' },<br />        { id: 2, name: 'John' }<br />      ]</code></pre><pre id="1ddc"><code>      expect(collection.toJSON()).to.eql(expectedCollection)</code></pre><pre id="f6b1"><code>      done()<br />    })<br /><br />server.respond()<br />  server.restore()<br />});</code></pre><p id="9114"><a href="http://facebook.github.io/jest/docs/snapshot-testing.html#snapshot-testing-with-jest" target="_blank"><strong>Snapshot Testing</strong></a>is when you compare a resulted data structure to an expected one. For example, the following Jest test simulates the rendering of a “Link” component and then saves it as JSON.</p><p id="a6bd">It then compares it to the results of a previous run. If anything changed, the developer is prompted to agree that the change is intended.</p><pre id="b13b">it('renders correctly', () =&gt; {<br />  const linkInstance = (<br />    &lt;Link page="http://www.facebook.com"&gt;Facebook&lt;/Link&gt;<br />  )</pre><pre id="69a7">  const tree = renderer.create(linkInstance).toJSON()</pre><pre id="cdd9">  expect(tree).toMatchSnapshot()<br />})</pre><figure id="2a55"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*255X4sW5UsjUjxdnrjm3_Q.png?q=20" /><div class="readableLargeImageContainer"><img /></div></figure><h3 id="6a09"><strong>Putting it All Together</strong></h3><p id="9682">We suggest using the same tools for all the test types if possible. The same testing structure and syntax (2), assertion functions (3), result reporting, and watching (4) for all of them. Sometimes even the same testing environment (1) can be used for some or all of them.</p><p id="73ad">Make sure it is possible to run only particular types of tests on demand.</p><ul><li id="1382">For <strong>unit tests</strong>, provide all units with a mocked input (6) and make sure their output is expected (3), Also make sure to use a coverage reporting tool (7) to know what units are covered.</li><li id="0b9e">For <strong>integration tests, </strong>define important cross-module internal scenarios. Comparing to unit tests, you would use spies and stubs to test expected behavior instead of just asserting the output (6). Also, a browser or browser-like environment could test integration between processes and their results on the UI.</li><li id="99c0">For <strong>functional tests,</strong> A browser or browser-like environment with a programmable API (8) will be used to create user-like behavior scenarios.</li></ul><h3 id="dacf">List of General Prominent Testing Tools</h3><p id="b9f9"><strong>JSDom</strong> is a JavaScript implementation of the WHATWG DOM and HTML standards. In other words, JSDom simulates a browser’s environment without running anything but plain JS.</p><p id="1607">In this simulated browser environment, tests can run really fast. The drawback with JSDom is that not everything can be simulated outside a real browser (you can’t take a screenshot for example) so using it will limit your tests’ reach.</p><p id="705d">It is worth mentioning that the JS community rapidly improves it.</p><p id="29aa"><strong>Istanbul </strong>will tell you how much of your code is covered with unit tests. It will report on statement, line, function and branch coverage in percentages so you will understand better what is left to cover.</p><p id="aeaa"><strong>Phantom </strong>implements a <strong>“headless” Webkit browser </strong>which is between a real browser and JSDom in speed and stability.</p><p id="e4c5">It is very popular in the time of writing this article, but since <a href="https://www.chromestatus.com/features/5678767817097216" target="_blank">Google are adding the feature of running “headless”</a> to the native Google Chrome browser, <a href="https://groups.google.com/forum/#!msg/phantomjs/9aI5d-LDuNE/5Z3SMZrqAQAJ" target="_blank">it is not longer maintained</a> by it’s main creator and maintainer <a href="https://medium.com/@vitallium" target="_blank">Vitaliy Slobodin</a>.</p><p id="098e"><strong>Karma </strong>lets you <strong>run tests in browsers</strong>, including real browsers, Phantom, <a href="https://github.com/tmpvar/jsdom" target="_blank">jsdom</a>, and even legacy browsers.</p><p id="13a1">Karma hosts a <strong>test server with a special web page</strong> to run your tests in the page’s environment. This page can be run across many browsers.</p><p id="d7a9">This also means tests can be run remotely using services like <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>.</p><p id="7e5f"><strong>Chai </strong>is the most popular assertion library.</p><p id="79fe"><strong>Unexpected</strong> is an assertion library with a slightly different syntax from Chai. It is also extensible so assertions can be more advanced with libraries that are based on it like <a href="https://github.com/bruderstein/unexpected-react" target="_blank">unexpected-react</a> that you can read about more in depth <a href="https://medium.com/@bruderstein/enzyme-vs-unexpected-react-ee9cb099d12b" target="_blank">here</a>.</p><p id="ca92"><strong>Sinon</strong> is a very powerful standalone test spies, stubs and mocks for JavaScript that works with any unit testing framework.</p><p id="666a"><strong>testdouble </strong>is a new library that is similar to Sinon, with a few differences in design, philosophy, and features that could make it useful in many cases. you can read about it <a href="https://www.sitepoint.com/javascript-testing-tool-showdown-sinon-js-vs-testdouble-js/" target="_blank">here</a>, <a href="https://spin.atomicobject.com/2016/03/21/javascript-mocking-testdouble/" target="_blank">here </a>and <a href="http://blog.testdouble.com/posts/2016-03-13-testdouble-vs-sinon.html" target="_blank">here</a>.</p><p id="9d12"><strong>Wallaby</strong> is another tool worth mentioning. It is not free, but many users recommend buying it. It runs on your IDE (it supports all major ones) and runs relevant to your code changes tests and indicates if anything fails in real time just alongside your code.</p><figure id="f1e3"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*b-jNPVyrwyAJssbHNYPwtQ.png?q=20" /><div class="readableLargeImageContainer"><img /></div></figure><h3 id="dacc"><strong>Choose Your Framework</strong></h3><p id="9fdd">The first choice you should probably make is what framework do you want to use and libraries to support it. It is recommended to use the tools your framework provides until a need for unique tools arises. Then it should not be hard to change to or add them.</p><blockquote id="0785">* In short, if you want to “just get started” or looking for a fast framework for large projects, go with <strong>Jest</strong>.</blockquote><blockquote id="624f">* If you want a very flexible and extendable configuration, go with <strong>Mocha</strong>.<br />If you are looking for simplicity go with <strong>Ava</strong>.</blockquote><blockquote id="440c">* If you want to be really low-level, go with <strong>tape</strong>.</blockquote><p id="6472">Here is a list of the most prominent tools with some of their pros and cons:</p><p id="717d"><strong>Jasmine </strong>is a<strong> testing framework</strong> providing with everything you are expected to need for your tests: a running environment, structure, reporting, assertion, and mocking tools.</p><ul><li id="cb35"><strong>Globals</strong>- Creates test globals by default so there is no need to require them:</li></ul><pre id="3222"><code>// "describe" is in the global scope already<br />// so no these require lines are not required:<br />//<br />// const jasmine = <strong>require</strong>('jasmine')<br />// const describe</code> = jasmine.describe</pre><pre id="75bd"><code>describe('calculator', <strong>function</strong>() {<br />  ...<br />})</code></pre><ul><li id="6abe"><strong>Ready-To-Go</strong>- Comes with assertions, spies, mocks that are equivalent to libraries that do the same like Sinon. Libraries still can easily be used in case you need some unique features.</li><li id="649b"><strong>Angular</strong>- Has widespread <a href="https://docs.angularjs.org/guide/unit-testing" target="_blank">Angular support.</a></li></ul><p id="62c8"><strong>Mocha</strong> is currently the most used library. Unlike Jasmine, it is used with third party assertion, mocking, and spying tools (usually Enzyme and Chai).</p><p id="1837">This means Mocha is a little harder to set up and divided into more libraries but it is more flexible and open to extensions.</p><p id="ec50">For example, if you want <a href="https://mochajs.org/#assertions" target="_blank">special assertion logic</a>, you can fork Chai and replace only Chai with your own assertion library. This can also be done in Jasmine but Mocka is more flexible in this sense.</p><ul><li id="bfab"><strong>Community</strong>- Has many plugins and extension to test unique scenarios.</li><li id="8dc8"><strong>Extensibility</strong>- Plugins, extensions and libraries such as Sinon includes features Jasmine does not have.</li><li id="b24a"><strong>Globals</strong>- Creates test structure globals by default, but obviously not assertions, spies and mocks like Jasmine- some people are surprised by this seemingly inconsistency of globals.</li></ul><p id="e2f6"><strong>Jest</strong> is the <strong>testing framework </strong>recommended by Facebook. It wraps Jasmine and adds features on top of it so everything mentioned about Jasmine applies to it as well.</p><blockquote id="4149"><em>After reading an inhuman amount of articles and blog posts, it’s incredible how by the end of 2016 people are impressed by Jest’s speed and convenience.</em></blockquote><ul><li id="20e8"><strong>Performance</strong>- First of all Jest is considered to be faster for big projects with many test files by implementing a<a href="http://facebook.github.io/jest/blog/2016/03/11/javascript-unit-testing-performance.html" target="_blank"><strong>clever parallel testing mechanism</strong></a> (For example by us from our experience and in these blog posts: <a href="https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f" target="_blank">here</a>, <a href="https://medium.com/@kentcdodds/migrating-to-jest-881f75366e7e" target="_blank">here</a>, <a href="https://medium.com/@gethylgeorge/testing-a-react-redux-app-using-jest-and-enzyme-b349324803a9" target="_blank">here</a>, <a href="https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251" target="_blank">here</a>).</li><li id="9354"><strong>UI</strong>- Clear and convenient.</li><li id="8d1a"><strong>Snapshot testing</strong>- <a href="https://github.com/facebook/jest/tree/master/packages/jest-snapshot" target="_blank">jest-snapshot</a> is developed and maintained by Facebook, although it can be used in almost any other framework as part of the framework’s integration of the tool or by using the right plugins.</li><li id="5514"><strong>Improved modules mocking</strong>- Jest lets you mock heavy libraries in a very easy way to improve testing speed.</li><li id="9ed5"><strong>Code coverage</strong>- Includes a powerful and fast built-in code coverage tool that is based on <a href="https://github.com/gotwarlost/istanbul" target="_blank">Istanbul</a>.</li><li id="326b"><strong>Support</strong>- Jest is in motion and improves in big steps as for the end of 2016 and at the first months of 2017.</li><li id="68b8"><strong>Development- </strong>jest only updates the files updated so tests are running very fast in watch mode.</li></ul><p id="3c58"><strong>Ava</strong> is a minimalistic testing library that runs tests in parallel.</p><ul><li id="0f70"><strong>Globals</strong>- Does not create any test globals thus you have more control over your tests.</li><li id="a372"><strong>Simplicity</strong>- simple structure and assertions without a complex API while supporting many advanced features.</li><li id="58c5"><strong>Development- </strong>Ava only updates the files updated so tests are running fast in watch mode.</li><li id="3a2a"><strong>Snapshot testing </strong><a href="https://github.com/avajs/ava#snapshot-testing" target="_blank">is supported</a> by using <a href="https://github.com/facebook/jest/tree/master/packages/jest-snapshot" target="_blank">jest-snapshot</a> under the hood.</li></ul><p id="bf21"><strong>Tape </strong>is the simple of them all. It’s just a JS file you run with node with a very short and “to-the-point” API.</p><ul><li id="66d9"><strong>Simplicity</strong>- Minimalistic structure and assertions without a complex API. Even more than Ava.</li><li id="6510"><strong>Globals</strong>- Does not create any test globals thus you have more control over your tests.</li><li id="5cb3"><strong>No Shared State</strong> between tests- Tape discourages the use of functions like “beforeEach” to ensure test modularity and maximum user control over the tests cycle.</li><li id="00e9"><strong>No CLI</strong> is needed- Tape is simply run anywhere JS can be run.</li></ul><h3 id="7e68">Unit Tests</h3><p id="ca46">Cover everything. Use a coverage tool like <a href="https://github.com/gotwarlost/istanbul" target="_blank">Istanbul</a> to make sure every module in your system is covered.</p><p id="1eae">Since these tests are testing separate modules, it is prefered to run them in NodeJS and not in a browser (like karma does) because running JS in browsers is slower then in NodeJS.</p><h3 id="7a95">Integration Tests</h3><p id="1782">Integration Tests- Create a list of important internal flows with empty tests as TODOs as you develop or afterward and implement these tests one by one. Consider adding UI mocking and snapshots.</p><p id="cf48">Snapshot tests could be a good substitution for the traditional UI integration tests. Instead of testing parts of the UI after certain processes, you could snapshot parts of the application instead.</p><p id="3439">Consider using <strong>JSDom </strong>or <strong>Karma </strong>to run your tests in real browser.</p><h3 id="a7f6">Functional Tests</h3><p id="a2a6">The number of permanent tools for this purpose is somehow limited, and their implementation differs very much from each other, so it is strongly suggested to try implementing some of them before taking a decision.</p><blockquote id="b1fc">* In short, if you want to “just get started” with the most simple set-up, and if you want to test many environments easily, go with <strong>TestCafe</strong>.</blockquote><blockquote id="1d9a">* If you want to go with the flow and have maximum community support, if you need to be able to write tests not only in JS, <strong>Selenium </strong>is the way to go.</blockquote><blockquote id="4a6f">* If your application has no complex user interaction and graphics, for example, if you want to test a system full of forms and navigations, headless browser tools like <strong>Casper</strong> will provide you with the fastest tests.</blockquote><p id="9c07"><strong>SeleniumHQ</strong>, better known as just Selenium, <strong>automates the browser </strong>to simulate user behavior. It is not written specifically for tests and can control a browser for many purposes by exposing a server that simulates user behavior on a browser using an API.</p><p id="f8a0">Selenium can be controlled in many ways and using a variety programming languages, and with some tools even without any real programming.</p><p id="8d7d">To our needs, however, Selenium server is controlled by a <a href="http://seleniumhq.github.io/selenium/docs/api/javascript/index.html" target="_blank"><strong>Selenium WebDriver</strong></a>that serves as a communication layer between our NodeJS and the server that operates the browser.</p><p id="8d3e"><code>Node.js &lt;=&gt; WebDriver &lt;=&gt; Selenium Server &lt;=&gt; FF/Chrome/IE/Safari</code></p><p id="ba05">The WebDriver can be imported into your testing framework and tests can be written as part of it:</p><pre id="5048"><code>describe('login form', () <strong>=&gt;</strong> {</code></pre><pre id="ce66"><code>  before(() <strong>=&gt;</strong> {<br />    return driver.navigate().to('http://path.to.test.app/')<br />  })</code></pre><pre id="35a2"><code>  it('autocompletes the name field', () =&gt; {</code></pre><pre id="4c09"><code>    driver.findElement(By.css('.autocomplete'))<br />      .sendKeys('John')</code></pre><pre id="559e"><code>    driver.wait(until.elementLocated(By.css('.suggestion')))</code></pre><pre id="c8cd"><code>    driver.findElement(By.css('.suggestion')).click()</code></pre><pre id="ad86"><code>    <strong>return</strong> driver.findElement(By.css('.autocomplete'))<br />      .getAttribute('value')<br />      .then(inputValue <strong>=&gt;</strong> {<br />        expect(inputValue).to.equal('John Doe')<br />      })<br />  })<br /><br />after(() <strong>=&gt;</strong> {<br />    return driver.quit()<br />  })</code></pre><pre id="a060"><code>})</code></pre><p id="b912">The WebDriver itself might be sufficient for you and indeed<a href="https://marmelab.com/blog/2016/04/19/e2e-testing-with-node-and-es6.html" target="_blank"> some people </a>suggest using it as it is but various libraries were created to extend it wether by forking and altering it or by wrapping it.</p><p id="6401">And indeed wrapping the WebDriver might add redundant code and could make debugging harder and forking it might diverge it from <a href="https://github.com/SeleniumHQ/selenium/tree/master/javascript" target="_blank">the very active (as for 2017) ongoing development</a> of it.</p><p id="a27a">Still some people prefer to not use it directly. Let’s look at some of libraries for selenium operating:</p><p id="b4ab"><strong>Protractor </strong>is a library that wraps <a href="http://www.seleniumhq.org/" target="_blank">Selenium</a> to add it an improved syntax and special in-built hooks for <strong>Angular.</strong></p><ul><li id="637e"><strong>Angular-</strong> Has special hooks, although can be successfully used with other JS frameworks too.</li><li id="b5e2"><strong>Error reporting</strong>- Good mechanism.</li><li id="ad6f"><strong>Mobile</strong>- No support to automate mobile Apps.</li><li id="bf68"><strong>Support</strong>- TypeScript support is available and the library is operated and maintained by the huge Angular team.</li></ul><p id="06ed"><strong>WebdriverIO </strong>has it’s own implementation of the selenium WebDriver.</p><ul><li id="0e81"><strong>Syntax</strong>- very easy and readable.</li><li id="0631"><strong>Flexible</strong>- A very simple and agnostic from even being used for tests, flexible and extensible library.</li><li id="67f6"><strong>Community</strong>- It has good support and enthusiastic developer community that makes it reach with plugins and extensions.</li></ul><p id="c77d"><strong>Nightwatch</strong> has it’s own implementation of the selenium WebDriver. And provides it’s own testing framework with a test server, assertions, and tools.</p><ul><li id="33ec"><strong>Framework</strong>- Can be used with other frameworks too, but can be especially useful in case you want to run functional tests not as part of other framework.</li><li id="9e02"><strong>Syntax</strong>- looks the easiest and the most readable.</li><li id="9d06"><strong>Support</strong>- No typescript support and in general, this library seems to be slightly less supported than the others.</li></ul><p id="72bc"><strong>Casper</strong> is written on top of <strong>Phantom and Slimer </strong>(The same as Phantom but in FireFox’s Gecko)to provide navigation, scripting and testing utilities and abstracts away a lot of the complicated, asynchronous stuff when creating Phantom and Slimer scripts.</p><p id="f538">Casper and other headless browsers provide us with a faster but less stable way to run functional tests on UI-less browsers.</p><p id="90f9"><strong>TestCafe </strong>is a great alternative to Selenium-Based tools.</p><blockquote id="4db5"><strong>In October 2016, the core library of TestCafe was released as an open-source JavaScript framework. There is still a </strong><a href="https://testcafe.devexpress.com/" target="_blank"><strong>paid version</strong></a><strong> that offers non-JS tools like a test recorder and a customer support.</strong></blockquote><p id="a5bb">This is important because many outdated articles state that it’s code is closed and take it for a disadvantage.</p><p id="5ded">It injects itself into the browser’s environment as JS scripts instead of attaching to browsers using plugins like selenium does. This allows TestCafe to run on any browser, including on mobile devices. On Selenium you have to install special plugins for every device and browser.</p><p id="5aec">TestCafe is newer and more JS and test oriented. It features a very useful error reporting system that indicated the line of a failure, a very useful selectors system, and some more very useful features.</p><p id="82ad"><strong>Cucumber </strong>is another useful framework for functional testing. It is a framework that arranges the previously mentioned automated tests in a slightly different way.</p><p id="6305">Cucumber help with writing tests in BDD by dividing them between the business crew that writes acceptance criteria using the <strong>Gherkin </strong>syntax and the programmers that write their tests according to it. Tests can be written in a variety of languages that are supported by the framework, including JS that we are focusing on:</p><p id="0081"><em>features/like-article.feature: (The gherkin syntax)</em></p><pre id="d0c2">Feature: A reader can share an article to social networks<br />  As a reader<br />  I want to share articles<br />  So that I can notify my friends about an article I liked</pre><pre id="80bd">  Scenario: An article was opened<br />    Given I'm inside an article<br />    When I share the article<br />    Then the article should change to a "shared" state</pre><p id="d9dd"><em>features/stepdefinitions/like-article.steps.js</em></p><pre id="e9bf">module.exports = <strong>function</strong>() {<br />  <strong>this</strong>.Given(/^I'm inside an article$/, <strong>function</strong>(callback) {<br />    // functional testing tool code<br />  })</pre><pre id="3c3e"><strong>  this</strong>.When(/^I share the article$/, <strong>function</strong>(callback) {<br />    // functional testing tool code<br />  })<br /><br /><strong>this</strong>.Then(/^the article should change to a "shared" state$/, <strong>function</strong>(callback) {     <br />    // functional testing tool code<br />  }) <br />}</pre><p id="312d">If you think this kind of arrangement can help different crews in your company to collaborate, you can find this tool useful.</p><h3 id="3653">Contribute</h3><p id="34b7">If you have anything you want me to add or change in this very short guide, just tell me. I’ll be glad to do it. I want this guide to be as accurate, as complete and as useful as possible.</p><h3 id="6705">Conclusion</h3><p id="749d">In this very short guide, we saw the most trending testing strategies and tools in the JS community and hopefully made it easier for you to test your application.</p><p id="33b0">Remember that there are many more useful tools and strategies that this guide has not covered. Some has to do with the tools that are covered here and some are completely different.</p><blockquote id="d716">In the end, the best decisions regarding application architecture today are made by understanding general solution patterns that are developed by the very active community, and combining them with your own experience and understanding of the characteristics of your application and it’s special needs.</blockquote><blockquote id="42b4">Oh, and writing, and rewriting, and rewriting, and rewriting, and testing different solutions :)</blockquote>