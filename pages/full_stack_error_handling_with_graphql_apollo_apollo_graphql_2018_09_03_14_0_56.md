<a href="https://blog.apollographql.com/full-stack-error-handling-with-graphql-apollo-5c12da407210">https://blog.apollographql.com/full-stack-error-handling-with-graphql-apollo-5c12da407210</a><div id="articleHeader"><h1>Full Stack Error Handling with GraphQL and ApolloÂ ðŸš€</h1></div><h2 id="d7ee">Realising GraphQLâ€™s potential for errorÂ handling</h2><p id="076d">Most GraphQL layers sit between the application frontend and a constellation of micro-services and data sources, which make them a focal point for error handling. Errors can range from bad user inputs to back-end bugs to rare network outages. Since itâ€™s at the center of all the action, GraphQL has great potential to help us handle these errors in a systematic way.</p><p id="47ea">At Apollo, weâ€™ve heard a lot of desire from GraphQL developers for more guidance on how to do error handling. Thatâ€™s why weâ€™re baking in some of the best practices on error handling into Apollo Server 2.0 (which is <a href="https://dev-blog.apollodata.com/apollo-server-2-0-30c9bbb4ab5e" target="_blank">currently in beta</a>). The new enhancements will make it much easier to communicate errors to your client in an organized way, and open up new possibilities for tooling, making developing apps with GraphQL and Apollo that much easier to get started with.</p><figure id="96b5"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2F3oEduS8lEayGgIwtCo%2Fgiphy.gif&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Catching errors should be easy like this</figcaption></figure><p id="4500">On its own, the GraphQL <a href="https://facebook.github.io/graphql/October2016/#sec-Errors" target="_blank">spec</a> itself provides little guidance on how to format error responses, requiring only a <code>message</code> field with a string description of the error. This is usually insufficient for production apps:</p><ul><li id="7d56">As a front-end developer, I would like to display rich error feedback in the UI to empower my users to fix their own problems. My client also needs to gracefully handle partial failures to provide the best end-user experience.</li><li id="dec9">As a back-end developer, I would like to be able to determine the health of my service by classifying and monitoring errors programmatically.</li><li id="157b">As a package author, I would like to be able to write components/middleware that could handle errors automatically in the most appropriate way.</li></ul><p id="e2a4">Without standard error handling constructs such as the ones weâ€™re including in Apollo Server 2.0, you would end up with an arbitrary combination of network errors and GraphQL errors to tell clients what went wrong, and have to write lots of custom error handling logic.</p><p id="51bc">In this blog post, we will learn:</p><ol><li id="1277">Different types of GraphQL errors</li><li id="21bd">Best practices to deal with those errors</li><li id="5907">Practical use-cases and examples using Apollo Server 2.0</li></ol></section><section><div><div><h3 id="821e">A developerâ€™s view ofÂ errors</h3><p id="90bf">Before we dive into different strategies for handling errors, letâ€™s get up to speed on some terminology. Generally speaking, there are two dimensions along which we can categorize errors.</p><ol><li id="1747">Is it the client or server that is at fault?</li><li id="42c6">Where did the error occur?</li></ol><h4 id="c4d6">Who is at fault: Request vs ServerÂ Errors</h4><p id="d5b2">Request Errors occur when the client is at fault. There are 3 phases to a GraphQL query and client-caused errors may occur in any of them:</p><ul><li id="5126">Parse Phase: Client sent malformed GraphQL request, i.e. syntax error</li><li id="e15f">Validation Phase: Client sent inputs that failed GraphQL type checking</li><li id="f3ba">Execution Phase: Client sent bad user input (request out of range, resource not found, duplicate key) or had bad permissions (user is not authorized to perform some action).</li></ul><p id="a9f4">On the other hand, Server Errors are execution errors where the server is at fault. This could be caused by a downstream API or database failure, or some other program bug.</p><h4 id="3c06">Where the error occurred: graphQLErrors vs networkError</h4><p id="0dd9">Apollo Client also distinguishes between two kinds of errors in the GraphQL responseâ€Šâ€”â€Š<code>graphQLErrors</code> and <code>networkError</code>. Both of these fields are present on the <code>error</code> field, but they each have different semantics. The best way to think about the difference between the two is to consider wherethe error occurred.</p><ul><li id="b0cc"><code>networkError</code>: Errors that are thrown outside of your resolvers. If networkError is present in your response, it means your entire query was rejected, and therefore no data was returned. For example, the client failed to connect to your GraphQL endpoint, or some error occurred within your request middleware, or there was an error in the parse/validation phase of your query.</li><li id="786d"><code>graphQLErrors</code>: Any error that is thrown within your resolvers. Since we have multiple resolvers executing that are all potential sources of errors, we need an array to represent all of them. More importantly, <code>graphQLErrors</code> from failed resolvers can be returned alongside data/fields that resolved successfully.</li></ul></div></section><section><div><div><h3 id="7b1f">Error handling in Apollo ServerÂ 2.0</h3><p id="35fb">One of the new features in Apollo Server 2.0 is the <a href="https://www.apollographql.com/docs/apollo-server/v2/features/errors.html" target="_blank">ability to add error codes</a> to your GraphQL response. Any errors exported by Apollo Server that you throw in your resolver will augment the error response with a human-readable string in the <code>extensions.code</code> field. We are rolling out this feature with a few basic errors:</p><ul><li id="af97"><code>AuthenticationError</code>â€Šâ€”â€Šfor authentication failures</li><li id="7b51"><code>ForbiddenError</code>â€Šâ€”â€Šfor authorization failures</li><li id="328f"><code>UserInputError</code>â€Šâ€”â€Šfor validation errors on user input</li><li id="a722">As a fallback for uncaught failures, any other unknown errors thrown within your resolver will add the code <code>INTERNAL_SERVER_ERROR</code></li></ul><blockquote id="3737">In the following examples, we are using Apollo Server 2.0 (beta), which you can install like this <code>npm install apollo-server@beta</code>.</blockquote><h4 id="cd32">Throwing ApolloErrors in your resolvers</h4><p id="fe5b">Imagine you want to prevent unauthenticated users from executing certain queries. In the resolver for the protected action, you can check for the user object in the query context, and throw an <code>AuthenticationError</code> if it is not available.</p><figure id="c8fc"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F7384334%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Throwing Apollo Serverâ€™s exported errors</figcaption></figure><p id="63ed">This is how the response will look like:</p><figure id="c221"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F7384334%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Human-readable error code returned with graphQLErrors</figcaption></figure><p id="ea2c">Having well-defined error codes in your error responses lays the groundwork to make GraphQL errors more actionable and universal. The benefits of using them consistently throughout our application stack are pretty compelling:</p><ul><li id="4fe3">Error handlers can read the error codes to distinguish between transient errors (like expired authentication tokens) vs non-transient errors (bad user input), and possibly retry the transient errors automatically.</li><li id="87e8">Packages and applications can use the standard error codes to build out an error-aware ecosystem of tooling. For example, we can filter out service-level errors that reflect the health of the API, while ignoring errors caused by bad user input.</li></ul><h4 id="95af"><strong>Automatic Re-authentication</strong></h4><p id="deff">If you are using JSON Web Tokens to authenticate the origin of a request, you will need some way to refresh the token when it expires, all without impacting the user experience (like forcing the user to authenticate again with their username and password). Having well defined error codes, we can easily use <a href="https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-error" target="_blank">apollo-link-error</a> to alter the request flow of a GraphQL request that failed to authenticate. Here is a code example that uses <a href="https://github.com/apollographql/apollo-client/tree/master/packages/apollo-boost" target="_blank">Apollo Boost</a>:</p><figure id="8416"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F7384334%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Reauthenticating requests with apollo-link-error</figcaption></figure><p id="4a57">We can visualize the modified request flow with this diagram:</p><figure id="017d"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/60/1*VkQmJM6MU1YvM1WzMJcbew.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/1600/1*VkQmJM6MU1YvM1WzMJcbew.png" /></div></figure><p id="fc6a">The great thing about this approach is that it happens entirely at the request level, intercepting and handling a failing request. Your view layer can remain blissfully unaware of what had just happened.</p><p id="a25a">We can do the exact same thing for network errors, by adding an <code>apollo-link-retry</code> <a href="https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-retry" target="_blank">link</a> to your link chain. It comes with some additional niceties like specifying a retry strategy with <a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank">exponential backoff and random delays</a>.</p><p id="6ab4"><strong>Takeaway: Strive to handle recoverable/transient errors in the link layer to reduce complexity in the view layer.</strong></p></section><section><div><div><h3 id="ca7b">Handling user levelÂ errors</h3><p id="e1c6">At this point, hopefully we have done a good job of dealing with most service level errors nicely, and found ways to smooth over its impact on the user experience. However, users can frequently be the source of errors as well.</p><p id="93b5">Even a well-meaning user or client will not always send data that your GraphQL endpoint expects, so every application needs to validate user input rigorously. In GraphQL, there are two levels of validation errors that could occur:</p><h4 id="ab28">GraphQL Type Validation</h4><p id="b18a">In GraphQL, we automatically benefit from a strongly typed schemaâ€Šâ€”â€Šany time a user types in a <code>string</code> when an <code>int</code> was expected as input, an error is thrown from the validation phase within <a href="https://github.com/graphql/graphql-js" target="_blank">GraphQL-JS</a>. Such errors prevent your GraphQL server from executing the query, resulting in the entire query being rejected. On the client, this shows up as a <code>networkError</code> with a message that looks like this:</p><pre id="0973">"message": "Variable \"$input\" got invalid value \"foo\"; Expected type Int; Int cannot represent non 32-bit signed integer value: foo"\</pre><p id="d6dd">In general, your application should avoid sending bad queries like this to your GraphQL endpoint. First, it wastes unnecessary server resources, and second, it reduces the ability to provide quick feedback to the user on the UI. I suggest that the best way to deal with type errors is to perform strong client-side validation using packages like <a href="https://github.com/chriso/validator.js" target="_blank">this</a>. If your schema is available on the client, you can also run the same <a href="https://github.com/graphql/graphql-js/tree/master/src/validation" target="_blank">validation step</a> GraphQL-JS provides before sending a request.</p><h4 id="d2d2">Custom Validation in your resolvers</h4><p id="739c">However, validation is surely more than just checking whether the input types match what is expected by the schemaâ€Šâ€”â€Šwe need to make sure that the inputs are semantically correct. Say you would like to create an app that allows users to post events that are happening in town. The schema for an Event might look something like this.</p><figure id="179c"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F7384334%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Example schema for an Event</figcaption></figure><p id="6209">Notice there are already multiple ways that the user could send invalid inputs. He might enter a date in the past, use a duplicate event name, or enter an invalid URL for the display photo. Checks against these types of mistakes typically require the use of server-side data, and should live in your GraphQL resolvers.</p><h4 id="5e67"><strong>Throwing BadUserInputError in resolvers</strong></h4><p id="62e4">Throwing <code>UserInputError</code> from Apollo Server gives us a really convenient way of adding field-level validation error information to the error response. Notice that the second argument to <code>UserInputError</code> allows you to specify these additional properties to include. A simple example is as follows:</p><figure id="de01"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F7384334%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Performing custom validation and throwing BadUserInputError</figcaption></figure><p id="1cbd">Failing validation, here is how the response will look on the client:</p><figure id="1a77"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F7384334%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Example response of how validation errors will be seen by the client</figcaption></figure><p id="c60d">While convenient, the weakness of this approach is that the format of the validation error messages is not captured by your schema, making it brittle to changes. Unless you maintain tight control of both server and client, you should keep the error responses as simple as possible.</p><p id="3ff6">For mutations, it can be worthwhile defining these validation errors as first class citizens within your schema. For more, you can look at the <a href="https://www.apollographql.com/docs/guides/schema-design.html#mutation-responses" target="_blank">schema design guides</a>.</p><h3 id="6cf7">Handling partial failures with nullableÂ types</h3><p id="3ddf">One of the great things about using GraphQL as your API gateway is the ability to stitch together data from different back-end services, allowing the client to fetch the data it needs with a single query. While this is great if you have a microservice architecture, youâ€™ll also have to think carefully about how to handle partial failures. I strongly recommend <a href="https://medium.com/@stubailo" target="_blank">Sashko Stubailo</a>â€™s excellent post on how to use <a href="https://dev-blog.apollodata.com/using-nullability-in-graphql-2254f84c4ed7" target="_blank">nullability in GraphQL</a>, but here is a takeaway from his discussion as it relates to error handling:</p><p id="3c75"><strong>Use nullable types for fields on which partial failure is acceptable. For critical fields in your query, specify them as non-nullable so the entire query fails when those fields fail to resolve.</strong></p></section><section><div><div><h3 id="642e">Conclusion</h3><p id="fe11">Hopefully this blog post has given you some ideas on how to handle the variety of errors that we will encounter when using GraphQL. For easy reference, here is a flowchart that summarizes the thinking process for using each approach that we have discussed in this post.</p></div><div><figure id="7c3f"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/60/1*jAXRW3PCreEw9ftHnD6maw.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*jAXRW3PCreEw9ftHnD6maw.png" /></div></figure><div><blockquote id="fa08">Shoutouts: <a href="https://medium.com/@evanshauser" target="_blank">Evans Hauser</a> for his mentorship and work on Apollo Server 2.0, <a href="https://medium.com/@timbotnik" target="_blank">Tim Hingston</a> for coming up with the taxonomy of GraphQL errors, <a href="https://medium.com/@jbaxleyiii" target="_blank">James Baxley III</a> whose <a href="https://youtu.be/9Qw8HKatjy8?t=22m22s" target="_blank">talk at Apollo Day 2018</a> provided some great thinking on this subject.</blockquote><figure id="05be"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Fe.enpose.co%2F%3Fkey%3DdRXnS9Gplk%26w%3D700%26h%3D425%26url%3Dhttps%253A%252F%252Fupscri.be%252F64a355%252F%253Fenpose&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure></section>