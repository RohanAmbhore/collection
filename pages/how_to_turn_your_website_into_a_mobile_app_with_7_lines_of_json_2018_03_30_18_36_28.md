<a href="https://medium.freecodecamp.org/how-to-turn-your-website-into-a-mobile-app-with-7-lines-of-json-631c9c9895f5">https://medium.freecodecamp.org/how-to-turn-your-website-into-a-mobile-app-with-7-lines-of-json-631c9c9895f5</a><div id="articleHeader"><h1>How to Turn Your Website into a Mobile App with 7 Lines of JSON</h1></div><h2 id="c1cc">A New Approach for Blending Web Engine into Native Apps</h2><div><figure id="c857"><div><div><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*x-5_XGJJhAgiBmLe54I3xg.png" /></div></figure><p id="0ff1">What if I told you <strong>the 7 lines of JSON above, colored in orange </strong>is all you need to turn a website into a mobile app? No need to rewrite your website using some framework API just to make it behave like a mobile app. Just bring your existing website as is, and blend it into a native app with a simple URL reference.</p><p id="cf0a">And what if, just by tweaking the JSON markup a bit, you can access all the native APIs, native UI components, as well as native view transitions out of the box?</p><p id="fc5e">Here’s what a minimal example looks like in action:</p><figure id="886f"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*3MfAMbH-dNaRejGpY2Ep1A.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*3MfAMbH-dNaRejGpY2Ep1A.gif" /></div></div></div></figure><p id="bc9e">Notice how I’ve embedded a <a href="https://github.com/Jasonette" target="_blank">github.com web page</a> but the rest of the layout is all native UI components, such as <a href="https://docs.jasonette.com/document/#bodyheader" target="_blank">the navigation header</a> and the <a href="https://docs.jasonette.com/document/#tabs" target="_blank">bottom tab bar</a>. And the transition is automatically native without you having to rewrite the website using any APIs.</p><p id="0136">Before I explain how, you may ask: “That’s cool, but can you do anything meaningful other than just displaying the web page in a native app frame?”</p><p id="8b03">Great question, because that’s the main topic of this post. All you need to do is create a seamless <strong>2-way communication channel between the web view and the app</strong>, so the parent app can trigger any JavaScript functions inside the web view and the web view can reach outside to call native APIs.</p><p id="8d29">Here’s one such example:</p><figure id="e370"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*JF5Rdy1DBKD0AHzH2G6ySg.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*JF5Rdy1DBKD0AHzH2G6ySg.gif" /></div></div></div></figure><p id="e464">Note that this view contains:</p><ol><li id="ec84">Native navigation header, complete with built-in transition functionality</li><li id="9499">A Web view, which embeds a QR code generator web app</li><li id="9a13">A native chat input component at the bottom</li></ol><p id="be4d">All this can be described by just tweaking some of the JSON markup attributes we saw above.</p><p id="ffc3">Finally, note that the QR code changes as you enter something from the chat input. The chat input triggers a JavaScript function inside the QR code web app that re-generates the image.</p><p id="9993">No app development framework has tried to fundamentally solve this problem of <strong>“seamless integration of web view into native apps”</strong> because they’re all focused on picking either 100% native or 100% HTML5 side.</p><p id="0a6f">Whenever you hear someone talk about the future of mobile apps, you would probably hear them talk about <strong>“Will it be the HTML5 approach that wins out? Or will it be native?”</strong></p><p id="23c6">None of them see <code>native</code> and <code>html</code> as something that could co-exist and furthermore, create synergy and achieve things that are not easily possible otherwise.</p><p id="adc0">In this article I’m going to explain:</p><ul><li id="a8c4">Why blending web engine and native components is often a good idea.</li><li id="b826">Why a seamless integration of HTML and Native is not easy, and how I implemented one.</li><li id="c685">Most importantly, how YOU can use it to build your own app instantly.</li></ul><h3 id="0e4e">Why would you use HTML in a native app?</h3><p id="3fdf">Before we go further, let’s first discuss whether this is even a good idea, and when you may want to take this approach. Here are some potential use cases:</p><h4 id="5018">1. Use Web Native Features</h4><p id="2bdb">Some parts of your app may be better implemented using the web engine. For example, <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">Websocket</a> is a web-native feature that’s designed for the web environment. In this case it makes sense to use the built-in web engine (<strong>WKWebView for iOS </strong>and<strong> WebView for Android</strong>) instead of installing a 3rd party library that essentially <strong>“emulates”</strong> Websocket.</p><p id="3d12">No need to install additional code just to do something that you can do for free, which brings us to the next point.</p><h4 id="94da">2. Avoid Large Binary Size</h4><p id="a236">You may want to quickly incorporate features that will otherwise require a huge 3rd party library.</p><p id="0f64">For example, to incorporate a QR code image generator natively, you will need to install some 3rd party library which will increase the binary size. But if you use the web view engine and a JavaScript library through a simple <code>&lt;script src&gt;</code>, you get all that for free, and you don’t need to install any 3rd party native libraries.</p><h4 id="2f8b">3. No Reliable Mobile Library Exists</h4><p id="d9af">For some cutting edge technologies, there is no reliable and stable mobile implementation yet.</p><p id="656b">Fortunately most of these technologies have web implementations, so the most efficient way to integrate them is to use their JavaScript library.</p><h4 id="2a80">4. Build part-native, part-web-based apps</h4><p id="d307">Many new developers looking to port their website into a mobile app get discouraged or overwhelmed when they find out some of their existing website features are too complex to quickly rewrite from scratch for each mobile platform.</p><p id="243b">For example, you may have a single web page that’s too complex to immediately convert to a mobile app, but the rest of your website may be easily converted.</p><p id="39be">In this case, it would be nice if there was a way to build most of the app natively, but for that particular complex web page, somehow seamlessly integrate it into the app as HTML.</p><h3 id="679f">How does it work?</h3><h4 id="3d50">A. Jasonette</h4><p id="2592">Jasonette is an open source, markup-based approach to building cross-platform native apps.</p><p id="3f0d">It’s like a web browser, but instead of interpreting HTML markup into web pages, it interprets JSON markup into native apps on iOS and Android.</p><p id="6eab">Just like how all web browsers have exactly the same code but can deliver you all kinds of different web apps by interpreting various HTML markup on demand, all Jasonette apps have exactly the same binary, and it interprets various JSON markup on demand to create your app. The developers never need to touch the code. Instead, you build apps by writing a markup that translates to native app in real-time.</p><p id="4be7">You can learn more about Jasonette <a href="https://medium.freecodecamp.org/how-to-build-cross-platform-mobile-apps-using-nothing-more-than-a-json-markup-f493abec1873" target="_blank">here</a>.</p><p id="e94c">While Jasonette at its core is all about building native apps, this particular article is about integrating HTML into the core native engine, so let’s talk about that.</p><h4 id="fd8d">B. Jasonette Web Container</h4><p id="64a2">Native apps are great but sometimes we need to make use of web features.</p><p id="9b63">But integrating web views into a native app is a tricky business. A seamless integration requires:</p><ol><li id="d8e0"><strong>Web view should be integrated as a part of native layout:</strong> The web view should blend into the app as a part of the native layout and is treated just like any other native UI components. Otherwise it will feel clunky, and it will feel exactly like what it is — a website.</li><li id="55d2"><strong>Parent app can control child web container: </strong>The parent app should be able to freely control the child web view.</li><li id="8aab"><strong>Child web container can trigger native events on the parent app: </strong>The child app should be able to trigger the parent app’s events to run native APIs.</li></ol><p id="5279">These are a lot of work, so I first worked on only the first piece of the puzzle — <strong>simply embedding a web container into native layout</strong> — and released it as version 1:</p><p id="9460">This was already pretty useful, but it still had the limitation of being non-interactive<strong>.</strong></p><p id="25d7">The parent app couldn’t control the child web container, and the child couldn’t notify the parent of any event<strong>, keeping the web container completely isolated from the outside world.</strong></p><h4 id="b8f9">C. Jasonette Web Container 2.0: Make it Interactive</h4><p id="3afe">After releasing version 1, I experimented with the second piece of the puzzle — <strong>adding interactivity to the web container.</strong></p><p id="7c87">The next section explains the solutions that were added to make the previously-static web containers interactive, making them significantly more powerful.</p><h3 id="5bf3">Implementation: Interactive Web Container</h3><h4 id="a662"><strong>1. Load by URL</strong></h4><h4 id="8001">Problem</h4><p id="45d3">Previously in version 1, to use web container as a background view component, you had to first <a href="https://jasonette.com/webcontainer/" target="_blank">set the </a><code><a href="https://jasonette.com/webcontainer/" target="_blank">$jason.body.background.type</a></code><a href="https://jasonette.com/webcontainer/" target="_blank"> to </a><code><a href="https://jasonette.com/webcontainer/" target="_blank">"html"</a></code><a href="https://jasonette.com/webcontainer/" target="_blank"> and then hard-code the HTML text under </a><code><a href="https://jasonette.com/webcontainer/" target="_blank">$jason.body.background.text</a></code><a href="https://jasonette.com/webcontainer/" target="_blank"> attribute</a> like this:</p><pre id="851a">{<br />  "$jason": {<br />    "head": {<br />      ...<br />    },<br />    "body": {<br />      "background": {<br />        "type": "html",<br />        "text": "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"<br />      }<br />    }<br />  }<br />}</pre><p id="e8cb">Naturally people wanted to be able to instantiate the container using simply a web URL instead of having to hardcode the entire HTML text in a single line.</p><h4 id="8d44">Solution</h4><p id="081d">Web container 2.0 has added the <code>url</code> attribute. You can embed a local <code>file://</code> HTML like this (it loads from the local HTML file you ship with the app):</p><pre id="7e2c">{<br />  "$jason": {<br />    "head": {<br />      ...<br />    },<br />    "body": {<br />      "background": {<br />        "type": "html",<br />       <strong> "url": "file://index.html"<br /></strong>      }<br />    }<br />  }<br />}</pre><p id="2581">Or embed a remote <code>http[s]://</code> URL like this (it loads from a remote HTML):</p><pre id="0779">{<br />  "$jason": {<br />    "head": {<br />      ...<br />    },<br />    "body": {<br />      "background": {<br />        "type": "html",<br />        <strong>"url": "https://news.ycombinator.com"</strong><br />      }<br />    }<br />  }<br />}</pre><h4 id="bc2b"><strong>2. Parent App &lt;=&gt; Web Container Communication</strong></h4><h4 id="6a39">Problem</h4><p id="b124">Previously, web containers were only for displaying content, and not interactive. This meant <strong>NONE of the following was possible:</strong></p><ol><li id="e2fb"><strong>Jasonette =&gt; Web Container:</strong> Call JavaScript functions inside the web container from Jasonette.</li><li id="0abd"><strong>Web Container =&gt; Jasonette:</strong> Call native API from web container code.</li></ol><p id="1f45">All you could do was display the web container. This was similar to how you would embed an iframe in a web page, but the main web page had no access to what was inside the iframe.</p><h4 id="76a8">Solution</h4><p id="0761">The whole point of Jasonette is to design a standard markup language to describe cross platform mobile apps. In this case, we needed a markup language that could comprehensively describe communications between the parent app and the child web container.</p><p id="ba31">To achieve this, I came up with a <code><a href="http://www.jsonrpc.org/specification" target="_blank">JSON-RPC</a></code> based communication channel between the parent app and the child web container. Since everything on Jasonette is expressed in JSON objects, it made perfect sense to use the JSON-RPC standard format as the communication protocol.</p>