<a href="https://thorsten-hans.com/electron-crashreporter-stay-up-to-date-if-your-app-fucked-up-3e9a989cd0a0">https://thorsten-hans.com/electron-crashreporter-stay-up-to-date-if-your-app-fucked-up-3e9a989cd0a0</a><div id="articleHeader"><h1>Electron CrashReporter — stay up to date if your app fucked up!</h1></div><p id="4e0f">Everyone of us knows about those situations. You ship your app to production and you’re instantly loosing 10 pounds of weight 💪🏼, if nothing bad happens in the first 24 hours. You’re finally able to get some sleep, customers are happy, the manager is happy, <em>you are happy</em>!</p><p id="0cf8">But at some point of time your app will crash! It will definitely crash. No matter how professional you are, there are bugs! Customers will find them! And that’s <strong>okay</strong>.</p><p id="1cd6">We’ve tools and technologies to patch our software easily. We can deliver updates through stores or using plain HTTP in combination with third party libraries to instantly update an app which is already installed on a customers device.</p><p id="e663">It’s <strong>not okay</strong> to trust in your strength and the robustness of your app for 100% without expecting that some bugs may happen. <em>Don’t be that naive. </em>Use proper mechanisms to measure what’s going on. Mechanisms like Microsoft’s AppInsight and of course Electron’s built-in <em>CrashReporter</em>.</p><h3 id="e4c7">Electron — CrashReporter</h3><p id="3ffa"><em>CrashReporter</em> will send unexpected, occurred at runtime to a remote Server using either <em>HTTP</em> or <em>HTTPS</em>.</p><p id="6a58">Electron’s <em>CrashReporter</em> is an implementation of <a href="https://chromium.googlesource.com/crashpad/crashpad/+/master/README.md" target="_blank">Crashpad</a>, a powerful crash-reporting engine. <em>Crashpad</em> has been integrated into Google Chromium for macOS back in March 2015 and replaced the previous library called <em>Breakpad</em>. <strong>Breakpad on the other hand is still being used for Electron on Windows and Linux</strong>. That’s important as you’ll notice in a few seconds.</p></section><section><div><div><p id="302e">Setting up <em>CrashReporter</em> inside of an Electron app is frictionless. It’s just a simple function call with some metadata that belongs to the<strong> main process</strong>. You should initialise <em>CrashReporter</em> as early as possible in your app’s lifecycle.</p><pre id="7b7a">const {app, BrowserWindow, crashReporter} = require(‘electron’);</pre><pre id="050e">crashReporter.start({<br /> productName: ‘TaskApp’,<br /> companyName: ‘xPlatform.rocks’,<br /> submitURL: ‘<a href="http://localhost:3000/api/app-crashes%27" target="_blank">http://localhost:3000/api/app-crashes'</a><br /> uploadToServer: true<br />});</pre><p id="27a7">That’s all for Windows and Linux!</p></div></section><section><div><div><h4 id="b52f">macOS additions</h4><p id="d8ab">As already mentioned is Electron using <em>Crashpad</em> instead of <em>Breakpad</em> as foundation when executing an app on macOS. That said, you’ve to start the <em>CrashReporter</em> explicitly in both process (<em>main and renderer</em>).</p><p id="a3c2">So you should add the following snippet to the <em>renderer process</em>.</p><pre id="3788">const crashReporter = require(‘electron’).crashReporter;</pre><pre id="de06">crashReporter.start({<br /> productName: ‘TaskApp’,<br /> companyName: ‘xPlatform.rocks’,<br /> submitURL: ‘<a href="http://localhost:3000/api/app-crashes%27" target="_blank">http://localhost:3000/api/app-crashes'</a><br /> uploadToServer: true<br />});</pre><blockquote id="fd59">This code is for demonstration purpose, in your real implementation you’ll of course get rid of the duplicated code.</blockquote><h4 id="8f1c">Hint for Angular developers</h4><p id="11ca">If you’re writing your web app based on <a href="https://angular.io" target="_blank">Angular</a>, you should checkout <a href="https://medium.com/@ThorstenHans/integrating-angular-and-electron-using-ngx-electron-9c36affca25e#.lnmh473ew" target="_blank"><strong>ngx-electron</strong></a>, a small library which makes consuming <em>Electron APIs</em> in TypeScript and Angular frictionless.</p><h3 id="f57f">The server-side</h3><p id="1b1b">There are already two open source projects that you can use to get the server-side API up and running</p><p id="1a58">- <a href="https://github.com/electron/mini-breakpad-server" target="_blank">mini-breakpad-server</a><br />- <a href="https://github.com/mozilla/socorro" target="_blank">socorro</a></p><p id="e115">If you want to get it up and running in no-time, go and take one of these. Personally, I prefer integrating the server-side logic into the project’s API over having a second, dedicated API.</p><p id="5477">The following sample demonstrates how to implement the server-side API using Node.js and Express.</p><h4 id="ee58">Setup the API</h4><p id="bae7">If you’ve already a working express API, you can skip these steps, but ensure that you’ve installed <code>multer</code> package in addition to <code>express</code> itself.</p><pre id="7017">$ mkdir node-api<br />$ yarn init<br />$ yarn add express — save<br />$ yarn add multer — save<br />$ touch index.js</pre></div></section><section><div><div><h4 id="aae0">The express API implementation</h4><p id="bf26">The implementation is pretty much, straight forward. <em>CrashReporter</em> will send any <strong>crash</strong> as <code>POST</code> request to the defined API endpoint (here <code>http://localhost:3000/api/app-crashes</code>). It’s a <code>multipart/form-data</code>message, containing a dump file and the following metadata:</p><pre id="90d6">{ <br /> _companyName: ‘xPlatform.rocks’,<br /> _productName: ‘TaskApp’,<br /> _version: ‘0.1.1’,<br /> guid: ‘e47569a7-da27–4632–9bf8–1cef7f8b44b9’,<br /> platform: ‘darwin’,<br /> process_type: ‘renderer’,<br /> prod: ‘Electron’,<br /> ver: ‘1.4.15’ <br />}</pre><p id="6898">You can also add custom metadata, according to the official docs, only string properties are send successfully to the API endpoint.</p><pre id="1e03">const express = require(‘express’),<br /> multer = require(‘multer’),<br /> bodyParser = require(‘body-parser’),<br /> path = require(‘path’),<br /> fs = require(‘fs’),<br /> http = require(‘http’),<br /> miniDumpsPath = path.join(__dirname, ‘app-crashes’);</pre><pre id="1ffd">const app = express(),<br /> server = http.createServer(app)</pre><pre id="0873">let upload = multer({<br /> dest: miniDumpsPath<br />}).single(‘upload_file_minidump’);</pre><pre id="34a1">app.post(‘/api/app-crash’, upload, (req, res) =&gt; {<br /> req.body.filename = req.file.filename<br /> const crashData = JSON.stringify(req.body);</pre><pre id="7e08"> fs.writeFile(req.file.path + ‘.json’, crashData, (e) =&gt; {<br />   if (e){<br />     return console.error(‘Cant write: ‘ +  e.message);<br />   }<br />   console.info(‘crash written to file:\n\t’ + crashData);<br /> })<br /> res.end();<br />});</pre><pre id="6b06">server.listen(3000, () =&gt; {<br /> console.log(‘running on port 3000’);<br />})</pre><p id="270d">The <code>multer</code> package does a great job in dealing with <code>multipart/form-data</code> requests. Everything else is pretty self-explaining. This API is just taking all the metadata and writes it to a dedicated file. The created file will have the same name as the mini dump, but it’ll have the <code>.json</code> extension. Both files were written to the subfolder <code>app-crashes</code> .</p><p id="4a00">Start the API from the terminal using <code>node index.js</code></p><h3 id="018c">Testing CrashReporter</h3><p id="9ed4">You can easily test your CrashReporter setup using <code>process.crash()</code>from both processes like show in the following figure.</p></div><div><figure id="0ff5"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*pqPDvHDMf1TLHiezzu_Etg.png?q=20" /><div class="readableLargeImageContainer"><img /></div></figure><div><p id="8da1">From this point in time you’ll receive important information about unexpected app crashes 💣 from all your electron app instances. In combination with the dump file, it’s easier to reproduce what happened and less time consuming to find and eliminate bugs 🚀.</p><p id="8826"><em>If you liked this post, please 💚 this post and follow </em><a href="https://medium.com/@ThorstenHans" target="_blank"><em>Thorsten Hans</em></a></p></div></section>