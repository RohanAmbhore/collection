<a href="https://medium.com/styled-components/component-folder-pattern-ee42df37ec68">https://medium.com/styled-components/component-folder-pattern-ee42df37ec68</a><div id="articleHeader"><h1>Writing Scalable React Apps with the Component Folder Pattern</h1></div><h2 id="a24a"><em>Discover how to organize your React components using the </em><strong>component folder<em> pattern</em></strong><em>. It will help un-clutter your projects, and your life. It’s soon to be your new best friend.</em></h2><div><figure id="db1f"><div><div><div class="readableLargeImageContainer"><img /></div><figcaption>Photo by <a href="https://unsplash.com/photos/ImMqjoxPGGA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank">Wesley Tingey</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank">Unsplash</a></figcaption></figure><p id="909d">We’ve all seen them. The huge 400+ line god component behemoths. They can be so large, that it takes the better part of a day to get a high-level understanding of what they do.</p><p id="9b27">In this article, we will take one of these god components and break it down into bite sized and logical units of work. Then we’ll apply the <strong>component folder pattern</strong> to compartmentalize the pieces.</p><h3 id="dc16">Giphy search</h3><p id="2ec5">For our example, I’ll be using a Giphy search app whose file structure looks like this.</p><pre id="60e7">src/<br />|- App.js<br />|- GiphySearch.js</pre><p id="b522">It looks pretty simple, but everything (state, view, and data loading) are all in one component. This makes <code>GiphySearch</code> hard to maintain.</p><figure id="0ae8"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Fcodesandbox.io%2Fstatic%2Fimg%2Fbanner.png&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div><figcaption>The <em>before</em> Giphy search app on <a href="https://codesandbox.io/s/J6zVkz6Ng" target="_blank">CodeSandbox.io</a>. It works, but it’s not pretty.</figcaption></figure><p id="7f21">You can start to imagine the sub-components that we’re going to need. First we’ll need a controller that keeps the state (e.g. <code>loading</code>, <code>error</code>, and <code>data</code>). We’ll also need:</p><ul><li id="a806">A <code>SearchInput</code> component that renders the input box and calls an <code>onSearch</code> handler when the user clicks “Search”.</li><li id="f257">A <code>Loading</code> component that displays a loading indicator.</li><li id="8686">A <code>loadData</code> module that sends a search query to the Giphy API and fetches the image URL.</li><li id="e356">An <code>Image</code> component that displays the image URL.</li><li id="9095">An <code>Error</code> component in case something goes wrong.</li></ul><p id="250f">I’ll add one more component, a <code>View</code> component that selectively dispatches to the other render components. Our file system would now look something like this.</p><pre id="c938">src/<br />|- App.js<br />|- GiphyView.js<br />|- GiphySearchInput.js<br />|- GiphyImage.js<br />|- GiphyLoading.js<br />|- GiphyError.js<br />|- giphyLoadData.js</pre><p id="d6ea">A big problem with this approach is that as we add components, our <code>src</code> folder will start to fill up fast. There will be lots and lots of files, making it hard to find what you’re looking for. But to me the issue is that we are using a namespaced file structure. Guess what? That’s exactly the problem that folders solve.</p><h3 id="871e">Introducing the component folder pattern</h3><p id="e153">What can we do to logically structure all of these files? What if we placed our related files together into a single <code>GiphySearch</code> folder? This is what we do for traditional web development with an <code>index.html</code> and its supporting files. It would look like this.</p><pre id="4d96">src/<br />|- App.js<br />|- GiphySearch/<br />    |- index.js<br />    |- View.js<br />    |- SearchInput.js<br />    |- Image.js<br />    |- Loading.js<br />    |- Error.js<br />    |- loadData.js</pre><p id="e236">Nice, but what is that <code>index.js</code> file doing here and what does it do? Well notice that our <code>GiphySearch.js</code> file is now gone. We simply renamed it <code>index.js</code>.</p><p id="261e">The thing I like about this approach is that once you get your <code>GiphySearch</code> component working, collapse the folder. You’ll no longer be staring at all of those files, reducing visual clutter. Researchers at <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3072218/" target="_blank">Princeton University Neuroscience Institute</a> conducted a study that suggests reducing clutter can help you stay focused.</p><pre id="ce7e">src/<br />|- App.js<br />|- <code>GiphySearch</code>/</pre><p id="24d4">Ahh… much better. Looks a lot like the file structure that we started out with, doesn’t it?</p><p id="a4d5">Some of you are asking, “Will I have to change my <code>import</code> statements with this new file structure? After all, the code for Giphy Search is inside of a folder and in a file with a different name.” The answer is… NO! That’s the beauty of the component folder pattern.</p><p id="5630">Your app still looks something like this, no matter if the module lives in <code>GiphySearch.js</code> or <code>GiphySearch/index.js</code>. Hurray for science!</p><pre id="7b67">import <code>GiphySearch</code> from './<code>GiphySearch</code>';</pre><pre id="e23c">const App = () =&gt; (<br />  &lt;GiphySearch initialQuery="dog"/&gt;<br />);</pre><p id="7b68">Before we dive in and look at the code line-by-line, here is what our new Giphy search looks like.</p><figure id="72d6"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Fcodesandbox.io%2Fstatic%2Fimg%2Fbanner.png&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div><figcaption>The <em>after</em> version, using the injected SpinLoad. Try it out and see the code on <a href="https://codesandbox.io/s/NxqMqyxlD" target="_blank">CodeSandbox.io</a></figcaption></figure><h3 id="c3ae">Breaking it down</h3><p id="8454">Let’s look at our completed GiphySearch component and what is inside of each file. We’ll start with <code>index.js</code>. It’s sole reason for existence is to maintain state. Nothing else.</p><pre id="905d">import View from './View';<br />import loadData from './loadData';</pre><pre id="658b">export default class extends Component {<br />  state = {};<br />  load = this.load.bind(this);</pre><pre id="8df1">  async load(...args) {<br />    try {<br />      this.setState({ loading: true, error: false });<br />      const data = await loadData(...args);<br />      this.setState({ loading: false, data });<br />    } catch (ex) {<br />      this.setState({ loading: false, error: true });<br />    }<br />  }</pre><pre id="bdae">  render() {<br />    return (<br />      &lt;View {...this.props} {...this.state} onLoad={this.load} /&gt;<br />    );<br />  }<br />}</pre><p id="580c">Both <code>props</code>, <code>state</code>, and an <code>onLoad</code> callback, are passed down to the <code>View</code> component. How we get the <code>data</code> is handled by the <code>loadData</code> module. This is because neither have anything to do with state.</p><p id="bb0a">In fact, look closely. Nothing about this component has anything to do with a Giphy search. It is abstract in about every way possible. Something you could use over and over again. IMO, this is simplistic elegance.</p><blockquote id="be25">“A component should do one thing, and do it well”</blockquote><p id="7ff6">Next is the <code>View</code> component. It will determine what to render. It’s really more of a view controller, as it passes along to other render components to do the actual rendering ﹣all based on state passed in as props from <code>index.js</code>.</p><pre id="7d19">import SearchInput from './SearchInput';<br />import Image from './Image';<br />import Loading from './Loading';<br />import Error from './Error';</pre><pre id="9b01">const View = ({ <br />  loading, error, data, initialQuery, onLoad,<br />  RenderSearchInput, RenderImage, RenderLoading, RenderError,<br />}) =&gt; (<br />  &lt;div&gt;<br />    &lt;RenderSearchInput<br />      initialQuery={initialQuery} <br />      onSearch={onLoad}<br />    /&gt;<br />    &lt;section&gt;<br />      {do {<br />        if (loading) {<br />          &lt;RenderLoading /&gt;<br />        } else if (error) {<br />          &lt;RenderError error={error}/&gt;<br />        } else {<br />          &lt;RenderImage src={data} /&gt;<br />        }<br />      }}<br />    &lt;/section&gt;<br />  &lt;/div&gt;<br />);</pre><pre id="3f56">View.propTypes = {<br />  ...<br />};</pre><pre id="7019">View.defaultProps = {<br />  RenderSearchInput: SearchInput,<br />  RenderImage: Image,<br />  RenderLoading: Loading,<br />  RenderError: Error,<br />};</pre><p id="3e9e">Notice that we use <a href="http://americanexpress.io/faccs-are-an-antipattern/#component-injection---a-better-solution" target="_blank">component injection</a> to render based on <code>loading</code>, <code>error</code>, and <code>data</code> conditions (<code>RenderLoading</code>, <code>RenderError</code>, and <code>RenderImage</code> respectively). Defaults are provided if none are specified.</p><p id="ecd8">Next is the <code>loadGiphy</code> file. It uses <code>fetch</code> to hit the Giphy REST endpoint, converts the JSON to an object, and extracts the image URL. It’s rather standard, so I won’t show it here.</p><p id="213d">The rest of our render components, <code>Loading</code>, <code>Error</code>, and <code>Image</code> are simple stateless functional components, so I won’t waste column inches on them either. However, the <a href="https://codesandbox.io/s/NxqMqyxlD" target="_blank">complete source code</a> (as well as a live running example) can be found on CodeSandbox.</p><h3 id="d41a">Reference implementation pattern</h3><p id="9a21">There’s one more technique that I’d like to point out. Whenever you use a render callback to perform your rendering﹣whether that be a Function as Child (<a href="http://americanexpress.io/faccs-are-an-antipattern/" target="_blank">don’t you dare!</a>), Function as Prop (aka render prop), or component injection (what I use almost exclusively)﹣it can sometimes be advantageous to provide a default if none is specified. I refer to this as the <strong>reference implementation pattern</strong>.</p><p id="3547">This allows the consumer of your component to <em>optionally</em> pass in a render component. However, if they don’t, some sort of default or “reference” component will perform the rendering.</p><p id="94ad">Let’s override the <code>Loading</code> component and make it look a bit nicer than the default reference implementation by passing the <code>RenderLoading</code> prop.</p><pre id="4582">import GiphySearch from './GiphySearch';<br />import SpinLoad from './SpinLoad';</pre><pre id="3e76">const App = () =&gt; (<br />  &lt;div&gt;<br />    &lt;h1&gt;Giphy Search&lt;/h1&gt;<br />    &lt;GiphySearch initialQuery="dog" RenderLoading={SpinLoad} /&gt;<br />  &lt;/div&gt;<br />);</pre><p id="c3fd">Notice that we are not overriding the <code>RenderSearchInput</code>, <code>RenderImage</code>, or <code>RenderError</code> components. They will use the default reference implementations.</p><p id="ef4a">Here’s what the <code>SpinLoad</code> component, built using <a href="https://www.styled-components.com/" target="_blank">styled-components</a>, looks like.</p><pre id="f566">import styled, { keyframes } from 'styled-components';</pre><pre id="879f">const rotate360 = keyframes`<br />  from {<br />    transform: rotate(0);<br />  }<br />  to {<br />    transform: rotate(360deg);<br />  }<br />`;</pre><pre id="dc29">const Spinner = styled.div`<br />  color: #333;<br />  font-size: 18px;<br />  font-family: sans-serif;</pre><pre id="84e3">  &:before {<br />    display: inline-block;<br />    content: '';<br />    width: 18px;<br />    height: 18px;<br />    border-radius: 50%;<br />    border: solid 2px #ccc;<br />    border-bottom-color: #66c;<br />    animation: ${rotate360} 1s linear infinite;<br />    margin-right: 6px;<br />    vertical-align: bottom;<br />  }<br />`;</pre><pre id="3689">const Loading = () =&gt; (<br />  &lt;Spinner&gt;Loading&lt;/Spinner&gt;<br />);</pre><pre id="eea8">export default Loading;</pre><p id="7c00">While the reference implementation pattern may not always make sense in your component, it’s a powerful pattern to be aware of. This can aid with testing of your component, as you can inject a test implementation.</p><h3 id="b42f">Conclusion</h3><p id="6cdf">I hope you get the opportunity to take the disciplines and patterns that you’ve read about here today and apply them to your own code. The <strong>component folder pattern</strong> un-clutters your project, while the <strong>reference implementation pattern</strong> allows you to provide reasonable defaults to render callbacks<strong>. </strong>Both are my faithful companions when writing React applications.</p>