<a href="https://medium.com/@skidding/testing-react-components-30516bc6a1b3">https://medium.com/@skidding/testing-react-components-30516bc6a1b3</a><div id="articleHeader"><h1>Testing React Components</h1></div><h2 id="e6bc">Compressed knowledge from writing thousands of UI tests and a solution for making testing components easy</h2><div><figure id="8e96"><div><div><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*OBHzSbf2RPp7apOjlfLP9w.jpeg" /></div><figcaption>Photo by <a href="https://unsplash.com/photos/ogz10BWwt4k?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank">Jason Wong</a></figcaption></figure><p id="af28"><strong>Testing should make us confident.</strong> Confident that our software does what we think it does, and that it will continue to do so as we pile up functionality. But testing UI components rarely breeds confidence. Instead, it often makes us feel angry and unproductive.</p><p id="bc22">Why bring this up? Because I’ve had this problem for years, since before the days of React, and I’ve recently put a ridiculous amount of time and thought into solving it. I believe I’ve found a set of tools and practices that <strong>make testing React components as easy as writing them.</strong></p><p id="f3c8">We’ll start with two core principles and gradually dive into examples.</p><h4 id="4f0a"><strong>№1</strong> component=f(props, state) is a lie</h4><p id="3dd4">It sounds great in theory, but it breaks down when you try to test real life components. As soon as you try to load your components in isolation you realize the following:</p><pre id="4c0e">component=f(props, state, <strong>context</strong>)</pre><p id="a183">More concretely,</p><pre id="1744">component=f(props, state, <em>Redux, Router, Theme, Intl, etc</em>)</pre><p id="478f">But this still doesn’t cover the entire spectrum of reality. Namely,</p><pre id="efc1">component=f(props, state, context, <strong>globals</strong>)</pre><p id="0bdb">Not global variables, only a <em>monster</em> would use those. I mean global APIs.</p><pre id="e9b4">component=f(props, state, context, <em>fetch, localStorage, window size</em>)</pre><blockquote id="b903"><em>Testing React components is a constant challenge, but very few talk about The Struggle. Official testing examples feature basic components, but taming the Monster Components is mostly taboo. Together we’ll look the beast in the eye and talk about a simple (new) testing API that puts any component to sleep and nicely complements existing tooling like Jest & Enzyme.</em></blockquote><p id="3eb7">I used this pitch to apply to a conference. I didn’t get in (<em>sad trombone ♪</em>), but I meant every word and I still want to talk about it.</p><p id="1e14">So, let’s <em>look the beast in the eye</em> now, shall we?</p><blockquote id="8183">The following examples use Jest & Enzyme implicitly, but neither is required to use the methods I am about to present.</blockquote><p id="c76a">The usual test example we see is trivial. Perhaps a button with a callback.</p><figure id="04bf"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F250750%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="0d0f">Now let’s ensure this component does what we expect it to do.</p><figure id="db9c"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F250750%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="4d9d">No wonder testing it feels like a breeze. The component is as <em>dumb</em> as a rock.</p><p id="59df">Now let’s put a <em>real </em>component to the test. Imagine a basic auth component with a name field and a submit button. You fill in the name and submit, which triggers a <code>fetch</code> request with your data. The response is positive, your name is dispatched to the <code>Redux</code> store and cached in <code>localStorage</code>. Basic stuff.</p><p id="bb05">Try sending this component to a test renderer and this is what you’ll get:</p><pre id="ebf3">Could not find “store” in either the context or props of Connect…</pre><pre id="db1d">ReferenceError: fetch is not defined</pre><pre id="1465">ReferenceError: localStorage is not defined</pre><p id="18dd">To which our usual response is <em>Oh Lawd have mercy!</em></p><p id="4d9e">You could argue that a serious app would have an abstraction for authentication, which should be tested instead. But, as we’ll see in a moment, that has nothing to do with testing components. <strong>We should be able to progressively abstract cross-cutting concerns <em>without</em> rewriting component tests.</strong></p><p id="5c4b">At this point, based on your experience, you might have two big objections:</p><ol><li id="bb95"><em>Wait, you’re testing “containers”?</em></li><li id="425c"><em>Wait, your components interface with global APIs (eg. fetch)</em></li></ol><p id="5e08">Yes and why not.</p><p id="aa61">And I also don’t use <em>shallow</em> rendering. Which leads us to the next principle.</p><h4 id="7e83"><strong>№2 Beware of the “glue” between your units</strong></h4><p id="f02c">Even with the simple component model of React and libraries alike, components are complex entities, far more so than plain functions. So we’re tempted to extract units as <em>pure</em> as possible. But <strong>the more granular we design our units, the more space for integration error we expose.</strong></p><p id="6739">Eg. We commonly export components without their wrappers to test them alone. Which is fine, we say, because the HoCs are already tested and we can test the connecting parts. We test reducers, actions and selectors. Hell, we should even test <code>mapStateToProps</code> and <code>mapDispatchToProps</code> for complete coverage. I used to follow this school of thought, but in time realized its major flaws. So many that I dedicated a paragraph to each.</p><ul><li id="3252"><strong>Effort to test is greater than effort to implement. </strong>Good luck onboarding developers: <em>Write your first component in Day 1. Struggle to write tests for it three days later.</em></li><li id="2495"><strong>It discourages refactoring</strong>. This might be the biggest issue for me. It’s not uncommon to dig our own grave when developing software, and there’s no better way to cement an average codebase than by meticulously assigning meaning to and testing every single function.</li><li id="ea9d"><strong>More room for error.</strong> It’s enough to forget testing any small part (eg. some selector) and the entire component can malfunction even when all tests are passing.</li><li id="6631"><strong>Out of sync inputs and outputs.</strong> The component can react properly to some props, and <em>mapStateToProps</em> can return correctly based on some state, but the exported component will still fail if the props from the former test get out of sync with the return value from the latter.</li></ul><p id="bba2">It’s tempting to seek comfort in our neat little units. But if we only test the basic parts we end up outsourcing our app’s complexity — the glue that keeps everything together — to chance. It’s also tempting to let QA worry about integration, but E2E tests are a safety net, operating on a much higher level.</p><p id="f11e">The less <em>glue</em> I leave out of my component tests the more confident I am about their output, but also in the ability to reuse them. <strong>The real unit is what we plan to share and reuse. The real unit bears meaning for the end user.</strong>That’s what we should test, not what is more convenient.</p><h4 id="9d0a">OK, but the test setup is overwhelming…</h4><p id="42c1">Setting up all the <em>providers</em> and mocks for “smart” components requires most of the effort and LOC in a test file. Asserting is piece of cake once the component mounts successfully. So my question became: <strong>How to simplify the test setup and let developers focus on asserting behavior?</strong></p><blockquote id="6b93">If only there was an easy way to simulate component states by mocking inputs…</blockquote><figure id="323c"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*vzNs4HaC-IiNDTtY2BRPqg.png?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div><figcaption>Cosmos Playground</figcaption></figure><p id="7b68">Actually, there is!</p><p id="b531"><a href="https://github.com/react-cosmos/react-cosmos" target="_blank">Cosmos</a> fixtures were designed to mock every input and render components under any combination of state. And while for a long time they were only used inside the Playground UI, it became evident that they can also replace elaborate test setup—<strong>a two-in-one offering!</strong></p><h4 id="932f">What’s a fixture?</h4><p id="aec3">First, let’s see what a JSX tag is (or <em>React.createElement</em> under the hood).</p><pre id="c971">&lt;Button disabled={true}&gt;Click me maybe&lt;/Button&gt;</pre><p id="b039">It’s a declaration. In this case, it says: I want a the Button component with the <code>{ disabled: true }</code> <strong>props</strong> and the <code>Click me maybe</code> <strong>children</strong>.</p><h4 id="387d">Now, imagine a fixture as a React element on steroids…</h4><p id="6dbc">Besides Component, props and children, it can receive <strong>local state</strong><em>, </em><strong>Redux state </strong>or <strong>Router URL</strong>. Fixtures can also mock <strong>fetch</strong><em>, </em><strong>XHR</strong>or<strong>localStorage</strong>.</p><blockquote id="aa82">All these features are driven by plugins, which make the fixture <strong>a platform for mocking component states.</strong></blockquote><p id="6757">Fixtures are regular JS objects, like this one.</p><pre id="3d1f">{<br />  props: {}</pre><pre id="6bb1">  url: '/dashboard',<br /><br />localStorage: {<br />    name: 'Dan'<br />  },<br /><br />reduxState: {},<br /><br />fetch: [<br />    {<br />      matcher: '/api/login',<br />      response: {<br />        name: 'Dan'<br />      }<br />    }<br />  ]<br />}</pre><p id="d29c">Once you get used to writing these, not only will you get a component-centric dev tool for free, but writing component tests will become easy and fun. Which leads us to the newly released<a href="https://github.com/react-cosmos/react-cosmos#headless-testing" target="_blank"><strong>Cosmos Test API</strong></a><strong>.</strong></p><figure id="a0b7"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*Nh3V6vDP-fZF4YkuijHaaA.png?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div><figcaption>Fun fact: The Cosmos UI is tested using the Cosmos Test API</figcaption></figure><p id="b287">Here’s a sample of what the API looks like, but please <a href="https://github.com/react-cosmos/react-cosmos#headless-testing" target="_blank">read the docs</a> and try it out to get a taste of its power.</p><figure id="45fe"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F250750%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="0582">The goals for this abstraction were to be as thin as possible and work well with standard testing practices. I’m not completely content with the “context” naming, but I’m happy to report that the API has been peer reviewed by a number of people and battle tested at <em>ScribbleLive</em>, the company I’m currently consulting for.</p><p id="5008">I’m grateful for the opportunity to design this against a real codebase and I especially thank <a href="https://medium.com/@tmkjone" target="_blank">Thomas Mattacchione</a> for playing a pivotal role in this development. Credit for the refined surface level API goes to <a href="https://medium.com/@xav_cz" target="_blank">Xavier Cazalot</a>.</p><p id="1034"><strong>And thank you for making it so far!</strong></p><p id="4466">Before I end, I’ll share two anecdotes from my experience writing tests using the aforementioned principles and API.</p><ol><li id="023b">Even in mature codebases, I usually write ad-hoc prototypes for new features. Instead of plugging into the Redux store from the start, I might start with local state until it gets serious. More than once, I completed a fully tested prototype and then <strong>ported the local state to Redux without rewriting any test.</strong></li><li id="12cb">A stateless Form component was used on many screens. A nice abstraction, but every instance required data mapping boilerplate and lifecycle ceremony. So I wrote <em>FormConnect </em>to abstract the repetitive parts. Again, <strong>refactored a dozen app screens without rewriting any test. </strong>Why?Because those screens hadn’t changed!</li></ol>