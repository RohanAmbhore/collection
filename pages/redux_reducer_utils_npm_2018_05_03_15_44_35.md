<a href="https://www.npmjs.com/package/redux-reducer-utils">https://www.npmjs.com/package/redux-reducer-utils</a><div id="articleHeader"><h1>redux-reducer-utils</h1></div>
<p>Lightweight, no dependency library for redux reducers</p>
<h3>Install</h3>
<pre><code>npm install --save redux-reducer-utils
</code></pre>
<pre><code>yarn add redux-reducer-utils
</code></pre>
<h4>Reducer creation</h4>
<p><code>createReducer</code> provides more declarative way to describe redux reducer</p>
<p>Just call <code>createReducer</code> with initial state as argument and then
invoke chain <code>when</code> to register actions handlers, finally call <code>toFunction</code> to build reducer</p>
<div><pre><div>import {createReducer} from 'redux-reducer-utils';</div><div>const initialState = {</div><div>const reducer = createReducer(initialState)</div><div>    .when(ACTION_TYPE_1, (state, action) =&gt; ({</div><div>        ...state,</div><div>        a: state.a + action.payload,</div><div>    .when(ACTION_TYPE_4, (state, action) =&gt; ({</div><div>        ...state,</div><div>        c: state.c + action.payload,</div><div>    .toFunction();</div></pre>
<p>Here comparison classic reducer description with <code>createReducer</code> way</p>
<div><pre><div>const ACTION_TYPE_1 = 'ACTION_TYPE_1';</div><div>const ACTION_TYPE_2 = 'ACTION_TYPE_2';</div><div>const ACTION_TYPE_3 = 'ACTION_TYPE_3';</div><div>const ACTION_TYPE_4 = 'ACTION_TYPE_4';</div><div>const initialState = {</div><div>const classicReducer = (state = initialState, action) =&gt; {</div><div>    switch (action.type) {</div><div>        case ACTION_TYPE_1:</div><div>            return {</div><div>                ...state,</div><div>                a: state.a + action.payload,</div><div>        case ACTION_TYPE_2:</div><div>        case ACTION_TYPE_3:</div><div>            return {</div><div>                ...state,</div><div>                b: state.b + action.payload,</div><div>        case ACTION_TYPE_4:</div><div>            return {</div><div>                ...state,</div><div>                c: state.c + action.payload,</div><div>        default:</div><div>            return state;</div><div>const withCreateReducer = createReducer(initialState)</div><div>    .when(ACTION_TYPE_1, (state, action) =&gt; ({</div><div>        ...state,</div><div>        a: state.a + action.payload,</div><div>    })) //if you need the same handler for two or more actions types, just put array to first argument</div><div>    .when([ACTION_TYPE_2, ACTION_TYPE_3], (state, action) =&gt; ({</div><div>        ...state,</div><div>        b: state.b + action.payload,</div><div>    .when(ACTION_TYPE_4, (state, action) =&gt; ({</div><div>        ...state,</div><div>        c: state.c + action.payload,</div><div>    .toFunction();</div></pre>
<h4>Reducer composition</h4>
<p><code>composeReducers</code> This function can help with reducers horizontal scaling</p>
<p>Every <em>i</em> reducer has access to <em>i-1</em> state</p>
<div><pre><div>import {composeReducers} from 'redux-reducer-utils';</div><div>const SOME_ACTION = 'SOME_ACTION';</div><div>const initialStateFirst = {</div><div>const initialStateSecond = {</div><div>const firstReducer = (state = initialStateFirst, action) =&gt; {</div><div>    //...some actions handlers</div><div>const secondReducer = (state = initialStateSecond, action) =&gt; {</div><div>    //...here you have access to state from firstReducer</div><div>    switch (action.type) {</div><div>        case SOME_ACTION:</div><div>            return {</div><div>                ...state,</div><div>                a: state.a + action.payload,</div><div>        default:</div><div>            return state;</div><div>export const composedReducer = composeReducers(firstReducer, secondReducer, /*...any number of reducers*/);</div></pre>
