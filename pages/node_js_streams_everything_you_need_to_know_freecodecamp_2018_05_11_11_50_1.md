<a href="https://medium.freecodecamp.org/node-js-streams-everything-you-need-to-know-c9141306be93">https://medium.freecodecamp.org/node-js-streams-everything-you-need-to-know-c9141306be93</a><div id="articleHeader"><h1>Node.js Streams: Everything you need to know</h1></div><div><figure id="8e0d"><div><div><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*xGNVMFqXXTeK7ZyK2eN21Q.jpeg" /></div><figcaption><a href="https://commons.wikimedia.org/wiki/File:Urban_stream_in_park.jpg" target="_blank">Image source</a></figcaption></figure><p id="793f">Node.js streams have a reputation for being hard to work with, and even harder to understand. Well I’ve got good news for you — that’s no longer the case.</p><p id="32b5">Over the years, developers created lots of packages out there with the sole purpose of making working with streams easier. But in this article, I’m going to focus on the native <a href="https://nodejs.org/api/stream.html" target="_blank">Node.js stream API</a>.</p><blockquote id="1e8b">“Streams are Node’s best and most misunderstood idea.”</blockquote><blockquote id="a174">— Dominic Tarr</blockquote><h3 id="d498">What exactly are streams?</h3><p id="9c5f">Streams are collections of data — just like arrays or strings. The difference is that streams might not be available all at once, and they don’t have to fit in memory. This makes streams really powerful when working with large amounts of data, or data that’s coming from an external source one <em>chunk</em> at a time.</p><p id="0368">However, streams are not only about working with big data. They also give us the power of composability in our code. Just like we can compose powerful linux commands by piping other smaller Linux commands, we can do exactly the same in Node with streams.</p><figure id="48cf"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*Fp3dyVZckIUjPFOp58x-zQ.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*Fp3dyVZckIUjPFOp58x-zQ.png" /></div></div></div><figcaption>Composability with Linux commands</figcaption></figure><pre id="c91e">const grep = ... // A stream for the grep output<br />const wc = ... // A stream for the wc input</pre><pre id="add5">grep.pipe(wc)</pre><p id="f242">Many of the built-in modules in Node implement the streaming interface:</p><figure id="a882"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*lhOvZiDrVbzF8_l8QX3ACw.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*lhOvZiDrVbzF8_l8QX3ACw.png" /></div></div></div><figcaption>Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption></figure><p id="3dd9">The list above has some examples for native Node.js objects that are also readable and writable streams. Some of these objects are both readable and writable streams, like TCP sockets, zlib and crypto streams.</p><p id="fbdf">Notice that the objects are also closely related. While an HTTP response is a readable stream on the client, it’s a writable stream on the server. This is because in the HTTP case, we basically read from one object (<code>http.IncomingMessage</code>) and write to the other (<code>http.ServerResponse</code>).</p><p id="69f4">Also note how the <code>stdio</code> streams (<code>stdin</code>, <code>stdout</code>, <code>stderr</code>) have the inverse stream types when it comes to child processes. This allows for a really easy way to pipe to and from these streams from the main process <code>stdio</code> streams.</p><h3 id="7ce9">A streams practical example</h3><p id="2790">Theory is great, but often not 100% convincing. Let’s see an example demonstrating the difference streams can make in code when it comes to memory consumption.</p><p id="4234">Let’s create a big file first:</p><pre id="ee57">const fs = require('fs');<br />const file = fs.createWriteStream('./big.file');<br /><br />for(let i=0; i&lt;= 1e6; i++) {<br />  file.write('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n');<br />}<br /><br />file.end();</pre><p id="3754">Look what I used to create that big file. A writable stream!</p><p id="aa45">The <code>fs</code> module can be used to read from and write to files using a stream interface. In the example above, we’re writing to that <code>big.file</code> through a writable stream 1 million lines with a loop.</p><p id="7bf2">Running the script above generates a file that’s about ~400 MB.</p><p id="c4cb">Here’s a simple Node web server designed to exclusively serve the <code>big.file</code>:</p><pre id="f070">const fs = require('fs');<br />const server = require('http').createServer();<br /><br />server.on('request', (req, res) =&gt; {<br />  fs.readFile('./big.file', (err, data) =&gt; {<br />    if (err) throw err;<br /><br />res.end(data);<br />  });<br />});<br /><br />server.listen(8000);</pre><p id="c7e9">When the server gets a request, it’ll serve the big file using the asynchronous method, <code>fs.readFile</code>. But hey, it’s not like we’re blocking the event loop or anything. Every thing is great, right? Right?</p><p id="ca4c">Well, let’s see what happens when we run the server, connect to it, and monitor the memory while doing so.</p><p id="f48c">When I ran the server, it started out with a normal amount of memory, 8.7 MB:</p><figure id="33b0"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*125_8HQ4KzJkeBcj1LcEiQ.png?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div></figure><p id="e1d0">Then I connected to the server. Note what happened to the memory consumed:</p><figure id="331e"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*SGJw31T5Q9Zfsk24l2yirg.gif?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div></figure><p id="5e55">Wow — the memory consumption jumped to 434.8 MB.</p><p id="28c9">We basically put the whole <code>big.file</code> content in memory before we wrote it out to the response object. This is very inefficient.</p><p id="65fd">The HTTP response object (<code>res</code> in the code above) is also a writable stream. This means if we have a readable stream that represents the content of <code>big.file</code>, we can just pipe those two on each other and achieve mostly the same result without consuming ~400 MB of memory.</p><p id="060e">Node’s <code>fs</code> module can give us a readable stream for any file using the <code>createReadStream</code> method. We can pipe that to the response object:</p><pre id="cdc8">const fs = require('fs');<br />const server = require('http').createServer();<br /><br />server.on('request', (req, res) =&gt; {<br />  <strong>const src = fs.createReadStream('./big.file');</strong><br />  <strong>src.pipe(res);</strong><br />});<br /><br />server.listen(8000);</pre><p id="df0b">Now when you connect to this server, a magical thing happens (look at the memory consumption):</p><figure id="bc29"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*iWNNIMhF9QmD25Vho6-fRQ.gif?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div></figure><p id="efa8"><em>What’s happening?</em></p><p id="9197">When a client asks for that big file, we stream it one chunk at a time, which means we don’t buffer it in memory at all. The memory usage grew by about 25 MB and that’s it.</p><p id="de87">You can push this example to its limits. Regenerate the <code>big.file</code> with five million lines instead of just one million, which would take the file to well over 2 GB, and that’s actually bigger than the default buffer limit in Node.</p><p id="7253">If you try to serve that file using <code>fs.readFile</code>, you simply can’t, by default (you can change the limits). But with <code>fs.createReadStream</code>, there is no problem at all streaming 2 GB of data to the requester, and best of all, the process memory usage will roughly be the same.</p><p id="4d49">Ready to learn streams now?</p><blockquote id="bd9e">This article is a write-up of part of <a href="https://www.pluralsight.com/courses/nodejs-advanced" target="_blank">my Pluralsight course about Node.js</a>. I cover similar content in video format there.</blockquote><h3 id="4fc8">Streams 101</h3><p id="fa57">There are four fundamental stream types in Node.js: Readable, Writable, Duplex, and Transform streams.</p><ul><li id="9ef7">A readable stream is an abstraction for a source from which data can be consumed. An example of that is the <code>fs.createReadStream</code> method.</li><li id="1183">A writable stream is an abstraction for a destination to which data can be written. An example of that is the <code>fs.createWriteStream</code> method.</li><li id="6ef9">A duplex streams is both Readable and Writable. An example of that is a TCP socket.</li><li id="e16d">A transform stream is basically a duplex stream that can be used to modify or transform the data as it is written and read. An example of that is the <code>zlib.createGzip</code> stream to compress the data using gzip. You can think of a transform stream as a function where the input is the writable stream part and the output is readable stream part. You might also hear transform streams referred to as “<em>through streams</em>.”</li></ul><p id="1058">All streams are instances of <code>EventEmitter</code>. They emit events that can be used to read and write data. However, we can consume streams data in a simpler way using the <code>pipe</code> method.</p><h4 id="76d5">The pipe method</h4><p id="29cf">Here’s the magic line that you need to remember:</p><pre id="1f3f"><strong>readableSrc</strong>.pipe(<strong>writableDest</strong>)</pre><p id="248d">In this simple line, we’re piping the output of a readable stream — the source of data, as the input of a writable stream — the destination. The source has to be a readable stream and the destination has to be a writable one. Of course, they can both be duplex/transform streams as well. In fact, if we’re piping into a duplex stream, we can chain pipe calls just like we do in Linux:</p><pre id="0c9e">readableSrc<br />  .pipe(transformStream1)<br />  .pipe(transformStream2)<br />  .pipe(finalWrtitableDest)</pre><p id="068a">The <code>pipe</code> method returns the destination stream, which enabled us to do the chaining above. For streams <code>a</code> (readable), <code>b</code> and <code>c</code> (duplex), and <code>d</code> (writable), we can:</p><pre id="8b50">a.pipe(b).pipe(c).pipe(d)</pre><pre id="175f"># Which is equivalent to:<br />a.pipe(b)<br />b.pipe(c)<br />c.pipe(d)</pre><pre id="16bb"># Which, in Linux, is equivalent to:<br />$ a | b | c | d</pre><p id="52de">The <code>pipe</code> method is the easiest way to consume streams. It’s generally recommended to either use the <code>pipe</code> method or consume streams with events, but avoid mixing these two. Usually when you’re using the <code>pipe</code> method you don’t need to use events, but if you need to consume the streams in more custom ways, events would be the way to go.</p><h4 id="a9a7">Stream events</h4><p id="a8cc">Beside reading from a readable stream source and writing to a writable destination, the <code>pipe</code> method automatically manages a few things along the way. For example, it handles errors, end-of-files, and the cases when one stream is slower or faster than the other.</p><p id="b0ec">However, streams can also be consumed with events directly. Here’s the simplified event-equivalent code of what the <code>pipe</code> method mainly does to read and write data:</p><pre id="3a57"># readable.pipe(writable)</pre><pre id="2976">readable.on('data', (chunk) =&gt; {<br />  writable.write(chunk);<br />});</pre><pre id="46a0">readable.on('end', () =&gt; {<br />  writable.end();<br />});</pre><p id="8dda">Here’s a list of the important events and functions that can be used with readable and writable streams:</p><figure id="90b6"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*HGXpeiF5-hJrOk_8tT2jFA.png?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div><figcaption>Screenshot captured from my Pluralsight course - Advanced Node.js</figcaption></figure><p id="2145">The events and functions are somehow related because they are usually used together.</p><p id="112d">The most important events on a readable stream are:</p><ul><li id="5a30">The <code>data</code> event, which is emitted whenever the stream passes a chunk of data to the consumer</li><li id="432d">The <code>end</code> event, which is emitted when there is no more data to be consumed from the stream.</li></ul><p id="d399">The most important events on a writable stream are:</p><ul><li id="be46">The <code>drain</code> event, which is a signal that the writable stream can receive more data.</li><li id="44ff">The <code>finish</code> event, which is emitted when all data has been flushed to the underlying system.</li></ul><p id="2222">Events and functions can be combined to make for a custom and optimized use of streams. To consume a readable stream, we can use the <code>pipe</code>/<code>unpipe</code> methods, or the <code>read</code>/<code>unshift</code>/<code>resume</code> methods. To consume a writable stream, we can make it the destination of <code>pipe</code>/<code>unpipe</code>, or just write to it with the <code>write</code> method and call the <code>end</code> method when we’re done.</p><h4 id="c545">Paused and Flowing Modes of Readable Streams</h4><p id="aafb">Readable streams have two main modes that affect the way we can consume them:</p><ul><li id="07a6">They can be either in the <strong>paused</strong> mode</li><li id="c86b">Or in the <strong>flowing</strong> mode</li></ul><p id="a855">Those modes are sometimes referred to as pull and push modes.</p><p id="b4c6">All readable streams start in the paused mode by default but they can be easily switched to flowing and back to paused when needed. Sometimes, the switching happens automatically.</p><p id="f309">When a readable stream is in the paused mode, we can use the <code>read()</code> method to read from the stream on demand, however, for a readable stream in the flowing mode, the data is continuously flowing and we have to listen to events to consume it.</p><p id="11c5">In the flowing mode, data can actually be lost if no consumers are available to handle it. This is why, when we have a readable stream in flowing mode, we need a <code>data</code> event handler. In fact, just adding a <code>data</code> event handler switches a paused stream into flowing mode and removing the <code>data</code> event handler switches the stream back to paused mode. Some of this is done for backward compatibility with the older Node streams interface.</p><p id="2d98">To manually switch between these two stream modes, you can use the <code>resume()</code> and <code>pause()</code> methods.</p><figure id="2c52"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*HI-mtispQ13qm8ib5yey3g.png?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div><figcaption>Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption></figure><p id="903b">When consuming readable streams using the <code>pipe</code> method, we don’t have to worry about these modes as <code>pipe</code> manages them automatically.</p><h3 id="f248">Implementing Streams</h3><p id="830f">When we talk about streams in Node.js, there are two main different tasks:</p><ul><li id="7741">The task of <strong>implementing</strong> the streams.</li><li id="456d">The task of <strong>consuming</strong> them.</li></ul><p id="179c">So far we’ve been talking about only consuming streams. Let’s implement some!</p><p id="edba">Stream implementers are usually the ones who <code>require</code> the <code>stream</code> module.</p><h4 id="50f4">Implementing a Writable Stream</h4><p id="a35a">To implement a writable stream, we need to to use the <code>Writable</code> constructor from the stream module.</p><pre id="56dd">const { Writable } = require('stream');</pre><p id="ea6d">We can implement a writable stream in many ways. We can, for example, extend the <code>Writable</code> constructor if we want</p><pre id="8916">class myWritableStream extends Writable {<br />}</pre><p id="703e">However, I prefer the simpler constructor approach. We just create an object from the <code>Writable</code> constructor and pass it a number of options. The only required option is a <code>write</code> function which exposes the chunk of data to be written.</p><pre id="01b5">const { Writable } = require('stream');</pre><pre id="bebf">const outStream = new Writable({<br />  <strong>write</strong>(chunk, encoding, callback) {<br />    console.log(chunk.toString());<br />    callback();<br />  }<br />});<br /><br />process.stdin.pipe(outStream);</pre><p id="cbd6">This write method takes three arguments.</p><ul><li id="1bcb">The <strong>chunk</strong> is usually a buffer unless we configure the stream differently.</li><li id="d030">The <strong>encoding</strong> argument is needed in that case, but usually we can ignore it.</li><li id="8cc4">The <strong>callback</strong> is a function that we need to call after we’re done processing the data chunk. It’s what signals whether the write was successful or not. To signal a failure, call the callback with an error object.</li></ul><p id="ad6d">In <code>outStream</code>, we simply <code>console.log</code> the chunk as a string and call the <code>callback</code> after that without an error to indicate success. This is a very simple and probably not so useful <em>echo</em> stream. It will echo back anything it receives.</p><p id="b4a0">To consume this stream, we can simply use it with <code>process.stdin</code>, which is a readable stream, so we can just pipe <code>process.stdin</code> into our <code>outStream</code>.</p><p id="7c90">When we run the code above, anything we type into <code>process.stdin</code> will be echoed back using the <code>outStream</code> <code>console.log</code> line.</p><p id="7ded">This is not a very useful stream to implement because it’s actually already implemented and built-in. This is very much equivalent to <code>process.stdout</code>. We can just pipe <code>stdin</code> into <code>stdout</code> and we’ll get the exact same echo feature with this single line:</p><pre id="a0ef">process.stdin.pipe(process.stdout);</pre><h4 id="e391">Implement a Readable Stream</h4><p id="ffc5">To implement a readable stream, we require the <code>Readable</code> interface and construct an object from it:</p><pre id="5764">const { Readable } = require('stream');</pre><pre id="7f6e">const inStream = new Readable({});</pre><p id="5c6b">There is a simple way to implement readable streams. We can just directly <code>push</code> the data that we want the consumers to consume.</p><pre id="394e">const { Readable } = require('stream'); </pre><pre id="dbae">const inStream = new Readable();</pre><pre id="1391">inStream.<strong>push</strong>('ABCDEFGHIJKLM');<br />inStream.<strong>push</strong>('NOPQRSTUVWXYZ');</pre><pre id="b616">inStream.<strong>push</strong>(null); // No more data</pre><pre id="20bb">inStream.pipe(process.stdout);</pre><p id="68cd">When we <code>push</code> a <code>null</code> object, that means we want to signal that the stream does not have any more data.</p><p id="0a8c">To consume this simple readable stream, we can simply pipe it into the writable stream <code>process.stdout</code>.</p><p id="c604">When we run the code above, we’ll be reading all the data from <code>inStream</code> and echoing it to the standard out. Very simple, but also not very efficient.</p><p id="b722">We’re basically pushing all the data in the stream <em>before</em> piping it to <code>process.stdout</code>. The much better way is to push data <em>on demand</em>, when a consumer asks for it. We can do that by implementing the <code>read()</code> method in a readable stream configuration:</p><pre id="f335">const inStream = new Readable({<br />  <strong>read</strong>(size) {<br />    // there is a demand on the data... Someone wants to read it.<br />  }<br />});</pre><p id="a308">When the read method is called on a readable stream, the implementation can push partial data to the queue. For example, we can push one letter at a time, starting with character code 65 (which represents A), and incrementing that on every push:</p><pre id="866c">const inStream = new Readable({<br />  read(size) {<br />    <strong>this.push</strong>(String.fromCharCode(this.currentCharCode++));<br />    if (this.currentCharCode &gt; 90) {<br />      <strong>this.push</strong>(null);<br />    }<br />  }<br />});</pre><pre id="4c97">inStream.currentCharCode = 65;</pre><pre id="d09a">inStream.pipe(process.stdout);</pre><p id="5559">While the consumer is reading a readable stream, the <code>read</code> method will continue to fire, and we’ll push more letters. We need to stop this cycle somewhere, and that’s why an if statement to push null when the currentCharCode is greater than 90 (which represents Z).</p><p id="d8e7">This code is equivalent to the simpler one we started with but now we’re pushing data on demand when the consumer asks for it. You should always do that.</p><h4 id="ab69">Implementing Duplex/Transform Streams</h4><p id="6c27">With Duplex streams, we can implement both readable and writable streams with the same object. It’s as if we inherit from both interfaces.</p><p id="84f6">Here’s an example duplex stream that combines the two writable and readable examples implemented above:</p><pre id="758f">const { Duplex } = require('stream');<br /><br />const inoutStream = new <strong>Duplex</strong>({<br />  <strong>write</strong>(chunk, encoding, callback) {<br />    console.log(chunk.toString());<br />    callback();<br />  },<br /><br /><strong>read</strong>(size) {<br />    this.push(String.fromCharCode(this.currentCharCode++));<br />    if (this.currentCharCode &gt; 90) {<br />      this.push(null);<br />    }<br />  }<br />});<br /><br />inoutStream.currentCharCode = 65;</pre><pre id="5fae"><strong>process.stdin.pipe(inoutStream).pipe(process.stdout);</strong></pre><p id="d45e">By combining the methods, we can use this duplex stream to read the letters from A to Z and we can also use it for its echo feature. We pipe the readable <code>stdin</code> stream into this duplex stream to use the echo feature and we pipe the duplex stream itself into the writable <code>stdout</code> stream to see the letters A through Z.</p><p id="a310">It’s important to understand that the readable and writable sides of a duplex stream operate completely independently from one another. This is merely a grouping of two features into an object.</p><p id="5c37">A transform stream is the more interesting duplex stream because its output is computed from its input.</p><p id="dcee">For a transform stream, we don’t have to implement the <code>read</code> or <code>write</code> methods, we only need to implement a <code>transform</code> method, which combines both of them. It has the signature of the <code>write</code> method and we can use it to <code>push</code> data as well.</p><p id="d2a1">Here’s a simple transform stream which echoes back anything you type into it after transforming it to upper case format:</p><pre id="ea41">const { Transform } = require('stream');<br /><br />const upperCaseTr = new Transform({<br />  <strong>transform</strong>(chunk, encoding, callback) {<br />    this.push(chunk.toString().toUpperCase());<br />    callback();<br />  }<br />});<br /><br />process.stdin.pipe(upperCaseTr).pipe(process.stdout);</pre><p id="a56d">In this transform stream, which we’re consuming exactly like the previous duplex stream example, we only implemented a <code>transform()</code> method. In that method, we convert the <code>chunk</code> into its upper case version and then <code>push</code> that version as the readable part.</p><h4 id="f453">Streams Object Mode</h4><p id="22df">By default, streams expect Buffer/String values. There is an <code>objectMode</code> flag that we can set to have the stream accept any JavaScript object.</p><p id="f5ba">Here’s a simple example to demonstrate that. The following combination of transform streams makes for a feature to map a string of comma-separated values into a JavaScript object. So <code>“a,b,c,d”</code> becomes <code>{a: b, c: d}</code>.</p><pre id="6009">const { Transform } = require('stream');</pre><pre id="8588">const commaSplitter = new Transform({<br />  <strong>readableObjectMode</strong>: true,</pre><pre id="cb67">  transform(chunk, encoding, callback) {<br />    this.push(chunk.toString().trim().split(','));<br />    callback();<br />  }<br />});</pre><pre id="06ad">const arrayToObject = new Transform({<br />  <strong>readableObjectMode</strong>: true,<br />  <strong>writableObjectMode</strong>: true,</pre><pre id="bf34">  transform(chunk, encoding, callback) {<br />    const obj = {};<br />    for(let i=0; i &lt; chunk.length; i+=2) {<br />      obj[chunk[i]] = chunk[i+1];<br />    }<br />    this.push(obj);<br />    callback();<br />  }<br />});</pre><pre id="88ee">const objectToString = new Transform({<br />  <strong>writableObjectMode</strong>: true,</pre><pre id="26a1">  transform(chunk, encoding, callback) {<br />    this.push(JSON.stringify(chunk) + '\n');<br />    callback();<br />  }<br />});</pre><pre id="ff97">process.stdin<br />  .pipe(commaSplitter)<br />  .pipe(arrayToObject)<br />  .pipe(objectToString)<br />  .pipe(process.stdout)</pre><p id="a173">We pass the input string (for example, <code>“a,b,c,d”</code>) through <code>commaSplitter</code> which pushes an array as its readable data (<code>[“a”, “b”, “c”, “d”]</code>). Adding the <code>readableObjectMode</code> flag on that stream is necessary because we’re pushing an object there, not a string.</p><p id="0735">We then take the array and pipe it into the <code>arrayToObject</code> stream. We need a <code>writableObjectMode</code> flag to make that stream accept an object. It’ll also push an object (the input array mapped into an object) and that’s why we also needed the <code>readableObjectMode</code> flag there as well. The last <code>objectToString</code> stream accepts an object but pushes out a string, and that’s why we only needed a <code>writableObjectMode</code> flag there. The readable part is a normal string (the stringified object).</p><figure id="aa4b"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*u2kQzUD0ruPpt-xx0UOHoA.png?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div><figcaption>Usage of the example above</figcaption></figure><h4 id="b87f">Node’s built-in transform streams</h4><p id="0e43">Node has a few very useful built-in transform streams. Namely, the zlib and crypto streams.</p><p id="9dcd">Here’s an example that uses the <code>zlib.createGzip()</code> stream combined with the <code>fs</code> readable/writable streams to create a file-compression script:</p><pre id="017f">const fs = require('fs');<br />const zlib = require('zlib');<br />const file = process.argv[2];<br /><br />fs.createReadStream(file)<br />  .pipe(zlib.createGzip())<br />  .pipe(fs.createWriteStream(file + '.gz'));</pre><p id="b2a4">You can use this script to gzip any file you pass as the argument. We’re piping a readable stream for that file into the zlib built-in transform stream and then into a writable stream for the new gzipped file. Simple.</p><p id="24b9">The cool thing about using pipes is that we can actually combine them with events if we need to. Say, for example, I want the user to see a progress indicator while the script is working and a “Done” message when the script is done. Since the <code>pipe</code> method returns the destination stream, we can chain the registration of events handlers as well:</p><pre id="6652">const fs = require('fs');<br />const zlib = require('zlib');<br />const file = process.argv[2];<br /><br />fs.createReadStream(file)<br />  .pipe(zlib.createGzip())<br /><strong>  .on('data', () =&gt; process.stdout.write('.'))</strong><br />  .pipe(fs.createWriteStream(file + '.zz'))<br />  <strong>.on('finish', () =&gt; console.log('Done'));</strong></pre><p id="392b">So with the <code>pipe</code> method, we get to easily consume streams, but we can still further customize our interaction with those streams using events where needed.</p><p id="7bd0">What’s great about the <code>pipe</code> method though is that we can use it to <em>compose</em> our program piece by piece, in a much readable way. For example, instead of listening to the <code>data</code> event above, we can simply create a transform stream to report progress, and replace the <code>.on()</code> call with another <code>.pipe()</code> call:</p><pre id="b53d">const fs = require('fs');<br />const zlib = require('zlib');<br />const file = process.argv[2];<br /><br />const { Transform } = require('stream');<br /><br />const <strong>reportProgress</strong> = new Transform({<br />  transform(chunk, encoding, callback) {<br />    process.stdout.write('.');<br />    callback(null, chunk);<br />  }<br />});<br /><br />fs.createReadStream(file)<br />  .pipe(zlib.createGzip())<br /><strong>  .pipe(reportProgress)</strong><br />  .pipe(fs.createWriteStream(file + '.zz'))<br />  .on('finish', () =&gt; console.log('Done'));</pre><p id="45ca">This <code>reportProgress</code> stream is a simple pass-through stream, but it reports the progress to standard out as well. Note how I used the second argument in the <code>callback()</code> function to push the data inside the <code>transform()</code> method. This is equivalent to pushing the data first.</p><p id="c713">The applications of combining streams are endless. For example, if we need to encrypt the file before or after we gzip it, all we need to do is pipe another transform stream in that exact order that we needed. We can use Node’s <code>crypto</code> module for that:</p><pre id="94cd"><strong>const crypto = require('crypto');<br /></strong>// ...</pre><pre id="0b77">fs.createReadStream(file)<br />  .pipe(zlib.createGzip())<br /><strong>  .pipe(crypto.createCipher('aes192', 'a_secret'))<br /></strong>  .pipe(reportProgress)<br />  .pipe(fs.createWriteStream(file + '.zz'))<br />  .on('finish', () =&gt; console.log('Done'));</pre><p id="e56a">The script above compresses and then encrypts the passed file and only those who have the secret can use the outputted file. We can’t unzip this file with the normal unzip utilities because it’s encrypted.</p><p id="ef6b">To actually be able to unzip anything zipped with the script above, we need to use the opposite streams for crypto and zlib in a reverse order, which is simple:</p><pre id="f265">fs.createReadStream(file)<br />  .pipe(crypto.<strong>createDecipher</strong>('aes192', 'a_secret'))<br />  .pipe(zlib.<strong>createGunzip</strong>())<br />  .pipe(reportProgress)<br />  .pipe(fs.createWriteStream(file.slice(0, -3)))<br />  .on('finish', () =&gt; console.log('Done'));</pre><p id="a9c2">Assuming the passed file is the compressed version, the code above will create a read stream from that, pipe it into the crypto <code>createDecipher()</code> stream (using the same secret), pipe the output of that into the zlib <code>createGunzip()</code> stream, and then write things out back to a file without the extension part.</p><p id="210c">That’s all I have for this topic. Thanks for reading! Until next time!</p>