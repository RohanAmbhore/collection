<a href="https://blog.ghaiklor.com/profiling-nodejs-applications-1609b77afe4e">https://blog.ghaiklor.com/profiling-nodejs-applications-1609b77afe4e</a><div id="articleHeader"><h1>Profiling NodeJS applications</h1></div><p id="a1b9">In previous articles, I talked about <a href="https://medium.com/@ghaiklor/how-nodejs-works-bfe09efc80ca" target="_blank">NodeJS internals</a>, <a href="https://medium.com/@ghaiklor/why-nodejs-is-so-fast-a0ff67858f48" target="_blank">why NodeJS is so fast</a>, <a href="https://medium.com/@ghaiklor/how-v8-optimises-javascript-code-a0f3bbd46ac9" target="_blank">V8 internals</a> and its <a href="https://medium.com/@ghaiklor/optimizations-tricks-in-v8-d284b6c8b183" target="_blank">optimization tricks</a>. That’s cool, but… Understanding these things is not enough to write high-performance NodeJS applications. You still need to know, how to profile your NodeJS application, find the bottleneck and optimize it, knowing how NodeJS and V8 optimizes it.</p><figure id="38ec"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/60/1*2KUruTVCUYUlZvwSjVwMTQ.jpeg?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/1600/1*2KUruTVCUYUlZvwSjVwMTQ.jpeg" /></div></figure><h4 id="387c">Profiler</h4><p id="af42">The main goal of a profiler is to measure all the CPU ticks spent on executing functions in your application. There are also memory profilers, which can be used to find memory leaks, but in this article I’ll be talking about performance issues only.</p><p id="fe46">For instance, Google Chrome (<em>or any other modern browser</em>) has a built-in profiler in DevTools, recording all the information about functions and how long it takes to execute them into a log file. Afterwards, Google Chrome analyzes this log file, providing you with human-readable information of what’s happening (<em>Flamechart, stack, whatever</em>), so you can understand it and find the bottleneck.</p><p id="8d1f">NodeJS has a built-in profiler as well, but with one difference. It doesn’t analyze log files as Google Chrome does. Instead, it just collects all the information into log file and that’s it. It means, that you need to have some separate tool that can understand this log file and provide you with human-readable information.</p><p id="1bf6">Let’s skip the theory for now and start with a simple example. I recommend you do everything I do step by step, so you can see what’s going on on your local machine as well (<em>my NodeJS version is 5.10.1 and npm 3.8.7, I can’t guarantee this example to work for you if you have a different version of Node)</em>.</p><h4 id="ee64">Project with a bottleneck</h4><p id="0acf">Let’s imagine, that the following example is some big project with performance issues. I have chosen <em>crypto</em> module and sync version of <em>pbkdf2</em> specifically, because they decrease performance a lot and that’s what we want in this example.</p><pre id="7201">"use strict";</pre><pre id="1e51">const crypto = require('crypto');</pre><pre id="fe9e">function hash(password) {<br />  const salt = crypto.randomBytes(128).toString('base64');<br />  const hash = crypto.pbkdf2Sync(password, salt, 10000, 512);<br />  return hash;<br />}</pre><pre id="0166">// Imagine that loop below is real requests to some route<br />for (let i = 0; i &lt; 50; i++) {<br />  hash('random_password');<br />}</pre><p id="f3a2">Running this snippet gives me the following:</p><pre id="858b">~: time node server.js<br />9.24 real    9.21 user    0.02 sys</pre><p id="0cf0">We definitely have an issue with performance here — <strong>9.24 seconds</strong>.</p><p id="d95b">Let’s profile it!</p><h4 id="bd8c">Collecting ticks information into log file</h4><p id="9dd0">NodeJS has a flag which enables profiler — <em>prof</em>. When you running your application with this flag, it actually collects the CPU ticks into log file in the same folder, where your script is.</p><p id="3f13">Run NodeJS with profiler and wait for it to finish:</p><pre id="0b4b">~: node --prof server.js</pre><p id="1000">Now, you have the log file with ticks information. This log file gets a name something like <em>isolate-*.log</em>. If you try to see the content of the log file with a tool like <em>cat</em>, you will see a lot of un-readable information. That’s why we need a tool for analyze it.</p><h4 id="6eea">Analyzing log file</h4><p id="a8be">Until NodeJS 4.x you must to use separate packages like <a href="https://www.npmjs.com/package/node-tick-processor" target="_blank">node-tick-processor</a>. Since we have NodeJS 5.10.1, we can use a built-in tool.</p><p id="a891">Run NodeJS with flag <em>prof-process</em> and provide path\filename to log file, generated before. Filename will be different, so replace it with yours.</p><pre id="b2b7">~: node --prof-process isolate-0x101804a00-v8.log</pre><p id="a0d6">After some time, you will get all information about your application, including amount of processor ticks spent for each function (<em>since we have a small example, we have few lines only</em>).</p><figure id="44b8"><figcaption>Example of statistical profiling result in NodeJS application</figcaption></figure><p id="e354">As you see, <em>prof-process</em> analyzed ticks log file and now we have readable information about what’s happening in our script. It has six sections: <em>Shared libraries</em>, <em>JavaScript</em>, <em>C++</em>, <em>Summary</em>, <em>C++ entry points</em>, <em>Bottom up (heavy) profile</em>.</p><p id="47e7">I’ll explaing all of these sections another time, for now, lets look at <em>Bottom (up) heavy profile</em>. That’s the place where you get information about more heavy functions.</p><p id="4899">As we can see, 99.9% of CPU ticks are spent in <em>pbkdf2Sync</em> function in <em>crypto.js</em> module which is called from our <em>hash</em> function. This is our bottleneck. Knowing that, we can optimize it, replacing sync function with async and provide a callback that will do some stuff after hashing.</p><pre id="6b54">"use strict";</pre><pre id="fa2c">const crypto = require('crypto');</pre><pre id="1be4">function hash(password, cb) {<br />  const salt = crypto.randomBytes(128).toString('base64');<br />  const hash = crypto.pbkdf2(password, salt, 10000, 512, cb);<br />}</pre><pre id="9431">// Imagine that loop below is real requests to some route<br />for (let i = 0; i &lt; 50; i++) {<br />  hash('random_password', (error, hash) =&gt; console.log(hash));<br />}</pre><p id="7b0b">Run our modified snippet via <em>time</em>:</p><pre id="7268">~: time node server.js<br />2.64 real    9.91 user    0.07 sys</pre><p id="3157"><strong>9.24 seconds</strong> versus <strong>2.64 seconds</strong>. It runs 3.5 times faster. Now, let’s profile it again and compare profiling results with un-optimized version before:</p><pre id="0768">~: node --prof server.js<br />~: node --prof-process isolate-0x101804a00-v8.log</pre><figure id="87e4"><figcaption>Statistical profiling results of optimized version</figcaption></figure><p id="5caa">We can see now, that in <em>Bottom up (heavy) profile</em> not a lot of CPU ticks, comparing to 7431 at previous time. Also, there is no <em>hash</em> function that calls <em>pbkdf2</em>.</p><p id="ddc1">It means, we have an optimized version of our server and there are no heavy functions.</p><h4 id="e93d">Summary</h4><p id="2bcc">This was just a simple example to show you the basics of NodeJS application profiling. Knowing how to profile your applications and tools you can use to do it helps you make right decisions about what you need to optimize.</p></section><section><div><div><p id="a71b">Thanks for reading! I hope it helped you understand how to profile NodeJS applications a little bit better. Tweet <a href="https://twitter.com/ghaiklor" target="_blank">me</a> on Twitter if you have any questions or suggestions about my articles.</p><p id="c273"><em>Eugene Obrezkov aka ghaiklor, Developer Advocate at </em><a href="https://onix-systems.com" target="_blank"><em>Onix-Systems</em></a><em>, Kirovohrad, Ukraine.</em></p></div></section>