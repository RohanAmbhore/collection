<a href="https://engineroom.teamwork.com/serverless-crash-reporting-for-electron-apps-fe6e62e5982a">https://engineroom.teamwork.com/serverless-crash-reporting-for-electron-apps-fe6e62e5982a</a><div id="articleHeader"><h1>Serverless crash reporting for Electron apps</h1></div><p id="4276">The term “serverless” has been trendy for a while now. In this post, I’m going to share my experience dabbling with serverless architecture, specifically for handling crash reports from <a href="http://electron.atom.io/" target="_blank">Electron</a> apps.</p><h4 id="fd41">The conference</h4><p id="691a">I attend about two or three conferences a year, typically related to JavaScript or the Web. Some have been amazing, like <a href="http://www.nodeconf.eu/" target="_blank">NodeConf EU</a>. A few others were slightly disappointing, in that I expected to learn more. If you’re unlucky, some conferences can feel a little like a recap of the articles and books you’ve read over the previous year. Each developer at Teamwork gets one paid conference per year. This year, I decided to change things up and go for a topic I know little about, so I chose to head to New York for the first ever <a href="http://serverlessconf.io/" target="_blank">ServerlessConf</a>.</p><p id="a930">I bought a <a href="https://www.udemy.com/" target="_blank">Udemy</a> course on <a href="https://aws.amazon.com/lambda/" target="_blank">AWS Lambda</a> during a sale and the video or two I watched of that was the extent of my knowledge on serverless architecture. So what does “serverless” even mean? I’m not sure anyone knows really, but more on that later. The idea with Lambda is that once you supply some code (a stateless “function”) in one of the supported languages, you can trigger it via an API you configure, other events, or on a schedule (think Cron). The typical example is creating thumbnails whenever an image is added to a particular <a href="https://aws.amazon.com/s3/" target="_blank">S3</a> bucket.</p><figure id="7215"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/60/0*PunR2epJ6yYV0f9_.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/1600/0*PunR2epJ6yYV0f9_.png" /></div></figure><p id="6b09">So you push up little chunks of code which can all be written in different languages if you like and can be updated independently at any point. You only pay when your functions are executing. Compare that to setting up an API on an <a href="https://aws.amazon.com/ec2/" target="_blank">EC2</a> instance where you’ll pay even if it’s sitting there idle. By default, your functions can only execute for 3 seconds at most before being killed but that can be configured (to anything between 1–300 seconds). What’s great as well is that Lambda will completely handle scaling for you.</p><p id="52cc">The conference was good, especially for one so cheap (even though I’d have paid for some air conditioning :/). Of course some talks were basically people pushing their services but overall it was interesting. It was clear the speakers couldn’t agree on what “serverless” meant. Some implied it was about not managing your own servers or replacing a certain chunk of your server stack but keeping the rest, using third-party services and APIs at every possible chance, among others. My takeaway is that “serverless” is really about “functions as a unit of deployment” and everything else is secondary. It’s up to you how you use it.</p><p id="5ede">Most of the talks involved AWS and there were a lot of jokes at <a href="https://aws.amazon.com/api-gateway/" target="_blank">API Gateway</a>’s expense (the AWS tool you must configure to expose an API for your functions, which apparently is very awkward). Joe Emison gave an interesting <a href="http://www.slideshare.net/ServerlessConf/joe-emison-10x-product-development" target="_blank">talk</a> on using third-party services and serverless architectures to get his apps to market quickly. He essentially created thick clients leveraging services like <a href="https://firebase.google.com/" target="_blank">Firebase</a>, <a href="https://auth0.com/" target="_blank">Auth0</a>, <a href="https://www.algolia.com/" target="_blank">Algolia</a>, <a href="https://www.netlify.com/" target="_blank">Netlify</a>, <a href="https://webtask.io/" target="_blank">Webtask.io</a>, and more. I admired his cojones in pointing out that nothing AWS offers is best-in-class individually, as long as you don’t mind not having everything in one place, given that the general manager of AWS Lambda was in the front row.</p><p id="4577">Overall, I didn’t learn <em>that</em> much. A lot of the talks were high-level talks on stacks, etc. I came away optimistic and still curious about serverless architecture as well as Firebase and more.</p><h4 id="39b9">The crash reporter</h4><p id="664a">We’re currently rewriting our desktop apps to be based on Electron rather than <a href="http://nwjs.io/" target="_blank">NW.js</a>. I’m sure this is going to be the first of many posts on that so I won’t go into too much detail here. I recently wrote a book on Electron called <a href="http://shop.oreilly.com/product/9781939902344.do" target="_blank">Developing an Electron Edge</a> and while proofreading it, a nice serverless use case struck me; serverless crash reporting.</p><p id="b177">Sure, we report runtime errors to <a href="https://sentry.io/teamwork/" target="_blank">Sentry</a> when they occur in <a href="https://teamwork.com/chat" target="_blank">Teamwork Chat</a>, but what if the app crashes entirely? Well, we’re in the dark there. One of the nice features Electron has over NW.js is crash reporting. Once you set up Electron’s <code><a href="http://electron.atom.io/docs/api/crash-reporter/" target="_blank">crash-reporter</a></code> module in your main and renderer process(es), it will send a POST request to the URL you've supplied any time the app crashes with some helpful information including the type of process which died, the app version, the OS, a dump file for debugging, and more.</p><pre id="b292">const {<br /> crashReporter<br />} = require('electron');</pre><pre id="7936">crashReporter.start({<br /> productName: 'YourAppName;',<br /> companyName: 'YourCompany;',<br /> submitURL: 'https://your-domain.com/url-to-submit&amp',<br /> autoSubmit: true<br />});</pre><p id="7e5d">That’s all you need. If you want to crash your app to test this out, call process.crash in your main process or any renderer process.</p><pre id="da18"><code>const {<br />app,<br />crashReporter<br />} = require(‘electron’);<br />app.on(‘ready’, () =&gt; {<br />crashReporter.start({<br />productName: ‘YourAppName’,<br />companyName: YourCompany ‘,<br />submitURL: ‘https://your-domain.com/url-to-submit',<br />autoSubmit: true<br />});<br />setTimeout(() =&gt; {<br />process.crash()<br />}, 3000);<br />})</code> </pre><h3 id="ef39">The serverless crash reporter</h3><p id="e384">So how can we make this serverless? We could have a Lambda function which accepts a POST, uploads the dump file to S3 and then sends an error event to Sentry with the URL to the file in the metadata. Nice right? I thought so anyway. We don’t want a whole server there running and waiting for crash reports. Ideally you wouldn’t have too many of these and therefore using Lambda should be very cheap.</p><p id="286d">It would just be a fun little project too, right? Gordon (devOps) and I had been interested in testing out something serverless for awhile and it was an attractive idea given that we had a few big ongoing projects within Teamwork Chat;</p><ul><li id="fc67">Search.</li><li id="cf5c">Redoing a lot of our backend, breaking into smaller microservices using RabbitMQ, Kubernetes, and more.</li><li id="a01d">New (Electron) desktop apps.</li><li id="365c">New (native) mobile apps.</li></ul><p id="1794">Expect a few posts on those topics.</p><p id="1573">Anyway, I thought serverless crash reporting would be a nice little side-project I could throw a few hours into without needing too much knowledge on anything, so I started with the function itself.</p><p id="7768">The function</p><p id="aed0">I started out by creating an S3 bucket, grabbed some API credentials, created a new Sentry project, and grabbed its DSN. We write everything in <a href="http://engineroom.teamwork.com/coffeescript/" target="_blank">CoffeeScript at Teamwork</a> but this will only be a few lines long, what’s the harm in a little ES6?</p><p id="6b18">I quickly threw together a module which did what I wanted. To test it, I created another script which required the first file, started an API with <a href="http://expressjs.com/" target="_blank">express</a>, and called my function whenever it received a POST.</p><pre id="0b18">ravenClient = new raven.Client(config.sentryDsn, {<br /> release: options._version<br />});</pre><p id="0144">When instantiating <a href="https://github.com/getsentry/raven-node" target="_blank">Raven</a> (Sentry’s Node.js client module), it’s important to note that I’m passing the app version as the release. This will also me to browse the errors on Sentry by app version and do whatever I like with them. This very handy. Otherwise, you could have an old buggy version of your app still being used by customers filling up your error logs.</p><p id="0750">Another thing worth mentioning is that writing single-use code is jarring. There are a few best practices you could not do and it would work fine; you don’t need to clean up that variable, that callback won’t be called again, etc.</p><p id="7063">Now I could start our Electron app which calls process.crash in its main process, a POST request would be sent to the local API, the file would go to S3, and finally a Sentry event would be created. I’m not sure if this is how people typically work serverlessly. It worked for me. I could easily mock some of the calls when debugging too.</p><p id="1711">The Lambda function</p><p id="5b10">Even though I had never used Lambda, I assumed that was the easy part. As far as I knew, all I needed for Lambda was a Node.js module that exported a function with which accepted certain arguments. I thought I might have had some issues with dependencies, I didn’t expect Lambda to be installing modules from npm. I assumed all I’d need to do is bundle them up into a ZIP or something like that for Lambda to use.</p><p id="fafb">It wasn’t so easy in reality. Gordon stepped in to help out but long story short… it’s not possible to do what I had planned to do with Lambda; it doesn’t support file uploads.</p><p id="57b0">A few suggested a workaround of putting the file on S3 and have that trigger the Lambda function but the POST is not under our control. I’d have to point the crash-reporter module at an intermediary URL which would accept the file, put it on S3, and the Lambda function would take over from there. That’s back to the original problem though; if I went with that, there’s no point in using Lambda at all.</p><p id="1222">Around the same time, I started investigating the <a href="https://serverless.com/" target="_blank">Serverless Framework</a>. It looked interesting. It’s a framework for Node.js functions with CLI tools which make publishing functions easier, stuff for testing functions, and more. The idea is that AWS Lambda is one of the platforms supported by Serverless Framework, along with Google CloudFunctions and more. I think there’s a company behind it but a lot of it is <a href="https://github.com/serverless/serverless" target="_blank">open-sourced</a>, I think.</p><p id="ff52">Maybe this framework would allow me to workaround my problem or at least I could point it to another hosting provider which <em>does</em> support POSTing of files. I <a href="http://forum.serverless.com/t/no-support-for-posting-files/307" target="_blank">posted</a> in their forum and played around with it in the meantime. On closer inspection, I found it to be a bit immature and the documentation to be a little lacking. I got a few answers on my forum post but once I properly got my problem across, the answers stopped.</p><p id="0c5e">The webtask</p><p id="0352">Disappointed, I almost gave up until I remembered Webtask.io. This is what Joe Emison had used instead of Lambda and I had heard good things about its parent company, Auth0. A quick look at their site got my hopes up again. There was even a <em>free</em> plan which limited us to one execution per second, which was fine by me as I wouldn’t expect there to be many crash reports.</p><p id="3679">Based on the documentation, it looked good, powerful. There was a lot there. Almost too much even; I originally just wanted to spend a few hours on this and host my function, which would be called a “webtask” now. After spending some time with the site, I’d say it’s OK. Some things are hard to get to, but I’m told there is a dashboard in the works.</p><p id="a8dd">I had a few little hiccups with their <a href="https://www.npmjs.com/package/wt-cli" target="_blank">wt-cli</a> CLI module (because I was on Windows) but I had a dummy webtask running online somewhat quickly. My module’s function signature had to refactored a bit to be compatible but once I did that, I uploaded my webtask and triggered it by crashing my Electron app. Then I ran into some problems.</p><p id="2a96">Webtask.io has some pre-installed npm modules but if you use anything outside of those, you’ll need to bundle them into your webtask. To do this, you’ll need their another module; <a href="https://www.npmjs.com/package/webtask-bundle" target="_blank">webtask-bundle</a>. So now instead of just running wt create a.js to publish/update a webtask named a, I needed to run webtask-bundle — output b.js a.js &amp;&amp; wt create b.js — name a.</p><p id="6a2f">The bundler uses <a href="https://webpack.github.io/" target="_blank">Webpack</a> underneath so all it’s doing is traversing the requires and bundling it together into one script. One downside to this is that the native promises from Node.js can no longer be found when Promise is referenced without a Webpack bundle. Webpack must mess with globals or something, I didn’t really look into it. I just used <a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank">bluebird</a> for promises and quickly moved on. Another downside are that it bundles all dependencies, even the ones I know Webtask.io have. I don’t really mind since my script was still far below the 100KB webtask weight limit.</p><p id="cfee">Running the commands every time I found an issue was becoming tedious. Instead, I started using the Web-based webtask editor (yes, editing the Webpack output). The editor is a good idea, even though it can be buggy and it’s a bit hard to find; there is pretty much no way to navigate to it from the site. It’s handy that you can run your webtask with the click of a button in the editor and watch the real-time logs, especially when your webtask won’t even start like mine wouldn’t.</p><p id="fe0e">Side note: there isn’t any real consensus on the best way to work with webtasks. Support for <a href="https://github.com/auth0/wt-cli/pull/89" target="_blank">local debugging</a> was added recently though.</p><p id="051e">Once I got around those little problems, I started getting a 400; Script exceeds the size limit. The error is misleading. It doesn’t like that the dump file Electron is sending is 560KB, which shouldn’t be a problem. As I said earlier, webtasks are limited to 100KB and the file is being compared to this by mistake.</p><p id="53bd">One thing I should point out is the Webtask.io has a <a href="https://webtask-chat.slack.com/" target="_blank">Slack channel</a> where you can receive some much appreciated support. It was pointed out to me there that Webtask.io actually supports <a href="https://webtask.io/docs/model" target="_blank">multiple function signatures</a> and I should try one of the other options; specifically the one that uses express.</p><p id="97a1">Once I did this, limit error disappeared but I started getting a random error deep in express itself, so I tried another function signature and it worked.</p><pre id="cd3b">module.exports = function(context, req, res) {<br /> res.writeHead(200, {<br /> 'Content-Type': 'text/html '<br /> });<br /> res.end('&lt;h1&gt;Hello, world!&lt;/h1&gt;');<br />}</pre><pre id="4e45">Note: one other thing I should point out is that I needed to disable the <code>Parse body</code> and <code>Merge body</code> options in the settings for my webtask too.</pre><pre id="ca24">OK, so I got it working. Finally. Here is my webtask:</pre><pre id="b4a0">'use strict';</pre><pre id="4b58">const fs = require('fs');<br />const path = require('path');<br />const formidable = require('formidable');<br />const raven = require('raven');<br />const aws = require('aws-sdk');<br />const Promise = require('bluebird');</pre><pre id="edd2">const config = {<br />    sentryDsn: 'TODO',<br />    s3: {<br />        accessKey: 'TODO',<br />        bucket: 'TODO',<br />        secretAccessKey: 'TODO'<br />    }<br />};<br />var ravenClient, onError;</pre><pre id="729e">// req - request {Object}<br />// Returns a Promise which resolves to an {Object} containing {fields} and {files}<br />const parseFormData = (req) =&gt; {<br />    return new Promise((resolve, reject) =&gt; {<br />        formidable.IncomingForm().parse(req, (err, fields, files) =&gt; {<br />            if (err) {<br />                return reject(err);<br />            }<br />            resolve({<br />                fields: fields,<br />                files: files<br />            });<br />        });<br />    });<br />};</pre><pre id="62e9">// name - {String}<br />// contents - {String}<br />// Returns a Promise which resolves to a {String} URL<br />const uploadDumpToS3 = (name, contents) =&gt; {<br />    aws.config.update({<br />        accessKeyId: config.s3.accessKey,<br />        secretAccessKey: config.s3.secretAccessKey<br />    });<br />    const s3 = new aws.S3({<br />        params: {<br />            Bucket: config.s3.bucket<br />        }<br />    });<br />    return new Promise((resolve, reject) =&gt; {<br />        s3.upload({<br />            ACL: 'public-read',<br />            Key: name,<br />            Body: contents<br />        }, (err, data) =&gt; {<br />            if (err) {<br />                return reject(err);<br />            }<br />            resolve(data.Location);<br />        });<br />    });<br />};</pre><pre id="07c5">// context - {Object}<br />// req - {Object}<br />// res - {Object}<br />// Returns a Promise<br />module.exports = (context, req, res) =&gt; {<br />    onError = (error, options) =&gt; {<br />        if (!ravenClient) {<br />            ravenClient = new raven.Client(config.sentryDsn, {<br />                release: options._version<br />            });<br />        }</pre><pre id="1a88">ravenClient.captureException(error, options);<br />        res.end('Successfully received crash and sent event to Sentry!');<br />    }</pre><pre id="2ec4">return parseFormData(req)<br />        .then(formData =&gt; {<br />            const payload = {<br />                tags: formData.fields,<br />                extra: {}<br />            };<br />            const dump = formData.files['upload_file_minidump'];</pre><pre id="44cd">if (dump) {<br />                const contents = fs.readFileSync(dump.path).toString('utf8');</pre><pre id="1ec4">return uploadDumpToS3(dump.name, contents)<br />                    .then(url =&gt; {<br />                        payload.extra[dump.name] = url;<br />                        return payload;<br />                    });<br />            } else {<br />                return payload;<br />            }<br />        })<br />        .then((payload) =&gt; {<br />            return onError(new Error(payload.tags.process_type + ' crash'), payload);<br />        })<br />        .catch((err) =&gt; onError(err, {<br />            extra: {<br />                context: context<br />            }<br />        }));<br />};</pre><p id="4b10">One thing that’s nice is that any error that occurs in the promise chain will also be logged to Sentry.</p><p id="2639">Next up, look into creating a proper account for Teamwork (instead of using my personal one) and hooking up a nice URL like functions.teamwork.chat. Looking over the site again, it hit me; I missed that Webtask.io’s free plan only allows for “30 days webtask lifetime,” whereas the other plans are unlimited in this respect. The next plan up is $9 per month and it doesn’t support custom domains, so it’s not so cheap after all, eh?</p><p id="2dfe">The conclusion</p><p id="45b3">In the end, I decided we’ll just add an endpoint to our existing API for this. It was an interesting experiment but I’ll leave it at that for now. Overall, I found the services and tools around serverless architecture to be a bit immature and flaky. Keep in mind that I knew very little about it and didn’t want to spend a lot of time on it, but nevertheless it <em>should</em> be that easy.</p><p id="ae90">For this specific use case, there’s probably scope for a Sentry feature where a project can expose a URL which we can POST crash dumps to and events are created in the project. That would be nice.</p><p id="c819">I didn’t want to come away empty handed so along with writing this, I’ve published my serverless crash reporting function on GitHub at <a href="https://github.com/Teamwork/serverless-crash-reporting" target="_blank">Teamwork/serverless-crash-reporting</a>. Feedback is welcome, this stuff is completely new to me.</p><p id="bf33">I’m not disregarding “serverless” just yet. Last week, <a href="https://aws.amazon.com/blogs/aws/new-for-aws-lambda-environment-variables-and-serverless-application-model/" target="_blank">two new Lambda features</a> were announced by AWS. I’m going to keep an eye on it and I’m sure I’ll revisit this topic in the future.</p>