<a href="https://hackernoon.com/unit-testing-redux-connected-components-692fa3c4441c">https://hackernoon.com/unit-testing-redux-connected-components-692fa3c4441c</a><div id="articleHeader"><h1>Unit Testing Redux Connected Components</h1></div><h2 id="075f">Mocking functions and Redux store</h2><figure id="5c8d"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*bs6W6c6yYS36PcD9joLVtw.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*bs6W6c6yYS36PcD9joLVtw.png" /></div><figcaption>Testing React+Redux with Jest+Enzyme</figcaption></figure><p id="63f3">When I did my previous <a href="https://hackernoon.com/implementing-basic-component-tests-using-jest-and-enzyme-d1d8788d627a" target="_blank">post</a>, I purposefully left out how to test connected components. With components that are connected to a Redux store, it takes a little bit more effort to set up test files and write tests. For this example I am using Jest and Enzyme to do my testing. I’ll talk a little about how to test these components using mock stores and mock functions.</p><h3 id="5fe5">How do we test them?</h3><p id="b03d">I’m going to continue using my Login component as an example. The code for the component looks like this,</p><pre id="ad3c">// app/src/components/Login.js<br />import React from 'react'<br />import { connect } from 'react-redux'<br />import { loginUser } from '../actions/users'</pre><pre id="e4f2">class Login extends React.Component {</pre><pre id="f46f">constructor() {<br />  super()<br />  this.state = {<br />   username: '',<br />   password: ''<br />  }<br /> }</pre><pre id="104e">handleInputChange = (event) =&gt; {<br />  this.setState({<br />   [event.target.name]: event.target.value<br />  })<br /> }</pre><pre id="f228">handleSubmit = (event) =&gt; {<br />  event.preventDefault()<br />  this.props.login(this.state)<br /> }</pre><pre id="d268">render() {<br />  return (<br />   &lt;form id='loginForm' className='login' onSubmit={this.handleSubmit}&gt;<br />    &lt;label&gt;Username&lt;/label&gt;<br />    &lt;input id='email' onChange={this.handleInputChange} name='email' type='text' /&gt;<br />    &lt;label&gt;Password&lt;/label&gt;<br />    &lt;input id='password' onChange={this.handleInputChange} name='password' type='password' /&gt;<br />    &lt;button&gt;Submit&lt;/button&gt;<br />   &lt;/form&gt;<br />  )<br /> }<br />}</pre><pre id="8c81">function mapDispatchToProps(dispatch) {<br /> return {<br />  login: (userparams, history) =&gt; {<br />   dispatch(loginUser(userparams, history))<br />  }<br /> }<br />}</pre><pre id="8242">export default connect(mapDispatchToProps)(Login)</pre><p id="89a0">I connected this component to my Redux store and added an onSubmit event for the form which calls the handleSubmit function. I added the mapDispatchToProps function which returns my login function. This will call on my action creator and dispatch my login user action. When the form gets submitted, it should call my login function from the props which will be responsible for logging in the user.</p><p id="d299">When trying to write a test for a connected component you will probably encounter this error message,</p><figure id="5bc6"><div><img src="https://cdn-images-1.medium.com/max/2000/1*gHMaUTH-oITMPCQPtG_MHg.png" /></div></figure><p id="022e">This message is a result of Jest trying to find your Redux store, but being unable to find it. This makes sense because our test files are separate from the app so we haven’t created a store or set up Redux.</p><h4 id="d7f8">How do we fix this problem?</h4><p id="edc1">As I was researching I came across a couple different ways of fixing this problem. There are two main options, both with support from different groups. Mostly I saw a divide between testing the component as it is connected to Redux, or to test the component when not connected to Redux. I’ll talk a little about each approach and tell you what I prefer.</p><h4 id="1b4b">Testing component with mock store</h4><p id="057b">This way of testing your component, in my opinion, is not suggested. When using this approach, we are over stepping the boundaries of unit testing and instead starting to test integration. I’ll show you how to set up a mock store, but I wont show any tests with this approach.</p><p id="5376">As you can see the error message above gives us two ways in which we can fix our problem. We can explicitly create a store and pass it to our connected Login component, or we can wrap the Login component in a Redux Provider that holds the store. I would suggest using the first approach, because then there is no need to mount our component and we can instead shallow render it. <a href="https://github.com/airbnb/enzyme/blob/master/docs/api/mount.md" target="_blank">Mounting</a> requires Enzyme to render the full DOM, while <a href="https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md" target="_blank">shallow rendering</a> requires only the component to be rendered.</p><p id="1d76">One way that we can integrate the store is by using redux-mock-store to create it. To add this to you project run</p><pre id="5a96">npm install redux-mock-store --save-dev</pre><p id="287b">This will allow us to create a store to pass to our connected component. This is how we could create a mock store,</p><pre id="07e8">// app/src/components/__tests__/Login-test.js</pre><pre id="635f"><code>import configureStore from 'redux-mock-store'<br /></code> </pre><pre id="f877"><code>// create any initial state needed<br />const initialState = {};</code> </pre><pre id="97f5"><code>// here it is possible to pass in any middleware if needed into //configureStore<br />const mockStore = configureStore();<br />let wrapper;<br />let store;</code></pre><pre id="9b37">beforeEach(() =&gt; {</pre><pre id="5123">  //creates the store with any initial state or middleware needed  <br />  store = mockStore(initialState)<br />  wrapper = <em>see below...</em><br /> })</pre><p id="0566">And the two ways of passing it to our component are like this,</p><pre id="e4de">wrapper = shallow(&lt;Login store={store}/&gt;)<br />                        OR<br />// not suggested<br />wrapper = mount(&lt;Provider store={store}&lt;Login /&gt;&lt;/Provider&gt;)</pre><p id="473d">If you look at the Redux Mock Store docs, the reason the library was created was to test action creators and middleware. Already this seems like a red flag when we are using the library in a way it wasn’t originally designed for.</p><p id="2e31">With this mock store, we can test our actions that are sent to our store through action creators, and see if they match the expected actions. This is more of an integration test, and testing the whole flow of our component. It is more complex and unnecessary, than if you test all parts of the application separately. I feel there is a much easier way of testing our component to make sure it is operating properly with Redux.</p><h4 id="8f17">Testing component without Redux store</h4><p id="cc17">If we test the component when it is not connected to the Redux store, we do not have to worry about the extra work of creating a mock store. Instead we just test the functionality of our component, and see if it behaves how we expect. To do this we can simply export our unconnected component, as well as our default export of the connected component. We do this by adding export before our component like this,</p><pre id="4875">// app/src/components/Login.js<br />import React from 'react'<br />import { connect } from 'react-redux'</pre><pre id="ed07">// add export here to export the unconnected component<br /><strong>export</strong> class Login extends React.Component {</pre><pre id="10d8">    // ...code above<br />}</pre><pre id="6dca">function mapDispatchToProps(dispatch) {<br /> return {<br />  login: (userparams, history) =&gt; {<br />   dispatch(loginUser(userparams, history))<br />  }<br /> }<br />}</pre><pre id="36bb">export default connect(mapDispatchToProps)(Login)</pre><p id="46d4">Now when we import the component into our test we have to write it like this,</p><pre id="cf30">// app/src/components/__tests__/Login-test.js<br />import { Login } from '../Login'</pre><p id="9196">This imports the unconnected component rather than the default connected component.</p><p id="8746">Because we do not have a store, our mapDispatchToProps function for logging in is not supplied to our component. We can easily fix this by creating a mock function with Jest. This function will hold the place of our action creator, and we will be able to test whether it gets called. To do this we can add this code to our test file, and pass this function as our login prop,</p><pre id="3c45">// app/src/components/__tests__/Login-test.js</pre><pre id="4439">describe('Login Component', () =&gt; {<br />  let wrapper;<br />  // our mock login function to replace the one provided by mapDispatchToProps<br />  const mockLoginfn = jest.fn();<br /><br />beforeEach(() =&gt; {<br />     // pass the mock function as the login prop <br />     wrapper = shallow(&lt;Login login={mockLoginfn}/&gt;)<br />   })</pre><pre id="458f">// ...tests here...<br />}</pre><p id="b8e0">This replaces the login function passed to our component by mapDispatchToProps. <strong>It is not necessary to test that our mapDispatchToProps is properly passing our login function to the connected component, because Redux is already responsible for this</strong>. So now that our component has that function, we can test whether our function gets called when we submit our login form. The code for the test looks like this,</p><pre id="f1c6">// app/src/components/__tests__/Login-test.js\</pre><pre id="684d">describe('When the form is submitted', () =&gt; {<br />  it('should call the mock login function', () =&gt; {<br />   wrapper.find('#loginForm').simulate(<br />     'submit', <br />     {preventDefault() {}}<br />   )<br />   expect(mockLoginfn.mock.calls.length).toBe(1)<br />  })<br />})</pre><p id="1b1b">When we simulate the submission of our form, we need to pass the preventDefault function in our event object or we will get an error. This is because the handleSubmit function will call event.preventDefault(), and if we don’t include it an error occurs. Once we simulate the submit event, we can then test our mock login function to see if it was called. Our mockLoginfn is essentially a spy like you would have if you were using the Sinon library. So by checking to make sure our mockLoginfn was called once, we are verifying that when we submit the form it will call the correct prop function and send the correct action. We can also add a test where we fill in the username and password fields, and then simulate the submission. When we do that we can check our mockLoginfn to make sure it was passed the correct arguments. That would look like this,</p><pre id="ca7f">it('should be called with the email and password in the state as arguments', () =&gt; {</pre><pre id="1b62">   // fill in email field with <a href="mailto:blah@gmail.com" target="_blank">blah@gmail.com</a>     <br />   wrapper.find('#email').simulate(<br />     'change', <br />     {target: <br />       {name: 'email', value: '<a href="mailto:blah@gmail.com" target="_blank">blah@gmail.com</a>'}<br />     }<br />   )</pre><pre id="7bc6">   // fill in password field with cats  <br />   wrapper.find('#password').simulate(<br />     'change', <br />     {target: <br />        {name: 'password', value: 'cats'}<br />     }<br />   )</pre><pre id="fef8">   // simulate form submission   <br />   wrapper.find('#loginForm').simulate(<br />     'submit', <br />     {preventDefault() {}}<br />   )</pre><pre id="2f4c">   // test to see arguments used after its been submitted <br />   expect(mockLoginfn.mock.calls[1][0]).toEqual(<br />     {email: '<a href="mailto:blah@gmail.com" target="_blank">blah@gmail.com</a>', password: 'cats'}<br />   )<br />  })</pre><p id="0ece">We check the mockLoginfn.mock.calls[1] because we already called our mockLoginfn in our previous test. Calls[1] gives us an array of the arguments passed in. We only used one object, so we test the first index in the array.</p><h3 id="4b43">Summary</h3><p id="411a">In my opinion the second way of testing is much simpler and would reduce code and testing time. Usually when testing our react application we can test our Redux parts separately from the components. Since our action creators and our reducers are essentially functions, we can test them like any other Javascript function. It is not necessarily important to test the whole flow from component to action to reducer and then to the store all in one test. That would be an integration test rather than a unit test for our component. If we are able to determine that each part is operating as it should through its own unit test, then we do not need anything else. Hope this helps clear up any issues you might have writing tests for connected components!</p><h3 id="b208">Sources:</h3>