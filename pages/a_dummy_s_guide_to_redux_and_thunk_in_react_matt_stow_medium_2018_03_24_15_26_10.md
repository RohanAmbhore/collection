<a href="https://medium.com/@stowball/a-dummys-guide-to-redux-and-thunk-in-react-d8904a7005d3">https://medium.com/@stowball/a-dummys-guide-to-redux-and-thunk-in-react-d8904a7005d3</a><div id="articleHeader"><h1>A Dummy’s Guide to Redux and Thunk in React</h1></div><p id="e080">If, like me, you’ve <a href="http://redux.js.org/" target="_blank">read the Redux docs</a>, <a href="https://egghead.io/courses/getting-started-with-redux" target="_blank">watched Dan’s videos</a>, <a href="https://www.learnredux.com/" target="_blank">done Wes’ course</a> and still not quite grasped how to use Redux, hopefully this will help.</p><p id="d139">It took me a few attempts at using Redux before it clicked, so I thought I’d write down the process of converting an existing application that fetches JSON to use Redux and <a href="https://github.com/gaearon/redux-thunk" target="_blank">Redux Thunk</a>. If you don’t know what Thunk is, don’t worry too much, but we’ll use it to make asynchronous calls in the “Redux way”.</p><p id="97a4">This tutorial assumes you have a basic grasp of React and ES6/2015, but it should hopefully be easy enough to follow along regardless.</p><h3 id="75b4">The non-Redux way</h3><p id="087a">Let’s start with creating a React component in <code>components/ItemList.js</code> to fetch and display a list of items.</p><h3 id="b3b8">Laying the foundations</h3><p id="031c">First we’ll setup a static component with a <code>state</code> that contains various <code>items</code> to output, and 2 boolean states to render something different when it's loading or errored respectively.</p><pre id="35c6">import React, { Component } from 'react';</pre><pre id="c439">class ItemList extends Component {<br />    constructor() {<br />        super();</pre><pre id="d9f4">        this.state = {<br />            items: [<br />                {<br />                    id: 1,<br />                    label: 'List item 1'<br />                },<br />                {<br />                    id: 2,<br />                    label: 'List item 2'<br />                },<br />                {<br />                    id: 3,<br />                    label: 'List item 3'<br />                },<br />                {<br />                    id: 4,<br />                    label: 'List item 4'<br />                }<br />            ],<br />            hasErrored: false,<br />            isLoading: false<br />        };<br />    }</pre><pre id="43f1">    render() {<br />        if (this.state.hasErrored) {<br />            return &lt;p&gt;Sorry! There was an error loading the items&lt;/p&gt;;<br />        }</pre><pre id="d5d9">        if (this.state.isLoading) {<br />            return &lt;p&gt;Loading…&lt;/p&gt;;<br />        }</pre><pre id="f223">        return (<br />            &lt;ul&gt;<br />                {this.state.items.map((item) =&gt; (<br />                    &lt;li key={item.id}&gt;<br />                        {item.label}<br />                    &lt;/li&gt;<br />                ))}<br />            &lt;/ul&gt;<br />        );<br />    }<br />}</pre><pre id="57bd">export default ItemList;</pre><p id="17ab">It may not seem like much, but this is a good start.</p><p id="2d03">When rendered, the component should output 4 list items, but if you were to set <code>isLoading</code> or <code>hasErrored</code> to <code>true</code>, a relevant <code>&lt;p&gt;&lt;/p&gt;</code> would be output instead.</p><h3 id="67a0">Making it dynamic</h3><p id="5b0d">Hard-coding the items doesn’t make for a very useful component, so let’s fetch the <code>items</code> from a JSON API, which will also allow us to set <code>isLoading</code> and <code>hasErrored</code> as appropriate.</p><p id="1083">The response will be identical to our hard-coded list of items, but in the real world, you could pull in a list of best-selling books, latest blog posts, or whatever suits your application.</p><p id="8caa">To fetch the items, we’re going to use the aptly named <a href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API" target="_blank">Fetch API</a>. Fetch makes making requests much easier than the classic <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank">XMLHttpRequest</a> and returns a promise of the resolved response (which is important to Thunk). Fetch isn’t available in all browsers, so you’ll need to add it as a dependency to your project with:</p><pre id="f269">npm install whatwg-fetch --save</pre><p id="a0e5">The conversion is actually quite simple.</p><ul><li id="cbd0">First we’ll set our initial <code>items</code> to an empty array <code>[]</code></li><li id="b01d">Now we’ll add a method to fetch the data and set the loading and error states:</li></ul><pre id="f345">fetchData(url) {<br />    this.setState({ isLoading: true });</pre><pre id="199e">    fetch(url)<br />        .then((response) =&gt; {<br />            if (!response.ok) {<br />                throw Error(response.statusText);<br />            }</pre><pre id="6389">            this.setState({ isLoading: false });</pre><pre id="964b">            return response;<br />        })<br />        .then((response) =&gt; response.json())<br />        .then((items) =&gt; this.setState({ items })) // ES6 property value shorthand for { items: items }<br />        .catch(() =&gt; this.setState({ hasErrored: true }));<br />}</pre><ul><li id="0f18">Then we’ll call it when the component mounts:</li></ul><pre id="217c">componentDidMount() {<br />  this.fetchData('http://5826ed963900d612000138bd.mockapi.io/items');<br />}</pre><p id="f587">Which leaves us with <em>(unchanged lines omitted)</em>:</p><pre id="9c92">class ItemList extends Component {<br />    constructor() {<br />        this.state = {<br />            items: [],<br />        };<br />    }</pre><pre id="7b2a">    fetchData(url) {<br />        this.setState({ isLoading: true });</pre><pre id="5147">        fetch(url)<br />            .then((response) =&gt; {<br />                if (!response.ok) {<br />                    throw Error(response.statusText);<br />                }</pre><pre id="7f1d">                this.setState({ isLoading: false });</pre><pre id="ca05">                return response;<br />            })<br />            .then((response) =&gt; response.json())<br />            .then((items) =&gt; this.setState({ items }))<br />            .catch(() =&gt; this.setState({ hasErrored: true }));<br />    }</pre><pre id="2eed">    componentDidMount() {<br />        this.fetchData('http://5826ed963900d612000138bd.mockapi.io/items');<br />    }</pre><pre id="c93e">    render() {<br />    }<br />}</pre><p id="67b4">And that’s it. Your component now fetches the <code>items</code> from a REST endpoint! You should hopefully see <code>"Loading…"</code>appear briefly before the 4 list items. If you pass in a broken URL to <code>fetchData</code> you should see our error message.</p><p id="2aec">However, in reality, a component shouldn’t include logic to fetch data, and data shouldn’t be stored in a component’s state, so this is where Redux comes in.</p><h3 id="9abd">Converting to Redux</h3><p id="f0fa">To start, we need to add Redux, React Redux and Redux Thunk as dependencies of our project so we can use them. We can do that with:</p><pre id="2b31">npm install redux react-redux redux-thunk --save</pre><h3 id="eb55">Understanding Redux</h3><p id="098b">There are a few core principles to Redux which we need to understand:</p><ol><li id="2613">There is 1 global state object that manages the state for your entire application. In this example, it will behave identically to our initial component’s state. It is the <em>single source of truth</em>.</li><li id="4908">The only way to modify the state is through emitting an action, which is an object that describes what should change. Action Creators are the functions that are <code>dispatch</code>ed to emit a change – all they do is <code>return</code> an action.</li><li id="4ef8">When an action is <code>dispatch</code>ed, a Reducer is the function that actually changes the state appropriate to that action – or returns the existing state if the action is not applicable to that reducer.</li><li id="b330">Reducers are “pure functions”. They should not have any side-effects nor mutate the state — they must return a modified copy.</li><li id="28d7">Individual reducers are combined into a single <code>rootReducer</code> to create the discrete properties of the state.</li><li id="4112">The Store is the thing that brings it all together: it represents the state by using the <code>rootReducer</code>, any middleware (Thunk in our case), and allows you to actually <code>dispatch</code> actions.</li><li id="376c">For using Redux in React, the <code>&lt;Provider /&gt;</code> component wraps the entire application and passes the <code>store</code>down to all children.</li></ol><p id="7150">This should all become clearer as we start to convert our application to use Redux.</p><h3 id="0676">Designing our state</h3><p id="6794">From the work we’ve already done, we know that our state needs to have 3 properties: <code>items</code>, <code>hasErrored</code> and <code>isLoading</code> for this application to work as expected under all circumstances, which correlates to needing 3 unique actions.</p><p id="1119">Now, here is why Action Creators are different to Actions and do not necessarily have a 1:1 relationship: we need a fourth action creator that calls our 3 other action (creators) depending on the status of fetching the data. This fourth action creator is almost identical to our original <code>fetchData()</code> method, but instead of directly setting the state with <code>this.setState({ isLoading: true })</code>, we'll <code>dispatch</code> an action to do the same: <code>dispatch(isLoading(true))</code>.</p><h3 id="c0c7">Creating our actions</h3><p id="6458">Let’s create an <code>actions/items.js</code> file to contain our action creators. We'll start with our 3 simple actions.</p><pre id="e60a">export function itemsHasErrored(bool) {<br />    return {<br />        type: 'ITEMS_HAS_ERRORED',<br />        hasErrored: bool<br />    };<br />}</pre><pre id="0da1">export function itemsIsLoading(bool) {<br />    return {<br />        type: 'ITEMS_IS_LOADING',<br />        isLoading: bool<br />    };<br />}</pre><pre id="6c5e">export function itemsFetchDataSuccess(items) {<br />    return {<br />        type: 'ITEMS_FETCH_DATA_SUCCESS',<br />        items<br />    };<br />}</pre><p id="9d22">As mentioned before, action creators are functions that return an action. We <code>export</code> each one so we can use them elsewhere in our codebase.</p><p id="5236">The first 2 action creators take a <code>bool</code> (<code>true</code>/<code>false</code>) as their argument and return an object with a meaningful <code>type</code> and the <code>bool</code> assigned to the appropriate property.</p><p id="b8bb">The third, <code>itemsFetchDataSuccess()</code>, will be called when the data has been successfully fetched, with the data passed to it as <code>items</code>. Through the magic of ES6 property value shorthands, we'll return an object with a property called <code>items</code> whose value will be the array of <code>items</code>;</p><p id="82d1"><em>Note: that the value you use for </em><code><em>type</em></code><em> and the name of the other property that is returned is important, because you will re-use them in your reducers</em></p><p id="c6ce">Now that we have the 3 actions which will represent our state, we’ll convert our original component’s <code>fetchData</code>method to an <code>itemsFetchData()</code> action creator.</p><p id="11c2">By default, Redux action creators don’t support asynchronous actions like fetching data, so here’s where we utilise Redux Thunk. Thunk allows you to write action creators that return a function instead of an action. The inner function can receive the store methods <code>dispatch</code> and <code>getState</code> as parameters, but we'll just use <code>dispatch</code>.</p><p id="ecc6">A real simple example would be to manually trigger <code>itemsHasErrored()</code> after 5 seconds.</p><pre id="4f3e">export function errorAfterFiveSeconds() {<br />    // We return a function instead of an action object<br />    return (dispatch) =&gt; {<br />        setTimeout(() =&gt; {<br />            // This function is able to dispatch other action creators<br />            dispatch(itemsHasErrored(true));<br />        }, 5000);<br />    };<br />}</pre><p id="0869">Now we know what a thunk is, we can write <code>itemsFetchData()</code>.</p><pre id="7a79">export function itemsFetchData(url) {<br />    return (dispatch) =&gt; {<br />        dispatch(itemsIsLoading(true));</pre><pre id="fd7c">        fetch(url)<br />            .then((response) =&gt; {<br />                if (!response.ok) {<br />                    throw Error(response.statusText);<br />                }</pre><pre id="6515">                dispatch(itemsIsLoading(false));</pre><pre id="0504">                return response;<br />            })<br />            .then((response) =&gt; response.json())<br />            .then((items) =&gt; dispatch(itemsFetchDataSuccess(items)))<br />            .catch(() =&gt; dispatch(itemsHasErrored(true)));<br />    };<br />}</pre><h3 id="7f94">Creating our reducers</h3><p id="fd53">With our action creators defined, we now write reducers that take these actions and return a new state of our application.</p><p id="f66a"><em>Note: In Redux, all reducers get called regardless of the action, so inside each one you have to return the original </em><code><em>state</em></code><em> if the action is not applicable.</em></p><p id="ae94">Each reducer takes 2 parameters: the previous state (<code>state</code>) and an <code>action</code> object. We can also use an ES6 feature called default parameters to set the default initial <code>state</code>.</p><p id="aa8e">Inside each reducer, we use a <code>switch</code> statement to determine when an <code>action.type</code> matches. While it may seem unnecessary in these simple reducers, your reducers could theoretically have a lot of conditions, so <code>if</code>/<code>else if</code>/<code>else</code> will get messy fast.</p><p id="6066">If the <code>action.type</code> matches, then we return the relevant property of <code>action</code>. As mentioned earlier, the <code>type</code> and <code>action[propertyName]</code> is what was defined in your action creators.</p><p id="c6e4">OK, knowing this, let’s create our items reducers in <code>reducers/items.js</code>.</p><pre id="3d5a">export function itemsHasErrored(state = false, action) {<br />    switch (action.type) {<br />        case 'ITEMS_HAS_ERRORED':<br />            return action.hasErrored;</pre><pre id="8594">        default:<br />            return state;<br />    }<br />}</pre><pre id="3a71">export function itemsIsLoading(state = false, action) {<br />    switch (action.type) {<br />        case 'ITEMS_IS_LOADING':<br />            return action.isLoading;</pre><pre id="6265">        default:<br />            return state;<br />    }<br />}</pre><pre id="fb47">export function items(state = [], action) {<br />    switch (action.type) {<br />        case 'ITEMS_FETCH_DATA_SUCCESS':<br />            return action.items;</pre><pre id="1174">        default:<br />            return state;<br />    }<br />}</pre><p id="9c86">Notice how each reducer is named after the resulting store’s state property, with the <code>action.type</code> not necessarily needing to correspond. The first 2 reducers hopefully make complete sense, but the last, <code>items()</code>, is slightly different.</p><p id="3593">This is because it could have multiple conditions which would always return an array of <code>items</code>: it could return all in the case of a fetch success, it could return a subset of <code>items</code> after a delete action is <code>dispatch</code>ed, or it could return an empty array if everything is deleted.</p><p id="3850">To re-iterate, every reducer will return a discrete property of the state, regardless of how many conditions are inside that reducer. That initially took me a while to get my head around.</p><p id="5caf">With the individual reducers created, we need to combine them into a <code>rootReducer</code> to create a single object.</p><p id="1745">Create a new file at <code>reducers/index.js</code>.</p><pre id="1e3f">import { combineReducers } from 'redux';<br />import { items, itemsHasErrored, itemsIsLoading } from './items';</pre><pre id="2524">export default combineReducers({<br />    items,<br />    itemsHasErrored,<br />    itemsIsLoading<br />});</pre><p id="6bc2">We import each of the reducers from <code>items.js</code> and export them with Redux's <code>combineReducers()</code>. As our reducer names are identical to what we want to use for a store's property names, we can use the ES6 shorthand.</p><p id="10b1">Notice how I intentionally prefixed my reducer names, so that when the application grows in complexity, I’m not constrained by having a “global” <code>hasErrored</code> or <code>isLoading</code> property. You may have many different features that could error or be in a loading state, so prefixing the imports and then exporting those will give your application's state greater granularity and flexibility. For example:</p><pre id="62b3">import { combineReducers } from 'redux';<br />import { items, itemsHasErrored, itemsIsLoading } from './items';<br />import { posts, postsHasErrored, postsIsLoading } from './posts';</pre><pre id="50ee">export default combineReducers({<br />    items,<br />    itemsHasErrored,<br />    itemsIsLoading,<br />    posts,<br />    postsHasErrored,<br />    postsIsLoading<br />});</pre><p id="573b">Alternatively, you could alias the methods on <code>import</code>, but I prefer consistency across the board.</p><h3 id="bf5e">Configure the store and provide it to your app</h3><p id="b826">This is pretty straightforward. Let’s create <code>store/configureStore.js</code> with:</p><pre id="0458">import { createStore, applyMiddleware } from 'redux';<br />import thunk from 'redux-thunk';<br />import rootReducer from '../reducers';</pre><pre id="9ed1">export default function configureStore(initialState) {<br />    return createStore(<br />        rootReducer,<br />        initialState,<br />        applyMiddleware(thunk)<br />    );<br />}</pre><p id="5b37">Now change our app’s <code>index.js</code> to include <code>&lt;Provider /&gt;</code>, <code>configureStore</code>, set up our <code>store</code> and wrap our app (<code>&lt;ItemList /&gt;</code>) to pass the <code>store</code> down as <code>props</code>:</p><pre id="da88">import React from 'react';<br />import { render } from 'react-dom';<br />import { Provider } from 'react-redux';<br />import configureStore from './store/configureStore';</pre><pre id="3f2f">import ItemList from './components/ItemList';</pre><pre id="c2cb">const store = configureStore(); // You can also pass in an initialState here</pre><pre id="0a4b">render(<br />    &lt;Provider store={store}&gt;<br />        &lt;ItemList /&gt;<br />    &lt;/Provider&gt;,<br />    document.getElementById('app')<br />);</pre><p id="5f29">I know, it’s taken quite a bit of effort to get to this stage, but with the set up complete, we can now modify our component to make use of what we’ve done.</p><h3 id="852e">Converting our component to use the Redux store and methods</h3><p id="06ae">Let’s jump back in to <code>components/ItemList.js</code>.</p><p id="28c8">At the top of the file, <code>import</code> what we need:</p><pre id="899c">import { connect } from 'react-redux';<br />import { itemsFetchData } from '../actions/items';</pre><p id="f375"><code>connect</code> is what allows us to connect a component to Redux's store, and <code>itemsFetchData</code> is the action creator we wrote earlier. We only need to import this one action creator, as it handles <code>dispatch</code>ing the other actions.</p><p id="bba9">After our component’s <code>class</code> definition, we're going to map Redux's state and the dispatching of our action creator to props.</p><p id="48e3">We create a function that accepts <code>state</code> and then returns an object of props. In a simple component like this, I remove the prefixing for the <code>has</code>/<code>is</code> props as it’s obvious that they're related to <code>items</code>.</p><pre id="5488">const mapStateToProps = (state) =&gt; {<br />    return {<br />        items: state.items,<br />        hasErrored: state.itemsHasErrored,<br />        isLoading: state.itemsIsLoading<br />    };<br />};</pre><p id="3c48">And then we need another function to be able to <code>dispatch</code> our <code>itemsFetchData()</code> action creator with a prop.</p><pre id="5c2e">const mapDispatchToProps = (dispatch) =&gt; {<br />    return {<br />        fetchData: (url) =&gt; dispatch(itemsFetchData(url))<br />    };<br />};</pre><p id="a304">Again, I’ve removed the <code>items</code> prefix from the returned object property. Here <code>fetchData</code> is a function that accepts a <code>url</code> parameter and returns <code>dispatch</code>ing <code>itemsFetchData(url)</code>.</p><p id="df43">Now, these 2 <code>mapStateToProps()</code> and <code>mapDispatchToProps()</code> don't do anything yet, so we need to change our final <code>export</code> line to:</p><pre id="2f70">export default connect(mapStateToProps, mapDispatchToProps)(ItemList);</pre><p id="4105">This <code>connect</code>s our <code>ItemList</code> to Redux while mapping the props for us to use.</p><p id="99fe">The final step is to convert our component to use <code>props</code> instead of <code>state</code>, and to remove the leftovers.</p><ul><li id="f10d">Delete the <code>constructor() {}</code> and <code>fetchData() {}</code> methods as they're unnecessary now.</li><li id="43b6">Change <code>this.fetchData()</code> in <code>componentDidMount()</code> to <code>this.props.fetchData()</code>.</li><li id="1126">Change <code>this.state.X</code> to <code>this.props.X</code> for <code>.hasErrored</code>, <code>.isLoading</code> and <code>.items</code>.</li></ul><p id="a3a1">Your component should now look like this:</p><pre id="8c8f">import React, { Component } from 'react';<br />import { connect } from 'react-redux';<br />import { itemsFetchData } from '../actions/items';</pre><pre id="8ef3">class ItemList extends Component {<br />    componentDidMount() {<br />        this.props.fetchData('http://5826ed963900d612000138bd.mockapi.io/items');<br />    }</pre><pre id="781f">    render() {<br />        if (this.props.hasErrored) {<br />            return &lt;p&gt;Sorry! There was an error loading the items&lt;/p&gt;;<br />        }</pre><pre id="17db">        if (this.props.isLoading) {<br />            return &lt;p&gt;Loading…&lt;/p&gt;;<br />        }</pre><pre id="1df3">        return (<br />            &lt;ul&gt;<br />                {this.props.items.map((item) =&gt; (<br />                    &lt;li key={item.id}&gt;<br />                        {item.label}<br />                    &lt;/li&gt;<br />                ))}<br />            &lt;/ul&gt;<br />        );<br />    }<br />}</pre><pre id="2ce6">const mapStateToProps = (state) =&gt; {<br />    return {<br />        items: state.items,<br />        hasErrored: state.itemsHasErrored,<br />        isLoading: state.itemsIsLoading<br />    };<br />};</pre><pre id="ef7e">const mapDispatchToProps = (dispatch) =&gt; {<br />    return {<br />        fetchData: (url) =&gt; dispatch(itemsFetchData(url))<br />    };<br />};</pre><pre id="0faf">export default connect(mapStateToProps, mapDispatchToProps)(ItemList);</pre><p id="6826">And that’s it! The application now uses Redux and Redux Thunk to fetch and display the data!</p><p id="3658">That wasn’t too difficult, was it?</p><p id="48da">And you’re now a Redux master :D</p><h3 id="9aa5">What next?</h3><p id="1ea8">I’ve put all of <a href="https://github.com/stowball/dummys-guide-to-redux-and-thunk-react" target="_blank">this code up on GitHub</a>, with commits for each step. I want you to clone it, run it and understand it, then add the ability for the user to delete individual list items based on the item’s <code>index</code>.</p><p id="96f1">I haven’t yet really mentioned that in Redux, the <em>state is immutable</em>, which means you can’t modify it, so have to return a new state in your reducers instead. The 3 reducers we wrote above were simple and “just worked”, but deleting items from an array requires an approach that you may not be familiar with.</p><p id="fe76">You can no longer use <code>Array.prototype.splice()</code> to remove items from an array, as that will mutate the original array. <a href="https://egghead.io/lessons/javascript-redux-avoiding-array-mutations-with-concat-slice-and-spread" target="_blank">Dan explains how to remove an element from an array in this video</a>, but if you get stuck, you can check out (pun intended) the <code>delete-items</code> branch for the solution.</p><p id="5dfb">I really hope that this has clarified the concept of Redux and Thunk and how you might go about converting an existing React application to use them. I know that writing this has solidified my understanding of it, so I’m very happy to have done it.</p><p id="6c3f">I’d still recommend <a href="http://redux.js.org/" target="_blank">reading the Redux docs</a>, <a href="https://egghead.io/courses/getting-started-with-redux" target="_blank">watching Dan’s videos</a>, and <a href="https://www.learnredux.com/" target="_blank">re-doing Wes’ course</a> as you should hopefully now be able to understand some of the other more complex and deeper principles.</p><p id="a346">This <a href="http://codepen.io/stowball/post/a-dummy-s-guide-to-redux-and-thunk-in-react" target="_blank">article has been cross-posted on Codepen</a> for better code formatting.</p>