<a href="https://medium.com/skyshidigital/6-tricks-to-speed-up-and-improve-your-node-js-performance-fadc06d15cbe">https://medium.com/skyshidigital/6-tricks-to-speed-up-and-improve-your-node-js-performance-fadc06d15cbe</a><div id="articleHeader"><h1>6 Tips and Techniques to Speed Up and Improve Your Node.js Performance</h1></div><div><figure id="7d91"><div><div><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*hv0Rr5-DKpN_bDomhlTj7Q.jpeg" /></div></figure><p id="be1c">We all know, in recent years, javascript has become a highly developed programming language. Many developers are getting interested in using javascript, and it‚Äôs becoming the most popular language in the world (<a href="https://insights.stackoverflow.com/survey/2017#most-popular-technologies" target="_blank">Stack Overflow Developer Survey 2017</a>). Currently, you can see how many libraries and frameworks are built using javascript. It is a very easy language to learn, works well when combined with other languages ‚Äã‚Äãand can be used in a variety of applications. And now, we also know how Node.js became a trend in backend programming. In fact, this is the main reason why some big companies with heavy traffic use Node.js on their platforms like eBay, Microsoft, Yahoo, Netflix and LinkedIn.</p><p id="bed5">Node.js is known event-driven I/O server-side JavaScript environment and single-threaded event loop based on <a href="https://github.com/v8/v8/wiki" target="_blank">V8 Engine</a> ( Google‚Äôs open source high-performance JavaScript engine). The event-driven architecture of node.js is very good technology for real-time applications, especially chat applications and streaming applications. As both the client-side and the server-side are written in JavaScript, the synchronization process which design by single-threaded is better and quicker.</p><p id="ed26">With good productivity on Node.js, practically you also want how Node.js can be more optimal. In this article will discuss 6 ways to make node js to be faster and optimal in work.</p><h3 id="15a8"><strong>1. Caching Your App with¬†Redis</strong></h3><figure id="6e77"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*i1d88Q8NNrRv6kjf7Ssw4g.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*i1d88Q8NNrRv6kjf7Ssw4g.png" /></div></div></div></figure><p id="12cc"><a href="https://www.digitalocean.com/community/tutorials/web-caching-basics-terminology-http-headers-and-caching-strategies" target="_blank"><strong>What is caching?</strong></a>On caching process, Redis as a more complex version of Memcached. Redis always served and modified data in the server‚Äôs main memory. The impact is system will quickly retrieve data that will be needed. It also reduces time to open web pages and make your site faster. Redis works to help and improve load performance from relational databases or NoSQL by creating an excellent in-memory cache to reduce access latency. Using Redis we can store cache using <code>SET and GET</code>, besides that redis also can work with complex type data like <code>Lists</code>, <code>Sets</code>, <code>ordered data structures</code>, and so forth.</p><p id="21ae">We will make a comparison of 2 pieces of code from Node.js. The following is when we try to retrieve data from the Google Book API, without put Redis on the endpoint.</p><p id="a831"><strong>Node.Js without Redis¬†:</strong></p><figure id="5d13"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F16377920%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="cbc5">And now, we will put a redis on this endpoint. If you have trouble when using redis, you can read the complete documentation of redis on the node JS <a href="https://github.com/NodeRedis/node_redis" target="_blank"><strong>here</strong></a>.</p><p id="92f0"><strong>Node.Js with Redis¬†:</strong></p><figure id="5a6b"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F16377920%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="9a26">You can see, the above code explains that redis will store the cache data of with unique key value that we have specified, using this function:</p><pre id="6a49">client.setex (isbn, 3600, JSON.stringify(book));</pre><p id="2b63">And take the cache data using the function below:</p><pre id="ca7e">client.get(isbn, (err, result) =&gt; {<br />     if (result) {<br />       res.send (result);<br />     } else {<br />       getBook (req, res);<br />     }<br />   });</pre><p id="a4bb">This is the result of testing of both codes. If we don‚Äôt use redis as cache, it takes at least <strong>908.545 ms</strong></p><figure id="1942"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*bSKQElJ1loM8RLVhJbRHDA.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*bSKQElJ1loM8RLVhJbRHDA.png" /></div></div></div><figcaption><strong>Response time without¬†Redis</strong></figcaption></figure><p id="39cb">Very different, when node js use redis. Look at this, it is very fast, it only takes <strong>0.621 ms</strong> to retrieve data at the same endpoint</p><figure id="aad0"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*yYmLb9bE7aemvQWyGZuyvA.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*yYmLb9bE7aemvQWyGZuyvA.png" /></div></div></div><figcaption><strong>Response time with¬†Redis</strong></figcaption></figure><h3 id="225e"><strong>2. Make sure your query is Optimized</strong></h3><figure id="e3ed"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*WvhokfgIJJXNwM1DRyBeBQ.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*WvhokfgIJJXNwM1DRyBeBQ.gif" /></div></div></div></figure><p id="12da">Basically, the process generated by database in the query greatly affects performance. When end-point generates data that called by the system. A bad query, will make the process of displaying data becomes very slow. For example, if we have a data on MongoDB, the problem is when we have 4 million rows of data, to find 1 desired data keyword, without using index schema that will be make query process very slow. With MongoDB, we can analyze how a query process can work. You can add this query¬†: <strong>explain(‚ÄúexecutionStats‚Äù)</strong> to analyze and find user data from your collection.</p><pre id="9c96">&gt; db.user.find({email: 'ofan@skyshi.com'}).explain("executionStats")</pre><p id="4482">Look at this, before we create the index, response query when looking for data.</p><pre id="154f">&gt; db.user.find({email: '<a href="mailto:ofan@skyshi.com" target="_blank">ofan@skyshi.com</a>'}).explain("executionStats")<br />{<br /> "queryPlanner" : ...<br />  },<br />  "winningPlan" : {<br />   "stage" : "COLLSCAN",<br />   "filter" : {<br />    "email" : {<br />     "$eq" : "<a href="mailto:ofan@skyshi.com" target="_blank">ofan@skyshi.com</a>"<br />    }<br />   },<br />   "direction" : "forward"<br />  },<br />  "rejectedPlans" : [ ]<br /> },<br /> "executionStats" : {<br />  "executionSuccess" : true,<br />  "nReturned" : 1,<br />  "executionTimeMillis" : 0,<br />  "totalKeysExamined" : 0,<br />  "totalDocsExamined" : 1039,<br />  "executionStages" : {<br />   ...   <br />    },<br />   ...<br />  }<br /> },<br /> "serverInfo" : {<br />  ...<br /> },<br /> "ok" : 1<br />}<br />&gt;</pre><p id="0734">From the above JSON results, there are 2 important points that we can analyze that is¬†:</p><ul><li id="0e03"><code><a href="https://docs.mongodb.com/manual/reference/explain-results/#explain.executionStats.nReturned" title="explain.executionStats.nReturned" target="_blank">nReturned</a>¬†:</code> displays 1 to indicate that the query matches and returns 1 documents.</li><li id="18ca"><code><a href="https://docs.mongodb.com/manual/reference/explain-results/#explain.executionStats.totalDocsExamined" title="explain.executionStats.totalDocsExamined" target="_blank">totalDocsExamined</a>¬†:</code> MongoDB has scanned <strong>1039 document</strong> data (this searches on all documents), to get 1 desired data.</li></ul><p id="e1e4">This is when we try to add index email to the user collection.</p><pre id="5512">&gt; db.getCollection("user").createIndex({ "email": 1 }, { "name": "email_1", "unique": true })<br />{<br /> "createdCollectionAutomatically" : false,<br /> "numIndexesBefore" : 1,<br /> "numIndexesAfter" : 2,<br /> "ok" : 1<br />}</pre><p id="4d88">The result of query analysis after add index email</p><pre id="61c4">&gt; db.user.find({email: '<a href="mailto:ofan@skyshi.com" target="_blank">ofan@skyshi.com</a>'}).explain("executionStats")<br />{<br /> "queryPlanner" : ...,<br />  "winningPlan" : {<br />   "stage" : "FETCH",<br />   "inputStage" : {<br />    "stage" : "IXSCAN",<br />    "keyPattern" : {<br />     "email" : 1<br />    },<br />    "indexName" : "email_1",<br />    "isMultiKey" : false,<br />    "isUnique" : true,<br />    ...<br />   }<br />  },<br />  "rejectedPlans" : [ ]<br /> },<br /> "executionStats" : {<br />  "executionSuccess" : true,<br />  "nReturned" : 1,<br />  "executionTimeMillis" : 0,<br />  "totalKeysExamined" : 1,<br />  "totalDocsExamined" : 1,<br />  ...<br />   }<br />  }<br /> },<br /> "serverInfo" : {<br />  ...<br />}</pre><p id="2f30">You can see, at the <strong>totalDocsExamined</strong> point, MongoDB <strong>only searches for 1 related data</strong>, this will make query process more faster and more efficient. Here‚Äôs the advantage when you add the index to MongoDB. By adding an index, it will also be useful when you want to sort data in a collection.</p><h3 id="5fdd"><strong>3. Check All Error Scripts with¬†Logging</strong></h3><p id="b85f">Why is logging important? The first is that you must ensure that your application program is running properly, without any fatal errors. If at any time, you find something strange in your program, it is time to find out what code makes the error. With logging, you can track activity and API process traffic.</p><p id="da5a">The logging process that people often use is to use console.log (‚ÄòLog Ouput‚Äô) by default it will insert some logs on the output standard (stdout) and console.error (‚ÄòLog Error‚Äô) also will go in error standard (stderr). However, I recommend that you use a more popular and efficient logging module, such as <code>Winston</code>, <code>Morgan</code> and <code>Buyan</code>.<br />I will give an example of how we are logging using winston¬†. In general, winston has 4 custom levels that we can use such as: <code>error</code>, <code>warn</code>, <code>info</code>, <code>verbose</code>, <code>debug</code>, and <code>silly</code>.</p><p id="010e"><strong>Some features that can be used on winston:</strong></p><ul><li id="0046">Possible to use multiple transports of the same type</li><li id="1a03">Simple Profiling</li><li id="a949">Supports querying of logs</li><li id="5126">Possible to catch and log uncaughtException</li><li id="b631">Setting the level for your logging message</li></ul><p id="2501">First of all we need to install Winston and include winston on the new project or that you have developed. Run the following command to do this:</p><pre id="9aff">npm install winston --save</pre><p id="3f85">This is the basic configuration wintons that we use¬†:</p><figure id="09de"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F16377920%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="06a3">From the code above we know that, we do use multiple transports configuration, with 2 levels logging that are verbose and error.</p><h3 id="9918">4. Implement HTTP/2</h3><figure id="8bb9"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*D2CcVAv6iQzfISvvCxgM1Q.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*D2CcVAv6iQzfISvvCxgM1Q.png" /></div></div></div></figure><p id="56f8">HTTP/2 commonly called SPDY is the latest web protocol standard developed by the IETF HTTP workgroup. HTTP/2 makes web browsing faster, easier and lower bandwidth usage. It focuses on performance, especially to solve problems that still occur in previous versions of HTTP/1.x. Currently, you can see some popular web like google, facebook and youtube, have implemented the HTTP/2 protocol on its web page.</p><p id="4e4c"><strong>Why is this better than HTTP/1.x?</strong></p><ul><li id="98ba">Multiplexing:<br />Multiplexing will allow multiple requests and response messages to retrieve resources in a single TCP connection simultaneously.</li><li id="3fde">Header Compression¬†:<br />Each request via HTTP contains header information. With HTTP/1.1, many headers are repeated in one session and duplicate the same info. This overhead is considerable, HTTP/2 removes the excess header while pressing the remaining headers and forcing all HTTP headers to be sent in a compressed format.</li><li id="0d44">Server Push:<br />With HTTP/1.1 it must wait for the client to send the connection. Server Push allows the server to avoid delays in sending data by ‚Äúpushing‚Äù responses that it claims the client needs to cache it and automatically this will speed up page load time by reducing the number of requests.</li><li id="f001">Binary Format¬†:<br />HTTP / 1.1 sends data in the textual format, while HTTP/2 sends data in binary format. Binary protocols are more efficient to parse and reduce the number of errors, compared to previous versions of textual protocols.</li></ul><p id="1f7d">And we know, Node.js currently supports and provides <a href="https://nodejs.org/api/http2.html" target="_blank">HTTP/2 implementations for core Node.js</a>. The API is very similar to the <a href="http://nodejs.org/api/https.html" target="_blank">standard node.js HTTPS API</a>. To start with HTTP/2, you can create an HTTP/2 server on Node.js using the following code line:</p><figure id="90ec"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F16377920%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="3dac">To implement Transport Layer Security (TLS) and Secure Socket Layer (SSL) protocols that built on OpenSSL. You can create a self-signed SSL Certificate to generate the <code>server.key</code> and <code>server.crt</code> via <a href="https://devcenter.heroku.com/articles/ssl-certificate-self" target="_blank"><strong>here</strong></a><strong>.</strong></p><p id="d640">Because HTTP/2 support is still experimental, Node.js must be launched with the <code>--expose-http2</code> command line¬†:</p><pre id="4cb4">$ node --expose-http2 node-http2.js</pre><p id="6c77">Now it‚Äôs time to check if a website is using the newest HTTP/2 protocol.</p><figure id="cedb"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*Q2WPFm4bvHPR1TjOZmAUmQ.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*Q2WPFm4bvHPR1TjOZmAUmQ.png" /></div></div></div><figcaption>HTTP2 using Node¬†JS</figcaption></figure><p id="8b05">From the picture above, you will be able to identify that the website has been using the HTTP/2 protocol.</p><h3 id="0449">5. Clustering Your Node¬†.js</h3><p id="a634">By default, Node.js runs on a single thread on a single-core of the processor. and It does not utilize several cores that may be available in a system. But now, with cluster on Node.js, it allows you to easily create child processes that all share server ports. it‚Äôs meant that cluster can handle a large volume of requests with multi-core systems. And automatically, this will increase the performance of your server.</p><p id="849b"><strong>Node.js Cluster Module<br /></strong>Node.js has implementation the core cluster modules, that allowing applications to run on more than one core. Cluster module a <em>parent/master</em> process can be forked in any number of <em>child/worker</em> processes and communicate with them sending messages via <a href="https://en.wikipedia.org/wiki/Inter-process_communication" target="_blank">IPC</a> communication. Let‚Äôs see a small code snippet below¬†:</p><figure id="167d"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F16377920%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="aacb">When the node is run, there it appears that there are 4 workers currently in use on Node.js with a cluster.</p><figure id="4512"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*jrI1gshkWT7gYKKI0luXzw.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*jrI1gshkWT7gYKKI0luXzw.png" /></div></div></div><figcaption>Node JS¬†Cluster</figcaption></figure><p id="5b9c">Now you can visit the <code>http:localhost:3000/cluster </code>link on a different tab and browser, you will find there, that each tab will have a different worker id.</p><figure id="b6dc"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*X9QTuj2polCH3PVwuCTUWQ.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*X9QTuj2polCH3PVwuCTUWQ.gif" /></div></div></div></figure><p id="1540"><strong>Node.js clustering with PM2</strong></p><p id="64f2">PM2 is a production process manager for Node.js applications with a built-in load balancer. It allows you to keep applications alive forever, to reload them without downtime and to facilitate common system admin tasks. One of its nicer features is an automatic use of Node‚Äôs <a href="http://nodejs.org/api/cluster.html#cluster_cluster" target="_blank">Cluster API</a>. PM2 gives your application the ability to be run as multiple processes, without any code modifications. For example, below is a simple code built using express¬†:</p><figure id="d455"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F16377920%3Fv%3D4%26s%3D400&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="ee7c">With command below, PM2 will automatically spawn as many workers as you have CPU cores. Let‚Äôs start and following commands to enable cluster using PM2:</p><pre id="021e"><code>pm2 start  app.js -i 0</code></pre><p id="ef31">Now you can see, how PM2 cluster has scaled accross all CPUs available</p><figure id="2b7b"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*rZeY6TuVshCSJrsC9LblDQ.png?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div></figure><p id="516f">Overall, PM2 cluster is powerful tools that can really improve the concurrency and overall performance of your Node JS. This is easier than you are using an existing cluster module on Node.js Core.</p><h3 id="6990">6. Use Realtime App Monitor to Analysis your¬†App</h3><figure id="ee5c"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*gjhkikuEdV-iRSGGacOyVg.jpeg?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div><figcaption>Newrelic Monitoring</figcaption></figure><p id="a49f">Real Time Monitoring is a third-party application that allows admins to maintain and monitor the system from any disruptions or problems that arise in web applications in real time. This lets you immediately respond to any errors or bugs that occur. In Node JS you can use Newrelic, Stackify, Ruxit, LogicMonitor and Monitis, to record traces and activities quickly, concisely and reliably. With this monitoring, you can analyze and find out more detail issues, especially the effectiveness and health of node.js when accessed by multiple users.</p><h3 id="6317">Conclusion¬†:</h3><p id="3593">I know there are still many ways to improve and speed up performance on Node.js, and with only 6 ways above, I think not enough to make your Node.js run perfectly. Hi friends, please let me know another way, by filling in the comments below. Thank You üòÉ</p>