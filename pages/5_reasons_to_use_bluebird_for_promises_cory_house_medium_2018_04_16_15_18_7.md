<a href="https://medium.com/@housecor/5-reasons-to-keep-using-bluebird-for-promises-a4f59c8a5d69">https://medium.com/@housecor/5-reasons-to-keep-using-bluebird-for-promises-a4f59c8a5d69</a><div id="articleHeader"><h1>5 Reasons To Use Bluebird for Promises</h1></div><h2 id="40aa">ES6 promises are great, but Bluebird remains compelling.</h2><figure id="b23b"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*n54wpde4Wbf2tvD3dJAouQ.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*n54wpde4Wbf2tvD3dJAouQ.png" /></div><figcaption>Bluebird.js — A JavaScript Promises library</figcaption></figure><p id="c77b">It’s great that the web platform keeps adding native support for popular approaches. I was excited about the release of ES6 promises. However, here are 5 reasons you may want to use Bluebird instead of native ES6 promises:</p><ol><li id="99ce"><a href="http://bluebirdjs.com/docs/api/catch.html" target="_blank">Error pattern matching in catch</a>. This means you can declare and trap specific error types, much like you can today in statically typed languages like C# and Java. This also has the benefit of being faster than a plain catch.</li><li id="f3e8"><a href="http://bluebirdjs.com/docs/api/cancellation.html" target="_blank">Bluebird promises can be cancelled</a>! 👍 It’s a shame this feature isn’t in the promise spec. Cancelling an AJAX call is often necessary to avoid throwing errors when the user navigates away while the call is in progress.</li><li id="2d2d">Bluebird can create a synchronous API from asynchronous code by wrapping generators in <a href="http://bluebirdjs.com/docs/api/promise.coroutine.html" target="_blank">promise.coroutine</a>. This means calling code need not worry about the promise or generator that’s running behind the scenes in a given function. It can call the function like it’s a simple synchronous function. This pattern can really clean up calling code.</li><li id="b789">Ever forgotten to declare a .catch? If you do, traditional ES6 promises will swallow the error. 😡 With Bluebird, <a href="http://bluebirdjs.com/docs/why-bluebird.html" target="_blank">unhandled errors are not silently swallowed by default</a>, but reported along with helpful stack traces. 😁</li><li id="9417">You can promisify existing APIs via <a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html" target="_blank">promisifyAll</a>. Run promisifyAll on any API and convert it into a promise-based API.</li></ol><h4 id="04a1">Downsides</h4><ol><li id="978a">Bluebird weighs 17K gzipped.</li><li id="b82a">It extends the promise spec, so Bluebird’s extra features may confuse some at first.</li><li id="0172">The extra features above are yet another thing to learn.</li></ol><p id="f1d9">Worth the downsides? Other benefits I’m overlooking? Chime in via the comments.</p></section><section><div><div><p id="37b7"><a href="https://twitter.com/housecor" target="_blank">Cory House</a> is the author of <a href="http://pluralsight.com/author/cory-house" target="_blank">multiple courses on JavaScript, React, clean code, .NET, and more on Pluralsight</a>. He is principal consultant at <a href="http://www.reactjsconsulting.com" target="_blank">reactjsconsulting.com</a>, a Software Architect at VinSolutions, a Microsoft MVP, and trains software developers internationally on software practices like front-end development and clean coding. Cory tweets about JavaScript and front-end development on Twitter as <a href="http://www.twitter.com/housecor" target="_blank">@housecor</a>.</p></div></section>