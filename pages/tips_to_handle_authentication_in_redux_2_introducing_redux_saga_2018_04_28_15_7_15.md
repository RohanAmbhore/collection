<a href="https://medium.com/@MattiaManzati/tips-to-handle-authentication-in-redux-2-introducing-redux-saga-130d6872fbe7">https://medium.com/@MattiaManzati/tips-to-handle-authentication-in-redux-2-introducing-redux-saga-130d6872fbe7</a><div id="articleHeader"><h1>Tips to handle Authentication in Redux #2 introducing redux-saga</h1></div><figure id="24f6"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*Z5wF0bUdvtEanXyLnN1TuA.jpeg?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*Z5wF0bUdvtEanXyLnN1TuA.jpeg" /></div></figure><p id="5ff3">After about 5 month from my first article <a href="https://medium.com/@MattiaManzati/tips-to-handle-authentication-in-redux-4d596e11bb21#.dsu4l691o" target="_blank">Tips to handle Authentication in Redux</a>, I think it’s time to share with you all how the actual redux ecosystem changed and improved the way I usually do authentication in redux.</p><p id="b643">One of the libraries that most improved my approach with redux apps is <a href="https://github.com/yelouafi/redux-saga" target="_blank">redux-saga</a>, that allows to decouple any side effect from the actual reducer.</p><h4 id="5f5d">Modeling the store</h4><p id="1803">When talking about authentication our store must know about two things: who are the users? which user is currently logged in? These are the main questions that will lead us choosing the right shape for our store. So we will have a property containing all the users indexed by id, and an auth property containing the currently logged user id.</p><p id="52ef">This way, getting the currently logged user object could be easily done via any redux state selector.</p><p id="7350">These selectors can then be used in your connect’s mapStateToProps to help you getting the current logged user. Also, they provide more flexibility, because if you change your store shape you can simply change that small selector function instead of changing your whole app components. tip: you could also memoize them :D</p><h4 id="23c2">Wait, anyone can easily change the logged user id!</h4><p id="8ca8">Hey, we are doing frontend development here! <strong>YOU SHOULD NEVER TRUST DATA INCOMING FROM THE CLIENT! </strong>So, whenever performing any AJAX request from the UI, you should never pass in the user id.</p><p id="76c5">Instead, as you can see in the store shape example, we will store the access token in the user object, and whenever performing any ajax request, pass that access token as parameter. This way our app could also support multiple users login and offline data insertion.</p><h4 id="f454">Getting started with the action creators</h4><p id="e096">Now we will create action creators for the various login actions. As you can see, <a href="https://github.com/erikras/ducks-modular-redux" target="_blank">ducks</a> may come in handy.</p><p id="f016">Just to describe a little the action creators, loginSubmit will take in {email, password}, loginRequest will take {email, password}, loginSuccess will take in a user object (including id and token), and login error any error structure you will use (take a look at<a href="https://github.com/erikras/redux-form" target="_blank"> redux-form</a>! :D).</p><h4 id="35f1">The users and auth reducer</h4><p id="991a">Now it’s time to perform the real auth logic! Whenever a loginSuccess is dispatched, we will store the user and set the logged user id.</p><p id="b20e">To provide a cleaner syntax, I will be using the object spread operator to append the just logged user to the users stack. More information about it can be found <a href="http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html" target="_blank">in the redux documentation</a>.</p><h4 id="b9a1">Wait, where do I perform the REAL login request?</h4><p id="085e">That’s where saga comes in handy! Sagas can be considered as daemon process that listens for dispatched actions and can dispatch actions whenever they want to. They are implemented using generators, which allows a great DX understanding and writing them.</p><p id="a9a0">Atm I am not so good with them, but I think you should have a deep dive into redux-saga docs, which provides great real world examples to dive in.</p><p id="fd8f">As you can see, the saga is a generator, which should be injected with createSagaMiddleware from redux-saga.</p><p id="3f22">The real login request is done in the login() function imported from the api.js file, I’ll let you do that, but it returns a promise that resolves with the logged user object (with token included) or rejects with an error object. Any rest library like superagent can help you implement that.</p><p id="8039">In the saga I also dispatch startSubmit and stopSubmit from the awesome redux-form package, in order to provide a visual feedback about the outgoing rest request.</p><h4 id="f9eb">Follow-up: performing API requests with the access token</h4><p id="0b5f">As said before, any rest request should also pass in the access token in order to identify the currently logged user. How can I do that? sagas come for the rescue. Using a similar pattern to the one used to perform the loginRequest and then dispach its response with loginSuccess or loginError, you can implement a saga that listens for a generic restRequest action being dispatched, perform the http request and dispatch restSuccess or restError based on the request response. This way you can access the stored access token and automatically append it to any rest request, and also this makes your code more testable, as you are separating concerns of side-effects.</p><h4 id="31cf">Thanks for your attention, hope to be helpful!</h4>