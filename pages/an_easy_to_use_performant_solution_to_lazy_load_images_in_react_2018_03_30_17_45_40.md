<a href="https://medium.com/@aljullu/an-easy-to-use-performant-solution-to-lazy-load-images-in-react-e6752071020c">https://medium.com/@aljullu/an-easy-to-use-performant-solution-to-lazy-load-images-in-react-e6752071020c</a><div id="articleHeader"><h1>An easy-to-use performant solution to lazy load images in React</h1></div><div><figure id="9b6c"><div><div><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*rBijqQfi8ScTwrYVuiVeCQ.png" /></div><figcaption>Check out the demo of a <a href="https://www.albertjuhe.com/react-lazy-load-image-component/" target="_blank">lazy-loading image gallery in React.</a></figcaption></figure><p id="0738">Lazy loading images has been a common practice on the web for ages. It improves page speed and avoids loading assets which might never be shown to the user. However, I couldn’t find any good and performant solution for React that satisfied all my needs, so I wrote my own.</p><h3 id="d6b8">Introducing react-lazy-load-image-component</h3><p id="c8ef">I created an <a href="https://www.npmjs.com/package/react-lazy-load-image-component" target="_blank">npm package</a> ready to be installed in any React application.</p><p id="499a">Just type:</p><pre id="7f47">npm i --save react-lazy-load-image-component</pre><p id="3245">and you are ready to import it in your project.</p><p id="852b">Here you can see the simplest example of its usage:</p><figure id="604d"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F3616980%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="ad8b">It will load the image when it appears in the viewport after scrolling or resizing, but also when it becomes visible after a re-render. For example, in an image gallery with a filter, some images that were below the fold might appear in the viewport when a filter is applied.</p><figure id="e7a2"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*7cG70KwRb3dxgi685Pd1QA.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*7cG70KwRb3dxgi685Pd1QA.gif" /></div></div></div><figcaption>Notice how the images are loaded when they appear on the screen, doesn’t matter if it’s because of the cards changing their order or because of a scroll event.</figcaption></figure><p id="f552">Some of its features are:</p><ul><li id="78d2">It <strong>throttles</strong> scroll and resize events by default. You can specify the delay time or use another delay function like <strong>debounce</strong>.</li><li id="9d62">If attributes <code>width</code> and <code>height</code> are specified, it renders a placeholder of the same size as the image by default. That <strong>avoids the browser recalculating the layout</strong> when the image appears in the viewport and is loaded.</li><li id="3e4c">It allows setting a <strong>placeholder image</strong>, useful to load low resolution assets before downloading the full-resolution ones.</li><li id="adcb">A <strong>custom placeholder component</strong> can be specified as well.</li><li id="a1b7">Comes with several <strong>on-visible effects like blur, black-and-white to color and opacity transitions</strong>. And it’s very easy to add new ones with CSS!</li></ul><figure id="7041"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*rVEZ5fp0iQO3Q2pX9SLDeg.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*rVEZ5fp0iQO3Q2pX9SLDeg.gif" /></div></div></div><figcaption>Images get color when the full-resolution version is loaded. That’s the <strong><em>black-and-white</em></strong><em> effect!</em></figcaption></figure><ul><li id="0777">You can specify a <strong>threshold</strong>, so images start loading before they appear on the screen.</li><li id="dace">It includes <strong>beforeLoad and afterLoad</strong> events.</li><li id="b706">It’s <strong>standards-friendly, </strong>so you can specify any standard &lt;img&gt; attribute. In addition, it never produces something like <code>&lt;img src=""/&gt;</code>, which is not a valid markup.</li><li id="334c">There is <strong>no CSS</strong> by default and there are very few inline styles — which are basically used to set the size and background of the placeholder. So you probably will not have to fight against the default styles because they are minimal!</li></ul><h3 id="d8a6"><strong>That’s cool, but I want to lazy-load a component which is not an image</strong></h3><p id="1ebd">No worries, <code>LazyLoadComponent</code> comes to the rescue! You can use it in a similar way than <code>LazyLoadImage</code> but you must provide a child that will be lazy loaded. It can be any other component or element.</p><figure id="5567"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F3616980%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="6010">You can use most of the props you were using in <code>LazyLoadImage</code> like <code>beforeLoad</code>, <code>afterLoad</code>, <code>threshold</code>, etc.</p><p id="6651">Notice however, that in this case <code>afterLoad</code> will be called immediately after the placeholder is rendered. Use <code>LazyLoadImage</code> if you want it to get called after the image is loaded.</p><h3 id="18bb">But I have an image gallery with hundreds of images, I don’t want all of them to listen to scroll events</h3><figure id="51e1"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*SPn120U1xS-cv8VKddGOvw.gif?q=20" /><div class="readableLargeImageContainer"><img /></div></div></div><figcaption>In image galleries, <strong>trackWindowScroll</strong> might be handy to improve performance.</figcaption></figure><p id="af2c">Scroll and resize events are tricky because they can be fired more than a dozen times in less than a second, that’s why the component comes with <strong>throttle</strong> by default.</p><p id="14d6">However, if you have an image gallery or any other project with many components to lazy load, there is another way to improve performance. Instead of making every component subscribe to scroll/resize events, subscribe a parent of them.</p><p id="7bc6">That’s what the HOC <code>trackWindowScroll</code> does. Wrap the deepest common parent of the lazy load components with this HOC and it will receive a prop named <code>scrollPosition</code>. Pass it down to the lazy-loading children, and they will be clever enough to know they don’t need to subscribe to the scroll/resize events.</p><figure id="8fd0"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F3616980%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></div></figure><p id="2889">This way we can have dozens, hundreds or even thousands of components that lazy load while only one of them is listening to the scroll/resize events.</p><h3 id="d3b9">What’s next?</h3><p id="b103">There are still <a href="https://github.com/Aljullu/react-lazy-load-image-component/issues/1" target="_blank">many features</a> that I would like to add, for example, supporting scroll events in a container element with <code>overflow: scroll</code>. But it’s enough for what I needed for now and will be happy to continue developing it or <a href="https://github.com/Aljullu/react-lazy-load-image-component" target="_blank">accepting PR</a> if somebody is interested.</p>