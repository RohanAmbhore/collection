<a href="https://hackernoon.com/routing-in-react-the-uncomplicated-way-b2c5ffaee997">https://hackernoon.com/routing-in-react-the-uncomplicated-way-b2c5ffaee997</a><div id="articleHeader"><h1>Routing in React, the uncomplicated way</h1></div><p id="bb80">I’ve used React Router on most of the projects I’ve worked on over the last few years, and as I’ve dealt with different routing requirements, I’ve always been pleased to see that React Router could handle whatever I threw at it.</p><p id="3851">But this flexibility doesn’t come for free.</p><p id="60d5">It’s kinda like buying a VCR that can do multi-timeslot recording, automated channel switching, and sports a menagerie of inputs and outputs. A deluxe piece of technology to be sure, but it also has 73 buttons on the remote.</p><p id="6db8">Sometimes you just need a play button.</p><p id="03f7">So, I decided to strip React Router out of one of my sites and implement something that was tailor made.</p><p id="0fe1">What you will find below is certainly nothing revolutionary, and if you’re an expert, there’s probably nothing in this post for you. But the adventure was a success and I found the process interesting.</p><p id="2877">Maybe it will be interesting to you too.</p><h3 id="c57e">Sweetening the pot</h3><p id="732a">Although I didn’t start this with the aim of improving performance, there was a rather staggering 20% drop in load time.</p><figure id="99e6"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*p2ljKftqaWKSqVyhcrPYbw.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*p2ljKftqaWKSqVyhcrPYbw.png" /></div></figure><p id="c628">The package size dropped by 13% from 104 KB gzipped to 90 KB, so I would have expected a drop in download/parse time of about the same. I’m honestly not sure where the other 7% improvement came from, but I’ll take it.</p></section><section><div><div><p id="1640">Let’s get into it.</p><h3 id="0894">Step 0: Requirements gathering</h3><p id="4760">My requirements are actually pretty simple:</p><ul><li id="de4f">Based on the URL, render a particular page (represented by a component)</li><li id="c0f4">When the user clicks a link, update the URL (without a full page refresh)</li><li id="a63b">When the URL updates, update the page</li></ul><h3 id="cf60">Step 1: Selecting a page based on the URL</h3><p id="1af1">The component below takes a URL (actually just the pathname part) as a prop, maps that to a component, and renders it. Couldn’t be simpler.</p><figure id="a758"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F4443482%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure><p id="4cc7">An aside… This is actually a great example of my new development paradigm: “don’t build for tomorrow what could be done tomorrow”.</p><p id="6d30">You see, this structure isn’t well suited to route matching. And I can’t define actions here to assign to each route. And it’s in the same module as the <code>&lt;App&gt;</code> component, so can’t be used elsewhere.</p><p id="467f">Should I arrange it now so that I can more easily add these features later if I want? Isn’t that good, future-proof code?</p><p id="956b">The correct question is: “will it be <em>harder </em>to do that in the future than it is to do today?” The answer is quite obviously no, so for today at least, my code will not be more complex that it needs to be.</p></section><section><div><div><p id="b3ef">Next up, I need to pass in the current pathname to this component, on both the server and in the browser.</p><h3 id="face">Step 2: Server-side rendering</h3><p id="81ea">I’m using <code>express</code> on the server, so pathname is available in <code>req.url</code>, which means I can render the page like so:</p><figure id="11e4"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F4443482%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure><p id="f42f">Really, that’s the whole thing. I hadn’t thought about this part until I got to it, and was quite pleased by how simple it was. (In a more serious environment I’d handle 404s with a <code>res.status(404)</code> here.)</p></section><section><div><div><p id="4eab">Okey dokey, that’s big bad server-side-rendering out of the way, on to …</p><h3 id="d9b3">Step 3: Client-side rendering</h3><figure id="f22a"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F4443482%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure><p id="0a21">Boom. Because <code>location.pathname</code> in the browser matches <code>req.url</code> on the server, everything just works.</p></section><section><div><div><p id="1569">At this point, the app is working for any given route and is pleasingly simple. Now I just need to be able to update that route in the browser …</p><h3 id="6bfa">Step 4: Updating the URL</h3><p id="a8a9">There are two approaches to this particular step:</p><ol><li id="4337">Update the URL in one place. That is, treat <code>document.location</code> as the ‘state’ that holds the current route. Then listen for changes in <code>document.location</code> to update the page.</li><li id="dd63">Update the URL in two places. That is, store the ‘current route’ in an actual store and update both the URL and the store at the same time. No need to listen for changes to <code>document.location</code>.</li></ol><p id="be4f">Number two means either passing some <code>updateRoute()</code> method in to every <code>&lt;Link&gt;</code> or using React’s context. I dont know about you, but I have never used React’s context for something and not regretted it later (sage advice from Facebook: “If you want your application to be stable, <a href="https://facebook.github.io/react/docs/context.html" target="_blank">don’t use context</a>.”).</p><p id="cef6">So, #1 it is.</p><p id="fe7a">I just need a component that updates the URL when a link is clicked. (Although not for external links, nor for links where the user wants a new tab.)</p><figure id="0dea"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F4443482%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure><p id="c686">I’ll tell you all about <code>history.push()</code> in the next section.</p><p id="3a86">I can now use a link like: <code>&lt;Link href="/about"&gt;About&lt;/Link&gt;</code> and trust that it will update the URL to <code>/about</code> when clicked.</p></section><section><div><div><p id="580a">Bonus tip: always use a <code>&lt;Link&gt;</code> component instead of anchor tags directly. Then check to see if you’re creating an <code>&lt;a&gt;</code> with <code>target="_blank"</code>. If you are, add <code>rel="noopener noreferrer"</code> automatically. <a href="https://www.jitbit.com/alexblog/256-targetblank---the-most-underestimated-vulnerability-ever/" target="_blank">This is why</a>.</p></div></section><section><div><div><p id="f346">The next step is to make sure the <code>&lt;App&gt;</code> component re-renders when the URL changes …</p><h3 id="e1a3">Step 5: Reacting to URL changes</h3><p id="c492">I had originally thought I’d just use good ol’ HTML5 History, but the history API has no concept of ‘listening’ to URL changes.</p><p id="9412">Dammit.</p><p id="a5cb">No problem though, I’ll just use the <code><a href="https://www.npmjs.com/package/history" target="_blank">history</a></code> package that <code>react-router</code> uses.</p><p id="2622">Implementing this package was a little bit slippery because I had to call <code>listen</code> on the same <em>instance</em> of <code>history</code> as the one on which I called <code>.push()</code>.</p><p id="ec91">So I needed a module that exported an instance of <code>history</code>, and then I could rely on the fact that subsequent <code>import</code>s of this module would return a cached version, and therefore the same instance. The module looked like this:</p><figure id="54c7"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F4443482%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure><p id="c4dc">But hang on, if I need a module to wrap the history package so that I’m using the same instance, that means that under the hood they’re probably just registering event listeners so that when I call <code>push()</code>, they call the callbacks registered with <code>listen</code>.</p><p id="660f">Well shucks, I can do that myself.</p><figure id="4eda"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F4443482%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure><p id="e2e2">There we go, saved myself 2.5 KB.</p></section><section><div><div><h4 id="bc25"><strong>A brief performance intermission</strong></h4><p id="adce">You might think getting excited over 2.5 KB is silly, but the load time dropped by a decent 15%.</p><p id="36c5"><em>Fifteen</em> percent.</p><p id="588d">I’ll bet neither of us would have predicted that adding a little tiny package would add so much to the load time.</p><p id="da8d">This is why I highly recommend keeping a spreadsheet handy to record these sorts of things. These are my scribblings for this exercise…</p><figure id="cee2"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*rfda5tbX6qqwAcN4wFrhaQ.png?q=20" /><div class="readableLargeImageContainer"><img /></div></figure><p id="ecc5">I log the time in <code>componentDidMount()</code> of <code>&lt;App&gt;</code>. Then in Chrome DevTools, I tick <strong>Preserve log </strong>in the console settings, throttle the network and CPU, then just keep hitting refresh to the beat of <em>Stayin’ Alive</em>.</p><figure id="b1cf"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*2dMIpMLCNtHiN-1Q21_oog.png?q=20" /><div class="readableLargeImageContainer"><img /></div><figcaption>uh, uh, uh, uh, uh</figcaption></figure><p id="cdf7">If I was to get all preachy I would suggest that if you <em>don’t</em> do something like this, your site is almost certainly slower than it needs to be.</p><p id="a8ca"><strong>End performance intermission.</strong></p></section><section><div><div><p id="6dd3">Earlier I showed that I have an <code>&lt;App&gt;</code> component that accepts a <code>pathname</code>. On the server I pass it <code>req.url</code>, in the browser I pass it <code>location.pathname</code>.</p><p id="b709">Remember?</p><p id="70a4">But now I want to update the pathname. So instead of using the prop directly, I will set the <em>state</em> to hold this pathname in the constructor.</p><p id="539e">When the URL changes, my listener will fire, being passed the new pathname, which I can use to update the state.</p><p id="e331">So now it looks like this:</p><figure id="f905"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars2.githubusercontent.com%2Fu%2F4443482%3Fv%3D3%26s%3D400&key=4fce0568f2ce49e8b54624ef71a8a5bd&width=40" /></div></figure><p id="2f90">That’s it!</p><p id="f553">Very simple routing without all the extra stuff.</p><h3 id="03a0">Source</h3><p id="3341">If you’re interested, I tried to keep the change as simple as possible and did it in <a href="https://github.com/davidgilbertson/davidg-site/commit/2241c110bebd6f0006a345b9a963856231997672" target="_blank">a single commit</a>. But please, before you go and view the code, know that I originally wrote the site two years ago and thus contains none of the wisdom I have gathered over the last two years.</p><p id="4ebe">In other words, it’s shit and I know it.</p><h3 id="e3f5">Was it worth it?</h3><p id="e649">I like to look back on experiments like this and ask myself if I would actually do this in a production environment in exchange for money.</p><p id="29e0">The answer this time is an unnecessarily loud yes.</p><p id="015e">Unlike <a href="https://hackernoon.com/how-i-converted-my-react-app-to-vanillajs-and-whether-or-not-it-was-a-terrible-idea-4b14b1b2faff#.9c7r9ojc1" target="_blank">removing React</a>, or <a href="https://medium.com/@david.gilbertson/building-a-website-without-css-trials-and-tribulations-5aa30499f57c#.2og8xsli5" target="_blank">doing CSS in JavaScript</a> or <a href="https://hackernoon.com/you-might-not-need-if-statements-a-better-approach-to-branching-logic-59b4f877697f#.70hk3r1i3" target="_blank">throwing out </a><code><a href="https://hackernoon.com/you-might-not-need-if-statements-a-better-approach-to-branching-logic-59b4f877697f#.70hk3r1i3" target="_blank">if</a></code><a href="https://hackernoon.com/you-might-not-need-if-statements-a-better-approach-to-branching-logic-59b4f877697f#.70hk3r1i3" target="_blank"> statements</a>, there is nothing ‘weird’ about this code — nothing a new developer would need time to decipher, and nothing that needs documenting more so than any other code.</p></section><section><div><div><p id="a2b3">Well this is embarrassing. I was going to add a bit here about parsing more complex paths like <code>/user/:id</code>. I recalled that at some point in the past I’d read an article that mentioned this.</p><p id="63b7">I went searching for it, found it, read through it, aaaand, it turns out I’ve pretty much ripped off the whole article.</p><p id="69fc">So, um, prior art: <a href="https://medium.freecodecamp.com/you-might-not-need-react-router-38673620f3d#.xr5w1s4er" target="_blank">You might not need React Router</a> by <a href="https://medium.com/@tarkus" target="_blank">Konstantin Tarkus</a>. Oh wait, that guy’s the Kirasoft guy, maker of <code>react-starter-kit</code>. Yeah don’t bother with my post, go read his instead. I should put this at the top…</p><h3 id="5559">Angry commenter appeaser section</h3><p id="5cdc">I’ve noticed that I get the angriest comments on posts that could potentially be construed as “you’re doing it wrong” (and I’ve got a decent sample size).</p><p id="f2db">I have grown to enjoy the ferocity of such remarks (“couldn’t code his way out of a wet paper bag” is my fav so far), but I figured I might preempt a few of the most likely misunderstandings:</p><ul><li id="0743">This is not an anti-react-router post. React Router does what it’s supposed to do well.</li><li id="8df7">Nor is it a my-solution vs their-solution competition. So no need to count and compare lines of code.</li><li id="37e3">“If what I have works, why would I go and write my own from scratch?” Settle down, nobody’s twisting your arm.</li><li id="9f8c">“React Router has documentation, yours doesn’t.” Yeah, 27 pages of documentation. But we’ve already agreed that this isn’t a competition.</li><li id="a30d">“React Router was never meant to be used for such a paltry site.” Yeah, that’s what I’ve just come to realise.</li></ul><h3 id="4a48">The end</h3><p id="5dbf">Adios, amigos.</p></div><div><blockquote id="f922"><a href="http://bit.ly/Hackernoon" target="_blank">Hacker Noon</a> is how hackers start their afternoons. We’re a part of the <a href="http://bit.ly/atAMIatAMI" target="_blank">@AMI</a> family. We are now <a href="http://bit.ly/hackernoonsubmission" target="_blank">accepting submissions</a> and happy to <a href="mailto:partners@amipublications.com" target="_blank">discuss advertising & sponsorship</a> opportunities.</blockquote><blockquote id="708a">If you enjoyed this story, we recommend reading our <a href="http://bit.ly/hackernoonlatestt" target="_blank">latest tech stories</a> and <a href="https://hackernoon.com/trending" target="_blank">trending tech stories</a>. Until next time, don’t take the realities of the world for granted!</blockquote></div><div><figure id="3936"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*35tCjoPcvq6LbB3I6Wegqw.jpeg?q=20" /><div class="readableLargeImageContainer"><img /></div></figure></section>