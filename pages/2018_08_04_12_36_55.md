<a href=""></a><div id="articleHeader"><h1>              Best practice when a mutation deletes an object            #899    </h1></div>


  <div>
    <div>
        <div>
          
          Closed
        </div>
    
    <div>
        <a href="/yurigenin" target="_blank">yurigenin</a>  opened this Issue
        <relative-time>on Nov 12, 2016</relative-time>
        Â· 75 comments
    </div>
  



    <h2>Comments</h2>
    
      

      

        

          <div>
            




            
<div id="issue-188891113">
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>What is the best practice for deleting items from the apollo store when a mutation deletes them on the server? I could not find anything related to this in the docs. Do I just have to return ids of deleted items as a result of mutation and then use reducer/updatequeris to manually delete items from the store? Or there is some way to let apollo client handle it automatically? Any help is appreciated.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>

          </div>

          

  


  


  
<div>
    
  <div>

  




  
<div id="issuecomment-260480061">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/yurigenin" target="_blank">@yurigenin</a> Right now <code>updateQueries</code> or result reducers are the recommended way to remove items from the store. We're open to re-implementing better ways of doing this, so if you have an idea, please share it here!</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-260981838">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/helfer" target="_blank">@helfer</a> <a href="https://github.com/stubailo" target="_blank">@stubailo</a> How do I actually purge the objects from the store? If I use reducers/updateQueries it only removes objects from the lists that contain them. But objects themselves stay in the store and become pretty much orphaned.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-260985122">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/yurigenin" target="_blank">@yurigenin</a> I think at the moment, you'd need to remove them manually, but I may just have missed that functionality when reading through the code</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-261000515">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/yurigenin" target="_blank">@yurigenin</a> right now there's no cache expiration. Deleting objects manually can be a bit dangerous, because you need to make sure that no other query is using them.</p>
<p>A few people have already asked for this, so here's a discussion around cache expiration: <a href="https://github.com/apollographql/apollo-client/issues/825" target="_blank">#825</a></p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-265048281">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>It might help to have an example of the updateQueries best practice. Anyone here able to share it, it would be great to have in the documentation, because it is part of any CRUD app :).<br />
How about the option of creating a function that removes an object based on the data-id? In this way I can just call that function after delete to clear it from the local cache, it might even be called automatically if the mutation returns null or so?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-265420107">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Yeah, also faced up with this and have no idea how to correctly implement this behavior</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-265463972">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I think the easiest and most flexible way is to use the reducer function. At least I got it working quite easily using that. Still maybe a bit too much boilerplate for such a common action, but at least it solves it for me.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-265775122">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Can someone provide example code of how to use reducer function to remove store data?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-265868567">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Already posted, but check this link <a href="http://stackoverflow.com/questions/40484900/how-do-i-handle-deletes-in-react-apollo?answertab=active#tab-top" target="_blank">http://stackoverflow.com/questions/40484900/how-do-i-handle-deletes-in-react-apollo?answertab=active#tab-top</a></p>
<p>I also use <code>react-addons-update</code> <a href="https://facebook.github.io/react/docs/update.html" target="_blank">https://facebook.github.io/react/docs/update.html</a></p>
<pre><code>npm install --save react-addons-update
</code></pre>
<p>Using the following query</p>
<pre><code>const GET_BRANDS = gql`
  query brands {
    brand_categories {
      id title
      brands {
        id title description active pos
      }
    }
  }`
</code></pre>
<p>This is my <code>updateQueries</code> function</p>
<pre><code>import update from 'react-addons-update'

export const DELETE_BRAND = gql`
  mutation deleteBrand($id: Int!) {
    deleteBrand(id: $id)
  }`

graphql(DELETE_BRAND, {
  props: ({ ownProps, mutate }) =&gt; ({
    deleteBrand: (id) =&gt; mutate({
      variables: { id },
      optimisticResponse: {
        deleteBrand: id,
      },
      updateQueries: {
        brands: (prev, { mutationResult }) =&gt; {
          // will find category and brand index from the previous list
          let categoryIndex, brandIndex
          prev.brand_categories.forEach((category, cindex) =&gt; {
            const bindex = category.brands.findIndex(b =&gt; b.id === id)
            if (bindex &gt; -1) {
              categoryIndex = cindex
              brandIndex = bindex
            }
          })
          // then remove brand from the next list
          return update(prev, {
            brand_categories: {
              [categoryIndex]: {
                brands: { $splice: [[brandIndex, 1]] }
              }
            }
          })
        },
      },
    }),
  }),
}),
</code></pre>
<p>Side question: is there an easier way to find indexes?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-265871937">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>The problem is that this will not delete the brand itself from the store... It only updates the list.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-265938051">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Here my version as a reducer. If you use proper ids, you get updates for free, but you need to handle the case of addition and removal from lists.</p>
<div><pre>const withContentItem = graphql(gql`
[YOUR QUERY] 
`, {
  options: props =&gt; ({
    variables: { ... },
    reducer: (state, action) =&gt; {
      // insert
      if (
        action.type === 'APOLLO_MUTATION_RESULT' /* is it a mutation? */
        && action.operationName === 'mutateElement' /* mutate element? */
        && action.result.data.mutateElement.contentItemId === state.contentItem.id /* operate on right content id? */
        && !state.contentItem.elements.find((el) =&gt; el.id === action.result.data.mutateElement.id) /* not already in list */
      ) {
        return update(state, {
          contentItem: {
            elements: {
              $push: [action.result.data.mutateElement] /* add to end of list */
            }
          }
        })
      }
      // delete
      if (
        action.type === 'APOLLO_MUTATION_RESULT'
        && action.operationName === 'deleteElement'
        && action.result.data.deleteElement.contentItemId === state.contentItem.id /* operate on right content id? */
      ) {
        return update(state, {
          contentItem: {
            elements: {
              $splice: [[state.contentItem.elements.findIndex(el =&gt; el.id === action.result.data.deleteElement.id), 1]]
            }
          }
        })
      }
      return state
    }
  }),
})</pre></div>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  


  
<div>
    
  <div>

  




  
<div id="issuecomment-288094768">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>We are missing one big use case when frontend can not determine results of what queries and how were changed after deletion (same applies for creating new entities). Let's say I queried <code>users(age=29, limit=20, offset=10, sort='name')</code>.<br />
Then I sent mutation to delete some user. And now I can not use <code>reducer</code> or <code>updateQueries</code> because I don't know HOW should I change results of users query. Only server knows how to filter users based on provided variables.<br />
The only thing I can do is to invalidate somehow cache for all <code>users</code> queries. But as far as I know there is no way to do it in Apollo. Am I right?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-288978293">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/nosovsh" target="_blank">@nosovsh</a> You can invalidate the entire cache, for everything, on a delete. That's what I ended up going with as a solution, though in my application deletes are a rarity anyways (i.e. perhaps once a week for a user at most).</p>
<p>Yes, it would be really nice if there was a way to invalidate a single item using the object ID the store is using to keep track of it, across all possible queries that would be including it. I tried to suss out exactly how the application is keying the cache for objects, and why all the solutions seem to couple it with the query (it must not be simple key/value, or these suggested workarounds would be total overkill), but after about an hour of digging into the code, I eventually just decided to go with the nuke option.</p>
<p>A clear explanation of the store and cache invalidation strategies would be quite welcome - as someone that isn't particularly familiar with Relay, I feel like most of the examples/discussion/documentation on the Apollo internal cache assumes a strong familiarity with Relay's store, and how it's plugged into Apollo.</p>
<p>For example, it wasn't clear at all to me if I zap a cached item from one query, if it zaps it from other queries that would return it, or if on deletion I need to essentially loop over every possible query that would return it and check if it's in the cache, and if so, zap it for each query. And if zapping it once zaps it everywhere, I'm again confused why I can't just zap it directly using the objectID generated to track it.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-289427048">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/jamiter" target="_blank">@jamiter</a> problem with <code>resetStore()</code> is that after you call it all active queries will be immediately refetched. And because Apollo uses <code>recycling</code> of queries a lot of them could be active even if components that were using them already gone. see <a href="https://github.com/apollographql/apollo-client/pull/462" target="_blank">#462</a><br />
That can cause enormous network load so I can not use it.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-289431887">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/jamiter" target="_blank">jamiter</a>
  

    </strong>

    commented

    <a href="#issuecomment-289431887" target="_blank"><relative-time>on Mar 27, 2017</relative-time></a>


    
      
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/nosovsh" target="_blank">@nosovsh</a>, I think you mentioned me by accident.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  


  
<div>
    
  <div>

  




  
<div id="issuecomment-300911650">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>(Please tell me if my question would be better asked in SO instead.)</p>
<p>I was using <code>updateQueries</code> to delete from the store but it only works for the current parameters in a query and I'm deleting data for other cached parameters (ie. I filter by month and I'd like to delete data from multiple months). Anyone knows the recommended way to do this (without refetching)?</p>
<p>Plus, I thought migrating to the new <code>update</code> API could give me more flexibility on this matter, but I couldn't find any doc about <strong>deleting</strong> from the store when using <code>update</code>. What is the recommended way to do this? Does it support the case I described above?</p>
<p>Thanks!</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-300966497">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/renato" target="_blank">@renato</a> with the <code>update</code> function you should be able to write <code>null</code> to the store. This won't actually remove any data, but it will break the links, so to the client it will look like the data isn't there any more and it will refetch.</p>
<p>What's the reason you want to delete from the cache and how important is that feature to you?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-301510348">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/helfer" target="_blank">@helfer</a> I'm sorry, I'm probably missing something.</p>
<p>I don't really need to "delete from the cache" but this is the way that worked so far for me when deleting something from the view.</p>
<p>I've a list of items in my React view injected by Apollo. When I execute a mutation that deletes one item how do I remove that specific item from my view? So far I've been deleting it from the cache using the <code>updateQueries</code> method.</p>
<p>However, the last query I'm working on has a month parameter and I can navigate through months so they become cached by Apollo. I've a mutation that deletes some items that affects multiple months, not only the currently active parameter. The <code>updateQueries</code> method only affects the active parameter so when I navigate to other months after this mutation, the old cache (before the delete operation) is loaded.</p>
<p>If you don't delete from the cache in these situations, what is the solution? Just invalidate the cache or refetch?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-304574412">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><code>What's the reason you want to delete from the cache and how important is that feature to you?</code></p>
<p>To synchronise my view model (mobx) with my model store (apollo)</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-305214067">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Based on the blog post <a href="https://dev-blog.apollodata.com/apollo-clients-new-imperative-store-api-6cb69318a1e3#0e85" target="_blank">Apollo Clientâ€™s new imperative store API</a>, here's how I setup delete mutations:</p>
<pre><code>this.props.FooDelete({
  variables: {
    input: {
      id: this.props.id
    }
  },
  update: (store, { data: { deleteFoo } }) =&gt; { 
    const data = store.readQuery({query: fooQuery() }); // the GraphQL query is returned by the function fooQuery
    const index = data.allFoos.edges.findIndex(edge =&gt; edge.node.id === this.props.id);
    if (index &gt; -1) {
      data.allFoos.edges.splice(index, 1);
    }
    store.writeQuery({ query: fooQuery(), data });
  }
})
.then( res =&gt; {
  console.log('Foo Deleted.');
});
</code></pre>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308711752">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I am confused. Most of the sample code I see on this thread, seems to deal with running a delete mutation from a single query. What if I actually have multiple queries referencing that object? I thought the whole point of Apollo tracking refs ie Type-X was to handle such a use case.</p>
<p>For example say user deletes User-1. User-1 is referenced by multiple queries say queryA and queryB. Based on what I see in this thread, it seems it would be the responsibility of the component update to correctly update the store for each of the referencing queries??</p>
<p>I hope I a missing the point here as this would be a maintenance nightmare! So getting back to the original question: What is the best way to handle this use case ie delete the reference and have apollo remove the reference from ALL queries tracking that instance?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308735861">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/derailed" target="_blank">@derailed</a> a few thoughts:</p>
<ol>
<li>The store is only going to save the user as one item in the cache so even if multiple queries are returning the user, it should only need to be removed once. If you haven't already, try out the Chrome Apollo extension, which will allow you to see how the store is updated post mutation.</li>
<li>If there are items in the store related to the user such as BlogUser, ToDoUser, etc., those would most likely need to be explicitly removed from the store within the "update" section of the mutation.</li>
<li>Generally, mutations are only going to impact a small number of tables, in which case the mutation update of the store makes sense. However, if a particular mutation is going to have wide ranging affects, you could consider resetting the entire store with <a href="http://dev.apollodata.com/react/auth.html#login-logout" target="_blank">client.resetStore()</a>. It's documented as part of the login/logout functionality, but it can be used elsewhere.</li>
</ol>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308756240">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <div>Hi Chris,

  Thank you for the reply! I am at loss here. I have a bunch of queries
falling in this use case ie referencing a user
  object. I am indeed using the extension and it seems to report the
correct behavior per the implementation ie the user object is deleted from
the query but still shows on the left handside under the store tab aka
`Apollo Client State, which leaves me to believe that user is still in the
store. So as you can see my update cb currently deletes the user from the
current query and not the actual store. Not sure how do actually to this??

  As you can see here 3 other queries references that user and need to be
updated. I haven't yet found a way to deal with that elegantly besides
having to refetch to make sure that user is now gone in related queries.
That said my update scenarios work ie on an update mutation the user
changes are correctly propagated which leads me to believe the store is
actually wired correctly?

  My expectations here is during a delete mutation all the queries having
the referenced user object should be "automatically" deleted without having
to manually update all related queries as the reference is no longer
active. Per your <a href="https://github.com/apollographql/apollo-client/issues/2" target="_blank">#2</a> point it does not seems to be handled by Apollo that
way.  Hence to currently get the right effect and short of either reseting
or refetching one is left with having to know all the potential queries
that might be affected by that deletion.
Does this sound right, or am I missing it?

Thank you for you clarifications!!

  Here is what I have in my code when a user is deleted:

this.apollo.mutate({
mutation: DeleteUser,
variables: deleteInputs(this.user.id),
// BOZO!! Lame!
refetchQueries: [{ query: Facilities }, { query: Accounts }, { query:
OrphanUsers }],
optimisticResponse: optimisticDelete(id),
update: (store: any, data: any) =&gt; {
const cache = store.readQuery({ query: PvdmUsers });
store.writeQuery({
query: PvdmUsers,
data: {
pvdmUsers: _.filter(cache.pvdmUsers, (u: UserFragment): boolean =&gt; { return
u.id != id })
}
});
}
})
.toPromise()
.then(() =&gt; this.back())
.catch(error =&gt; this.error = error.message);</div>
<a href="#" target="_blank">â€¦</a>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308785360">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/derailed" target="_blank">@derailed</a> - in the Apollo Chrome Extension, under the Store tab, the User is not removed after a delete mutation? If you post the code for the delete mutation, then I can give feedback on it.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308823825">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/chris-guidry" target="_blank">@chris-guidry</a> - Tx Chris!</p>
<p>I believe, the user is correctly removed from the query but not from the store. I think I am<br />
not understanding out to actually remove my user from the store. This code works for the<br />
users query. However I have 2 other query referencing that user and the given user still show<br />
in those.</p>
<p>So I think my confusion here is I expect the delete to be propagated to the other queries since<br />
it's a delete mutation, but don't think that's the way things actually work. But perhaps I am<br />
totally missing the point here??</p>
<p>Here is the code</p>
<div><pre>   this.apollo.mutate({
      mutation: DeleteUser,
      variables: deleteInputs(this.user.id),
      // BOZO!! Lame!
      refetchQueries: [{ query: Facilities }, { query: Accounts }, { query: OrphanUsers }],
      optimisticResponse: optimisticDelete(id),
      update: (store: any, data: any) =&gt; {
        const cache = store.readQuery({ query: PvdmUsers });
        store.writeQuery({
          query: PvdmUsers,
          data: {
            pvdmUsers: _.filter(cache.pvdmUsers, (u: UserFragment): boolean =&gt; { return u.id != id })
          }
        });
      }
    })
      .toPromise()
      .then(() =&gt; this.back())
      .catch(error =&gt; this.error = error.message);</pre></div>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308828871">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/MichaelDeBoey" target="_blank">MichaelDeBoey</a>
  

    </strong>

    commented

    <a href="#issuecomment-308828871" target="_blank"><relative-time>on Jun 16, 2017</relative-time></a>


    
      <include-fragment>
            
  â€¢


  
    <summary>
      <div>
        
            edited
        
        
      </div>
    </summary>
    
  

      </include-fragment>
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/derailed" target="_blank">@derailed</a> You're right that the User is still in the store, but isn't given back when asking for the <code>PvdmUsers</code> query.<br />
Currently there's no way of really deleting an object from the store I think (hence why this thread is still alive).</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308834382">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/MichaelDeBoey" target="_blank">@MichaelDeBoey</a> <a href="https://github.com/chris-guidry" target="_blank">@chris-guidry</a> - Tx Michael! I think you are right.</p>
<p>One thing just dawned on me. I think a delete mutation does not have any special meaning in Apollo, it's just a mutation. Thus it would be the resp of the dev on the update to make sure the deletion is correctly propagated across all queries referencing it. I think this is why I have been struggling with this concept as I thought given the special handling of refs that though regular mutation works nicely, in a delete situation special care must be taken to ensure the store integrity. I hope I am wrong about this, but if not this is going to be very painful...</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308844571">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/MichaelDeBoey" target="_blank">MichaelDeBoey</a>
  

    </strong>

    commented

    <a href="#issuecomment-308844571" target="_blank"><relative-time>on Jun 16, 2017</relative-time></a>


    
      <include-fragment>
            
  â€¢


  
    <summary>
      <div>
        
            edited
        
        
      </div>
    </summary>
    
  

      </include-fragment>
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/derailed" target="_blank">@derailed</a> No you're right. With a normal mutation (create or update), you get the created/updated Object back as a response, so Apollo knows how to handle it (in most cases). When deleting an object, Apollo doesn't know what to do (yet), so we have to specify it ourself in the <code>update</code> method we provide.<br />
If Apollo would automatically delete the object from the store, that could always break several things.</p>
<p>For instance when you have queries <code>ListAllUsers</code> and <code>ListAdminUsers</code>, where <code>User:1</code> is in both lists and Apollo then deleted <code>User:1</code> from the store, then de references would be deleted in both queries.<br />
But what if we have another query <code>ListBlogPost</code>s, where you have the following:</p>
<div><pre>query {
  ListBlogPosts () {
    id
    title
    user {
      id
      name
    }
  }
}</pre></div>
<p>Apollo can't know what to do (unless we tell it). Does it also delete all the <code>Blogpost</code>s?, does it only delete the reference to the deleted user?<br />
That's why we have to specify it ourself in the <code>update</code> method.</p>
<p>I know it can be cumbersome if you have a lot of references to the deleted <code>User</code>, but that's (currently) the only way to handle it I think.</p>
<p>Maybe <a href="https://github.com/helfer" target="_blank">@helfer</a> and/or <a href="https://github.com/stubailo" target="_blank">@stubailo</a> can correct me if I'm wrong?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308847688">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/MichaelDeBoey" target="_blank">@MichaelDeBoey</a> Thank you Michael for the explanation! I was hoping there was a better solution here as I am going to need to a) figure out which queries are active during the delete. b) for each active query traverse to see if that user is actually referenced c) delete the ref d) update the store. Lots of manual operation here especially in lite of new features creeping in and introduction new refs to users, that will need to update that delete operation.</p>
<p>Yikes!</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308849760">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/MichaelDeBoey" target="_blank">MichaelDeBoey</a>
  

    </strong>

    commented

    <a href="#issuecomment-308849760" target="_blank"><relative-time>on Jun 16, 2017</relative-time></a>


    
      <include-fragment>
            
  â€¢


  
    <summary>
      <div>
        
            edited
        
        
      </div>
    </summary>
    
  

      </include-fragment>
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/derailed" target="_blank">@derailed</a> I don't think you have to see if the query is active, you can just do the <code>readQuery</code> I think (I'm not sure tho <g-emoji>ðŸ˜•</g-emoji>).<br />
The only pain will be that you need to read every query with every possible <code>variables</code> I think, that's why the <code>updateQueries</code> comes in handy, 'cause you can name your queries and just put in all the names there and they will all be re-run with the right <code>variables</code> they were already executed with.<br />
Or maybe you can check just check the <code>ROOT_QUERY</code> for all executed queries?</p>
<p><a href="https://github.com/helfer" target="_blank">@helfer</a> or <a href="https://github.com/stubailo" target="_blank">@stubailo</a> should confirm that last one, 'cause I'm not sure if that's possible or not</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308923800">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Hi <a href="https://github.com/derailed" target="_blank">@derailed</a>! <a href="https://github.com/MichaelDeBoey" target="_blank">@MichaelDeBoey</a> is right, there's currently no easy way of deleting things from the store, but we're thinking of adding that soon. Right now you'll have to delete the reference from all queries that use it. A simpler way is to refetch all the queries that could reference that object, which you could even do as part of the mutation, if you wanted to (in that case it would be called a "fat query").</p>
<p>If we added a special <code>store.deleteObject</code> functionality or something like that, it could work by automatically removing all references or simply marking the object as deleted and then not including it in lists etc. any more. The question is what should happen to queries that now have incomplete data. Most likely the best we could do is return <code>null</code> in that case.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-308950923">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>This really seems to go to the same point I made an issue for here: <a href="https://github.com/apollographql/apollo-client/issues/1697" target="_blank">#1697</a></p>
<p>This seems to be the clue from <a href="https://github.com/MichaelDeBoey" target="_blank">@MichaelDeBoey</a></p>
<blockquote>
<p>The only pain will be that you need to read every query with every possible variables I think, that's why the updateQueries comes in handy, 'cause you can name your queries and just put in all the names there and they will all be re-run with the right variables they were already executed with.</p>
</blockquote>
<p>Is there no way Apollo can "understand" the relation between resources?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-309109110">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/helfer" target="_blank">@helfer</a> - Thanks for the update Jonas! I think that call will be helpful. Also a call to see who has contention on a given object would be nice to have. Think the store might be headed toward a client side db??</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-309113501">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>A db in redux? Is that a thing?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-309193168">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>We're headed in a somewhat different direction that's very close to the imperative store API we added before 1.0. The store will be pluggable, and have functions like <code>readQuery,</code>writeQuery<code>,</code>watchQuery<code>,</code>readFragment`, etc. on it.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

  
<div>
    
  <div>

  




  
<div id="issuecomment-309813616">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>is there a TLDR for a delete mutation?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>


  

    


    
<div>
    
  <div>

  




  
<div id="issuecomment-324906274">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>This issue has been automatically marked as stale becuase it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions to Apollo Client!</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-325228736">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I don't think this one should be closed yet <g-emoji>ðŸ™‚</g-emoji></p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    


    
<div>
    
  <div>

  




  
<div id="issuecomment-327952891">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I ended up doing something like this</p>
<div><pre>updateQueries: {
  userQuery: (prev, { mutationResult }) =&gt; {
    const newReservation = mutationResult.data.deleteReservation
    return {
      user: {
        ...prev.user,
        reservations: [
          ...prev.user.reservations.filter(
            r =&gt; r.id !== newReservation.id
          ),
        ],
      },
    }
  },
},</pre></div>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-329430791">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/n1ru4l" target="_blank">n1ru4l</a>
  

    </strong>

    commented

    <a href="#issuecomment-329430791" target="_blank"><relative-time>on Sep 14, 2017</relative-time></a>


    
      
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I thought about the ability to use directives in order to mark mutations. E.g. <code>@delete</code>. then the mutation would return either null or the Id of the object that should get deleted. In case of a mutation that deletes multiple items the mutation could return a list of IDs. We could then either implement this in Apollo or as a plugin, I did not check out Apollo 2 yet so I can not tell where it would fit in best.</p>
<p>Any suggestions or opinions on this approach? <g-emoji>ðŸ˜Š</g-emoji></p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    


    
<div>
    
  <div>

  




  
<div id="issuecomment-335509294">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I think this is a few things.</p>
<ol>
<li>Improving the docs to outline how to do this</li>
<li>Implementing some level of cache invalidation mechanism to support the core client to intelligently update</li>
</ol>
<p>Anyone want to take as stab at number one? I'd be happy to help!</p>
<p>We are actively working on number 2!</p>
<p>Keeping this issue open until the docs are at least improved here.</p>
<p><a href="https://github.com/peggyrayzis" target="_blank">@peggyrayzis</a> I think this should be an entire section on the new docs</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-335742239">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/jbaxleyiii" target="_blank">@jbaxleyiii</a> Is there any vision from the Apollo team on how to approach this?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-338113257">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Certainly performing a mutation and then expecting that to be able to correctly update all active queries is ...ambitious.</p>
<p>I'm not sure how many cases it works for, but I think using soft deletes might be a solution for some people.</p>
<p>Imagine a user:</p>
<pre><code>{
   id: 123,
   name: "John Doe",
   email: "john@doe.com",
}
</code></pre>
<p>and maybe a message</p>
<pre><code>{
  id: 456,
  text: "a witty comment",
  author {
    id: 123
    ...
   }
}
</code></pre>
<p>Then John Doe wants to delete his account so return a mutation with a result e.g.</p>
<pre><code>{
   id: 123,
   name: "[deleted]",
   email: null,
   deleted: true
}
</code></pre>
<p>Then it's up to components displaying users to decide if they want to check if <code>deleted</code> is set or not. For instance the posts in a forum may remain with the user name set to [deleted], but sending a private message would not be allowed.</p>
<p>This problem is not limited to deletes, imagine an insert which affects the results of many queries as well.</p>
<p>If you are using react and find yourself in the situation where you are performing a mutation and you know that this is going to possibly affect a number of active queries, on many components, then you may decide to move the network level fetching out of the HOC wrapping your components to somewhere else, and have your HOC have a fetchPolicy of 'cache-only'.</p>
<p>In this case you need to perform the fetching logic somewhere else, good candidates for this are redux-observable or redux-saga.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-342874899">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/jonmanzo" target="_blank">jonmanzo</a>
  

    </strong>

    commented

    <a href="#issuecomment-342874899" target="_blank"><relative-time>on Nov 9, 2017</relative-time></a>


    
      
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>This is how I handled the use case of removing an obj from multiple caches and unshifting it onto multiple other caches.</p>
<p>the mutation...</p>
<div><pre>import {
  mutationErrorHandler,
  mutationSuccessHandler,
  unshiftItemToQuery,
  removeFromRouteBasedStatusQuery
} from "../../util/mutationHelpers";

const self = "estimateItem";
const selfStatus = "estimated";

const wasSuccessful = mutationResult =&gt; {
  const status = mutationResult.data[self].status);
  return status === selfStatus;
};

export const ESTIMATE_ITEM_MUTATION = graphql(ESTIMATE_ITEM_GQL, {
  props: ({ mutate, ownProps }) =&gt; ({
    estimateItem: variables =&gt; {
      return mutate({
        variables,
        updateQueries: {
          Item: (prev, { mutationResult }) =&gt; {
            if (prev.item.id && prev.item.id !== mutationResult.data[self].id)
              return prev;
            return update(prev, {
              item: {
                status: { $set: mutationResult.data[self].status },
                estimated_at: { $set: mutationResult.data[self].estimated_at },
                estimated: { $set: mutationResult.data[self].estimated },
                last_updated: { $set: mutationResult.data[self].last_updated }
              }
            });
          },
          EmployeeItems: (prev, data) =&gt;
            removeFromRouteBasedStatusQuery(
              prev,
              data,
              "EmployeeItems",
              wasSuccessful,
              variables,
              ownProps
            ),
          QueueItems: (prev, data) =&gt;
            removeFromRouteBasedStatusQuery(
              prev,
              data,
              "QueueItems",
              wasSuccessful,
              variables,
              ownProps
            ),
          AllItems: (prev, data) =&gt;
            removeFromRouteBasedStatusQuery(
              prev,
              data,
              "AllItems",
              wasSuccessful,
              variables,
              ownProps
            )
        },
        update: (proxy, mutationResult) =&gt; {
          // Employee Items
          unshiftItemToQuery(proxy, {
            mutationResult,
            query: EMPLOYEE_ITEMS_QUERY,
            variables: rootQueryVariables("myItems", {
              employee_id: variables.employee_id || ownProps.employee_id
            }),
            ownProps,
            which: "myItems",
            self
          });

          // All Items
          unshiftItemToQuery(proxy, {
            mutationResult,
            query: ALL_ITEMS_QUERY,
            variables: rootQueryVariables("allItems"),
            ownProps,
            which: "allItems",
            self
          });
        }
      }).then(
        mutationResult =&gt;
          mutationSuccessHandler(
            mutationResult,
            wasSuccessful,
            "Item Estimated",
            ownProps
          ),
        mutationErrorHandler
      );
    }
  })
});</pre></div>
<p>Used in Update Queries...</p>
<div><pre>export const removeItemFromItemsList = (
  previousResult,
  mutationResult,
  objId
) =&gt; {
  if (!previousResult) {
    console.log("no previous query result");
    return;
  }
  const index = _.findIndex(previousResult.items.data, v =&gt; v.id === objId);
  if (index &lt; 0) {
    console.log("item not found in previous query result");
    return;
  }

  return update(previousResult, {
    items: {
      data: { $splice: [[index, 1]] }
    }
  });
};

export const removeFromRouteBasedStatusQuery = (
  prev,
  data,
  opName,
  wasSuccessful,
  variables,
  ownProps
) =&gt; {
  const { mutationResult, queryName } = data;
  if (
    !ownProps.isRouteBasedQuery ||
    ownProps.routeBasedQueryType !== "status" ||
    !wasSuccessful(mutationResult) ||
    queryName !== opName
  ) {
    return prev;
  }
  return removeItemFromItemsList(prev, mutationResult, variables.id);
};</pre></div>
<p>Used in update</p>
<div><pre>export const unshiftItemToQuery = (
  proxy,
  { mutationResult, query, variables = {}, ownProps, which, self }
) =&gt; {
  try {
    /**
     * Do not unshift on the currently viewed query, it will get updated, in place by default Apollo Behavior
     */
    if (ownProps.currentRoute === which) {
      return;
    }

    /**
     * Stop writes to EmployeeQuery if it is not this users item
     */
    if (which === "myItems") {
      if (skipMyItemsUpdate({ variables, ownProps })) return;

      // Add this to account for mutation updates that do not provide employee_variables
      if (!variables.employee_id)
        variables.employee_id = ownProps.employee_id;
    }

    const result = mutationResult.data[self];

    if (!result) {
      console.log(`Could not get data.${self} result from %o`, mutationResult);
      return;
    }

    const data = proxy.readQuery({ query, variables });

    if (!data) {
      console.log(
        `Could not find ${which} query to update for ${self} mutation`,
        query,
        variables
      );
      return;
    }

    // If this item exists previously, splice it out
    const existingIndex = _.findIndex(data.items.data, { id: result.id });

    let existing = {};

    if (existingIndex &gt; -1) {
      existing = data.items.data[existingIndex];
      data.items.data.splice(existingIndex, 1);
    }

    data.items.data.unshift({ ...existing, ...result });

    proxy.writeQuery({ query, variables, data });
  } catch (e) {
    console.error(
      `Could not add %o to ${which} query from ${self} mutation`,
      mutationResult
    );
    console.trace(e);
  }
};</pre></div>
<p>I have a removeItemFromQuery helper which is nearly identical to unshiftItemToQuery.  Created the helpers and use the "self" const etc. as we have (right now) 20+ mutations this can run on and duplicating this in every mutation was a logistical nightmare.  The removals that are happening in the updateQueries call now can (and will) be moved into update and handled the same way... If you're doing infinite scroll or any type of query pagination, connections are a must!</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-348876441">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>On our backend, we decided to have a state on our record of <code>active</code>.</p>
<p>We then had some middleware on our backend that, if inactive, we nullified all values (alternatively, you could hard delete the values in the db).</p>
<p>Finally, on our frontend, we then filtered by status of <code>active</code> or disabled a view based on that status.</p>
<p>We didn't want to manually handle the Apollo state in our app so this was our workaround solution.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-358209279">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I finally found a solution for my case with multiple queries. There is a race condition when using <code>refetchQueries</code> and <code>updateQuery</code> in a mutation . Seems like <code>updateQuery</code> removing the object form the Apollo store needs to be called before <code>refetchQueries</code>.</p>
<p>In my case the I have many different queries (sorting/filtering) objects.</p>
<ul>
<li><code>latestSongs</code></li>
<li><code>featuredSongs</code></li>
<li><code>mostViewedSongs</code></li>
<li><code>mostRemixedSongs</code></li>
<li>...  and more... generals and specifics per user</li>
</ul>
<p>The user can access the detail view of an object from any list to remove an object using a mutation. When the object is deleted from database I need to update the detail view to redirect out and also the query results for each list which could contain that object.</p>
<p>I don't want to remove the object manually from each list with <code>update</code> or <code>updateQueries</code> or reset the whole store so my option is to use <code>refetchQueries</code> to get the new lists and <code>updateQuery</code> to remove the object reference from the Apollo store:</p>
<ul>
<li><code>refetchQueries</code> <strong>doesn't work</strong> the queries are refetched and the lists returned don't have the removed object but Apollo still grab the data from the store and shows the removed object in the lists</li>
<li><code>updateQuery</code>  <strong>doesn't work</strong> the query <code>Song:id</code> is updated but Apollo doesn't understand that this reference <code>Song:id</code> is in the other queries (the lists)</li>
</ul>
<p>If I wait for the server response to remove the object reference from the store the queries are refetched but the UI still shows the removed object in the lists.<br />
Updating the object reference after the mutation promise is resolved <strong>doesn't work</strong>:</p>
<pre><code>    removeSongMutation({id})
       .then(() =&gt; updateQuery(() =&gt; ({ song: null })))
</code></pre>
<p>Updating the object reference before <code>refetchQueries</code> <strong>works</strong></p>
<pre><code>    updateQuery(() =&gt; ({ song: null })
    removeSongMutation({id})
</code></pre>
<p>The UI is updated correctly with the data from the lists refetched (not from the store). This is a kind of optimistic response because I'm updating the reference in the store before the object is removed from database.</p>
<pre><code>"apollo-client": "^2.0.4",
"react-apollo": "^2.0.4",
</code></pre>
<p>Hope this helps</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-365644015">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>We tried a different way by making use of a query's <code>fetchPolicy</code>.</p>
<p><strong>Goals</strong></p>
<ul>
<li>reduce complexity of <code>refetchQueries</code> by refetching only the currently displayed query(s). In other words only what is currently visible on the page. Queries do not re-fetch at mutation time unless their data is visible to the user. A "dirty" query however refetches from the network on next invocation.</li>
<li>reduce the complexity of tracking all queries that need to be re-fetched. Each query should know at fetch time if it needs to re-fetch from the server or it can just hit the cache (although a mutation still needs to know the name of each query that it will impact).</li>
</ul>
<p><strong>Brief explanation</strong></p>
<p>We have a <code>booksQuery</code> that feeds an infinite scroll of <code>Book</code>s. At the same time it can be filtered by the user with various arguments. So invalidating and re-fetching ALL the query / filter combinations can get really expensive.</p>
<p>We looked at a query's <code>fetchPolicy</code> and switching it dynamically between <code>cache-first</code> and <code>network-only</code>. This way we can force a query to refetch from the server if it is <em>dirty</em>.</p>
<p>To achieve this we need a <code>queryCache</code> where to track each query by name and the input filters that it has already fetched. Every time a query runs it gets its <code>fetchPolicy</code> from the <code>queryCache</code>. (we're using typescript but it works just the same in ES6 without the typings).</p>
<p>The sequence is as follows:</p>
<ul>
<li>mutation: invalidate all related queries (by name) on the <code>queryCache</code></li>
<li>query: next time the query runs it gets its <code>fetchPolicy: "network-only"</code> from the <code>queryCache</code></li>
<li>on query completion: clean the <code>queryCache</code> for the query to prevent it from going to the network on every subsequent invocation. This causes the <code>queryCache</code> to return <code>fetchPolicy:"cache-first"</code> on subsequent calls.</li>
</ul>
<p><strong>Example</strong></p>
<p>Connected component query:</p>
<div><pre>const BookFeedContainer = graphql(
   BookQueries.bookFeed,
   {
      options: (props: IOwnProps) =&gt; {
         const bookFilter: InputBookFilter = props.bookFilter;
         
         // BookQueries is a namespace under which we host all 
         // BookQuery graphql related info (fragments, queries, mutations, types etc)
         const queryName = BookQueries.names.bookFeed;
         const inputKey = InputBookFilter.toKey(bookFilter);
         
         // every time the query runs its fetch policy is determined by the queryCache
         const fetchPolicy = queryCache.getFetchPolicy(queryName, inputKey);

         return ({
           variables: {
             bookFilter: props.bookFilter,
           },
           fetchPolicy,
         });
      },
   }
)(BookFeed);</pre></div>
<p>Somewhere else in the app a mutation occurs:</p>
<div><pre>handleClickDeleteBook = () =&gt; {
    this.props.deleteBook()
      .then((result: any) =&gt; {
        // invalidate (refetch) all related queries if the deletion succeeds
        // this causes the queryCache to provide a "network-only" fetchPolicy
        // the next time the bookFeed query runs
        // NOTE that this does NOT cause the query to be invoked right away
        // if you need the query update to run immediately you must still call updateQueries
        // we do that on queries that are visible on the page
        queryCache.refetch([BookQueries.names.bookFeed]);

        // ... rest of code
      })
      .catch(err =&gt; {
        console.error(getGraphQLErrorMessage(err));
  }</pre></div>
<p>Query cleanup - most likely in <code>componentWillReceiveProps(nextProps)</code> once the query has finished executing</p>
<div><pre>queryCache.clean(BookQueries.names.bookFeed);</pre></div>
<p><strong>Query Filtering</strong></p>
<p>Each query has a list of input ids (inputKey in our case) keyed in on the query cache by query name:</p>
<div><pre>queryCache = {
  [queryName:string]: Array&lt;inputKey:string&gt;
}</pre></div>
<p>If an input filter's key is in the query's cached list then the query / inputFilter combination is "clean" and can be fetched from the cache (with fallback to network = default apollo config). If the input filter's key is NOT in the list or the list is missing from the cache then the query / filter combination is dirty and it must be fetched from the network. <code>fetchPolicy: network-only</code>.</p>
<p>This design allows to mark all query / filter combinations as dirty (either on a delete or add op) by just deleting the query's list of input keys (note that I do not need to know all the filter keys that the user might have accessed):</p>
<div><pre>import queryCache from "query-cache"; // this is a singleton

const queryName1 = "BookQueries_bookFeed"
const queryName2 = "SomeOtherRelatedQuery_name"

// this invalidates each queryName's list on the cache thus forcing 
// ALL combinations of each query to be refetched from the network on next call
queryCache.refetch([queryName1, queryName2]); </pre></div>
<p>Then when executing the query I can retrieve the fetch policy directly from the queryCache:</p>
<div><pre>const fetchPolicy1 = queryCache.getFetchPolicy(queryName1, inputKey); // cache-first or network-only

// or without filtering
const fetchPolicy2 = queryCache.getFetchPolicy(queryName2); </pre></div>
<p><strong>Detailed code</strong></p>
<p>queryCache.ts:</p>
<div><pre>/**
 * Hash map to keep track of all queries executed so far. Each query
 * can have multiple input filters. When the query is invalidated (isDirty)
 * then the cache policy defaults to "network-only". Else it's "cache-first".
 * Each time an input is fetched its key is placed into the inputKeys list
 * for the specific query. Remove its key from the list to force it to be
 * loaded from the network the next time
 */
class QueryCache {
  private cache = {};

  /**
   * Each query has a list keyed in by the query name. The list contains
   * the keys for all the inputs that have been previously fetched
   * and are "clean" (they can be safely retrieved from the cache). If an
   * input's key is not in the list then it must be refetched from the network.
   * If the list is missing from the caceh then any variation of the query
   * (or a query without input params) must be refetched from the network.
   *
   * @param {string} queryName - The graphql name of the query being targeted.
   */
  private getQueryList = (queryName: string) =&gt; this.cache[queryName];

  /**
   * Checks whether a specific input key for a given query should be
   * re-fetched. Only inputs that are already in the inputKeys are "clean".
   *
   * @param {string} queryName - graphql name of the query being targeted.
   * @param {string | undefined} inputKey - key uniquely identifying
   * the query's input parameters.
   */
  private isDirty = (queryName: string, inputKey?: string) =&gt; {
    const queryList = this.getQueryList(queryName);
    // if no query list on the cache then query is dirty
    // re-fetch from the network
    if (!queryList) {
      return true;
    }
    return inputKey ? this.getQueryList(queryName).indexOf(inputKey) &lt; 0 : false;
  };

  /**
   * Invalidates the query's entire input list. All versions of the query regardless
   * of input will be re-fetched from the network.
   *
   * @param {Array&lt;string&gt;} queryNames - list of names for all queries that should
   * be re-fetched from the network on the next call.
   */
  refetch = (queryNames: Array&lt;string&gt; = []) =&gt; {
    queryNames.forEach((name) =&gt; { delete this.cache[name] });
  }

  /**
   * Releases this query / filter(s) combination from fetch network-only constraints.
   *
   * @param {string} queryName - graphql name of the query being released
   * from network-only constraints.
   * @param {string | undefined } inputKey - key uniquely identifying
   * the query's input parameters.
   */
  clean = (queryName: string, inputKey?: string) =&gt; {
    const queryList = this.getQueryList(queryName) || [];
    queryList.push(inputKey);
    if (!this.cache[queryName]) {
      this.cache[queryName] = queryList;
    }
  }

  /**
   * Provide the appropriate fetch policy according to the cache's status.
   *
   * @param {string} queryName - graphql name of the query for which the
   * fetch policy is being retrieved.
   * @param {string | undefined } inputKey - key uniquely identifying
   * the query's input parameters.
   */
  getFetchPolicy = (queryName: string, inputKey?: string) =&gt; (
    this.isDirty(queryName, inputKey) ? "network-only" : "cache-first"
  )
}

const queryCache = new QueryCache();
export default queryCache; // singleton</pre></div>
<p>bookQueries.ts (simplified - in reality we use typescript namespaces):</p>
<div><pre>export const BookQueries = {
    bookFeed: gql`
      query BookQueries_bookFeed($bookFilter: InputBookFilter!, $cursor:String){
        bookFeed(bookFilter:$bookFilter, cursor:$cursor)
        @connection(key: "bookFeed", filter:["bookFilter"]) {
          list {
            id
          }
          cursor
          hasNext
        }
      }
    `,
    names: {
      bookFeed: "BookQueries_bookFeed",
    }
  };</pre></div>
<p>InputBookFilter.ts (also simplified):</p>
<div><pre>export default class InputBookFilter {
   private privacy: boolean

   constructor(privacy:string = "private"){
     this.privacy = privacy;
   }

   /**
    * All this has to do is provide a unique key given the input parameters.
    */
   static toKey = (filter: InputBookFilter) =&gt; `inputBookFilter_${filter.privacy}`;
}</pre></div>
<p>We haven't yet explored all the edge cases but on the first immediate try this works really well for us.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-367926545">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/maierson" target="_blank">@maierson</a> thanks for sharing your approach, it did sound very intriguing, just wondering have you discovered any drawbacks or hard-to-handle edge cases later?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-367996106">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/coodoo" target="_blank">@coodoo</a> so far it works really well for us. If I run into anything meaningful I'll make sure to update this thread.</p>
<p>The next challenge I see is how to handle a delete / creation in a list where a user has already downloaded a very long list of (paged) items. Do we re-fetch the entire list or just part of it based on some form of cursor data?</p>
<p>For deletes: this is where I feel it would be useful to be able to evict an item from the apollo cache and have all queries containing it update locally to reflect the removal. Having some experience with writing a client side cache I am aware of the complexities and risks of inconsistency that this can introduce in the data. However it's a very high value add if implemented properly.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-369972132">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/canercandan" target="_blank">canercandan</a>
  

    </strong>

    commented

    <a href="#issuecomment-369972132" target="_blank"><relative-time>on Mar 3</relative-time></a>


    
      <include-fragment>
            
  â€¢


  
    <summary>
      <div>
        
            edited
        
        
      </div>
    </summary>
    
  

      </include-fragment>
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>In prisma they support the <a href="https://www.prismagraphql.com/docs/reference/prisma-api/concepts-utee3eiquo#transactional-mutations" target="_blank">transactional mutations</a> concept, basically cascading deletes with the directive (<code>@relation(â€¦, onDelete: CASCADE)</code>).</p>
<p>Maybe apollo should retrieve those logics and apply those rules for the cache so whenever a node is deleted from the cache (using <code>options.update()</code>, its relations based on those transactional rules will be deleted as well.</p>
<p>Obviously this could only work with Prisma in the first place, but it can open a chapter to support other backend framework and database (at the end Prisma uses MySQL and cascading deletes is nothing unfamiliar for most of the DB engines)</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    


    
<div>
    
  <div>

  




  
<div id="issuecomment-405749674">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <blockquote>
<p>The store is only going to save the user as one item in the cache so even if multiple queries are returning the user, it should only need to be removed once.</p>
</blockquote>
<p>This is actually not true.  If there are multiple queries, with different parameters, that return a list of items, each one will have a different list of result item IDs in the cache, because the client has no way of knowing which items are included for a given set of parameters.  This is why updates to fields within those items magically work but deletes don't, because the id of the deleted item has to be removed from each of those lists.</p>
<p>But if Apollo merely provided a way to Mark a given typename/id pair as invalidated, it could automatically refetches any queries including that item in their result set.</p>
<p>I have started using helper functions to look through <code>apolloClient.queryManager.queries</code>, checking if a given field is present in the GraphQL <code>selectionSet</code> and if so, refetches the query.  But since these are only active queries, I have to use <code>cache-and-network</code> to ensure that any unmounted components refetch the latest data when they remount.</p>
<p>Next I plan to fetch enough type metadata from the backend to be able to scan all levels of the active queries for the deleted item and refetch any that contain it.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-405820587">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I just made a library to magically refetch all relevant active queries after creates and deletes!  It still has some limitations I need to work through, <del>and I need to add some optimizations</del>, but check it out:<br />
<a href="https://github.com/jcoreio/apollo-magic-refetch" target="_blank">https://github.com/jcoreio/apollo-magic-refetch</a></p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406088495">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I just realized that updating the cache after associating/dissociating objects can also be well served by <code>apollo-magic-refetch</code>, so I added some features and examples to support that case as well.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406138446">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/jedwards1211" target="_blank">@jedwards1211</a> this is a neat idea but would be very chatty and data intensive if there are a lot of updates. We have a chat app that has conversations and it receives messages via subscriptions, if it were to reload all the messages of a conversation every time a new message was added then it would use a lot of data for mobile users, and not be that responsive as it adds another network call when the data is already in the store.</p>
<p>We first solved this using redux-observable and keeping a <code>watchQuery</code> subscribed for each active conversation then updating the watchQuery when a relevant message came in via subscription.</p>
<p>A new approach we are trying is to use our own cache to replace 'apollo-cache-inmemory' which emits a stream of events when new data is written, or update, to the normalised cache. We then have <code>cacheWatchers</code> for queries which might care about the data, and they can update the cache via <code>readQuery()</code> and <code>writeQuery()</code>.</p>
<p>The goal is to have data changes automatically update relevant queries that are saved in the cache, without network fetching.</p>
<p>If anyone is interested in this I can share the code but it's at an early stage.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406150794">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/ravenscar" target="_blank">@ravenscar</a> Well I'm not saying you should use it for any and every use case, and obviously it doesn't make sense for that case.  If it doesn't seem useful for anything else in your app, then your app probably just has different needs than mine.</p>
<p>It sounds like you would agree with me that custom <code>update</code> logic belongs on the <code>Query</code> components more often than on the <code>Mutation</code> components, right?</p>
<p>I'm a bit confused how the custom cache approach works in your new message example.  When a new message arrives via subscription it gets written to the cache, and then a listener picks that up?<br />
And if a message were deleted, you would delete the <code>message:id</code> cache key and then listeners would pick that up and remove a reference to that key from their lists of results?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406151797">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>If I were to go full on in the opposite direction from refetching, I would probably just design a system to listen to all the relevant events for a given query on my database and send events to the client specific to each query telling it what to add/remove/change in its result set, rather that trying to write a lot of custom update logic on the client.  My data is very relational, so the number of update cases I would have to handle for each query would break my brain.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406152388">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><strong>What I really wish I could do is ask the <code>InMemoryCache</code> for all cached items of a given <code>__typename</code>, and then update them.</strong> If that were the case, when I delete an <code>Item</code>, I could just go through all <code>ItemConnections</code> in my cache and remove the edge for that <code>Item</code>.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406168366">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/ravenscar" target="_blank">@ravenscar</a> I should also clarify what I'm using the magic refetching for right now in my app: whenever a user creates or deletes an organization, another user, a user group, a device, a device group, etc. or changes associations between them.</p>
<p>These are infrequent operations so the extra refetching is a small price to pay for a strong guarantee of correct updates without handling numerous cases in custom <code>update</code> logic for each of these types in my schema.  Additionally, only one page of results shows onscreen at a time for lists of any of these types, so the amount of data to refetch is well bounded (in general it's good idea to avoid having an unbounded amount of data rendered into the DOM anyway).  In these cases the refetch approach really shines.</p>
<p>In frequent update cases like messages, you're still better off doing something custom.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406171257">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/jedwards1211" target="_blank">@jedwards1211</a> Hey I'm not saying what you've done is isn't useful - sorry if it came across that way! We did try this initially (refetching active queries) but for us it was too data heavy.</p>
<blockquote>
<p>It sounds like you would agree with me that custom update logic belongs on the Query components more often than on the Mutation components, right?</p>
</blockquote>
<p>I do agree that the logic belongs with the Query and not the Mutation - the update logic in the mutation is ass-backwards in my opinion.</p>
<p>It would be nice if apollo queries had something like reducers which worked on the updates that hit the store, but unfortunately that would probably require some kind of normalisation and I don't think this is a prerequisite for the store (even though that's exactly how it works).</p>
<blockquote>
<p>When a new message arrives via subscription it gets written to the cache, and then a listener picks that up?</p>
</blockquote>
<p>We have a way of detecting changes in the cache and it's exposed as an rxjs observable. This can be subscribed to by many observers which often manage the state of queries, and they add or remove the changed entity from collections.</p>
<p>If you use redux this is somewhat similar to a reducer where the state would be the result of the query and the actions would be the entity changes.</p>
<p>We use a CQRS paradigm not CRUD so it's a bit easier to detect changes, but I don't think that really matters too much.</p>
<blockquote>
<p>What I really wish I could do is ask the InMemoryCache for all cached items of a given __typename, and then update them.</p>
</blockquote>
<p>It would be really nice if <code>readFragment</code> supported this but I suppose it's near impossible unless you have a normalised cache. If you are using <code>apollo-cache-inmemory</code>, which uses a normalised cache, you could write your own version of it and add that functionality quite easily.</p>
<p>Basically roll your own cache like <a href="https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache-inmemory/src/objectCache.ts" target="_blank">this</a> and track __typenames</p>
<p>When you create the <code>InMemoryCache</code> instance supply a storeFactory in the config which produces your cache.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406319871">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I get that you're detecting changes to the cache, but what initial change do you make when an object gets deleted?  Do you set something to null?</p>
<p>Also if you have plans of making this a general purpose lib it might be better to use zen-observable since Apollo is using it, though that's just my opinion.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-406439825">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>If you want to delete it from the store you can call <code>delete()</code> with the object id. Of course you would have to have logic to remove it from all the collections as well - which is a pain.</p>
<p>By far the easiest approach for us has been to have a field on the object called "deleted" then when you delete an object just send it through as <code>deleted : true</code> and everything will update. You need to write your client side container components with this in mind though, so it's definitely no silver bullet.</p>
<p>This all falls into cache invalidation side of the <a href="https://martinfowler.com/bliki/TwoHardThings.html" target="_blank">two hard things</a> of computer science and it's seems really difficult (perhaps impossible?) to find a generalised solution. Certainly I haven't seen any solution people are actually happy with with respect to apollo's cache.</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    


    
<div>
    
  <div>

  




  
<div id="issuecomment-407987670">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Sorry to chime in so late - I've just run across the same issues as the rest of you.</p>
<p>Now, just to confirm for my own sanity - when deleting an object, you need to find every single reference of it in the client and remove them all manually?</p>
<p>Is that not kind of a huge step back from Redux + Normalizr? At least in that case all your entities are in the same place. Feels a bit like jQuery <g-emoji>ðŸ˜„</g-emoji></p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-408132310">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>Normalizr provides a way to automatically delete all references to an object without violating the types you've defined?<br />
I mean naively one could think that Apollo could just remove references from all lists.  But if you're using Relay Connections, the reference to an object is not inside a simple list, and an ancestor rather than the reference itself needs to be removed.<br />
Likewise if you have an object type Foo that has one required Bar, and its Bar gets deleted, what do you do?  You can't set its Bar reference to null, that would violate type expectations.  You could delete Foo, but then you've kinda got the same problem as before if anything references Foo...</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-408145024">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p><a href="https://github.com/MitchEff" target="_blank">@MitchEff</a> In normalizr gaearon recommends using a flag to indicate deleted: <a href="https://github.com/paularmstrong/normalizr/issues/21" target="_blank">paularmstrong/normalizr#21</a><br />
People have also been recommending that here for Apollo.<br />
How did you personally handle deletions in normalizr?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-408308965">
    
  <div>

    



    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>I did mine a kind of funny way, but takes advantage of the fact that every entity is just a key in your state. In my 'deleteEntity' action, I pass in type, entity and parentType. I can then go:</p>
<pre><code>let parent = clonedEntityState[parentType+'s'][entity[parentType+'_id'];

remove(parent[type+'s'], entityID =&gt; {
    return entityID === entity.id;
});
</code></pre>
<p>It's a bit simplified above, but you see what I mean. It's not perfect, but does 99% of the work in just a couple lines. I don't think you can achieve something quite as neat in GraphQL - you'd need to find every query that mentions the entity's parent and remove it manually, right?</p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
      <div>
        <h3 id="ref-issue-345314790">
      
        
      
        
  <a href="/hwillson" target="_blank">hwillson</a>
  

      referenced this issue
        in <strong>apollographql/apollo-feature-requests</strong>
      <a href="#ref-issue-345314790" target="_blank">
        <relative-time>7 days ago</relative-time>
      </a>
    </h3>

  
    
          
      Open
    



    
      <h4>
        <a href="/apollographql/apollo-feature-requests/issues/5" target="_blank">
          Best practice when a mutation deletes an object
          #5
        </a>
      </h4>
    

    


  

</div>


</div>

    
<div>
    
  <div>

  




  
<div id="issuecomment-408494195">
    
  <div>

    
<div>
  

    
    
      Contributor
    



  <h3>

    <strong>
      

  <a href="/hwillson" target="_blank">hwillson</a>
  

    </strong>

    commented

    <a href="#issuecomment-408494195" target="_blank"><relative-time>7 days ago</relative-time></a>


    
      
    
  </h3>
</div>


    <div>

      
<task-lists>
<table>
  <tbody>
    <tr>
      <td>

          <p>To help provide a more clear separation between feature requests / discussions and bugs, and to help clean up the feature request / discussion backlog, Apollo Client feature requests / discussions are now being managed under the <a href="https://github.com/apollographql/apollo-feature-requests" target="_blank">https://github.com/apollographql/apollo-feature-requests</a> repository.</p>
<p>This issue has been migrated to: <a href="https://github.com/apollographql/apollo-feature-requests/issues/5" target="_blank">apollographql/apollo-feature-requests#5</a></p>
      </td>
    </tr>
  </tbody>
</table>
</task-lists>


        



    </div>

  </div>
</div>


</div>

</div>

    
<div>
      

  

  <div>
  <h3 id="event-1757850147">

    
      
    

    

        
  <a href="/apollographql" target="_blank">apollographql</a>
  


        locked and limited conversation to collaborators


    <a href="#event-1757850147" target="_blank"><relative-time>7 days ago</relative-time></a>

  </h3>
</div>



</div>








        