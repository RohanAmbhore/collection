<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/?utm_source=mybridge&utm_medium=web&utm_campaign=read_more">http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/?utm_source=mybridge&utm_medium=web&utm_campaign=read_more</a><div id="articleHeader"><h1>2nd Edition – .ds laboratory</h1></div>
		

			
				

		
	
	
		<p>Read this article in: <a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition-rus/" target="_blank">Russian</a>, <a href="http://www.xiaojichao.com/post/jscorev2.html" target="_blank">Chinese</a>.</p>
<p>This is the <em>second edition</em> of the <a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank">JavaScript. The Core</a> overview lecture, devoted to ECMAScript programming language and core components of its runtime system.</p>
<p><strong>Audience:</strong> experienced programmers, experts.</p>
<p>The <a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank">first edition</a> of the article covers generic aspects of JS language, using abstractions mostly from the legacy ES3 spec, with some references to the appropriate changes in ES5 and ES6 (aka ES2015).</p>
<p>Starting since ES2015, the specification changed descriptions and structures of some core components, introduced new models, etc. And in this edition we focus on the newer abstractions, updated terminology, but still maintaining the very basic JS structures which stay consistent throughout the spec versions.</p>
<p>This article covers ES2017+ runtime system.</p>
<p>
<strong>Note:</strong> the latest version of the <a href="https://tc39.github.io/ecma262/" target="_blank">ECMAScript specification</a> can be found on the TC-39 website.
</p>
<p>We start our discussion with the concept of an <em>object</em>, which is fundamental to ECMAScript.</p>
<h2 id="object"><a href="#object" target="_blank">Object</a></h2>
<p>ECMAScript is an <em>object-oriented</em> programming language with the <em>prototype-based</em> organization, having the concept of an <em>object</em> as its core abstraction.</p>
<p>
  <b>Def. 1: Object:</b> An <em>object</em> is a <em>collection of properties</em>, and has a <em>single prototype object</em>. The prototype may be either an object or the <code>null</code> value.
</p>
<p>Let’s take a basic example of an object. A prototype of an object is referenced by the internal <code>[[Prototype]]</code> property, which to user-level code is exposed via the <code>__proto__</code> property.</p>
<p>For the code:</p>
<div><div id="highlighter_904270"><table><tbody><tr><td></td><td><div><div><code>let</code> <code>point = {</code></div><div><code>x: 10,</code></div><div><code>y: 20,</code></div><div><code>};</code></div></div></td></tr></tbody></table></div></div>
<p>we have the structure with two <em>explicit own properties</em> and one <em>implicit</em> <code>__proto__</code> property, which is the reference to the prototype of <code>point</code>:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/js-object.png"  alt="Figure 1. A basic object with a prototype." title="Figure 1. A basic object with a prototype." /></div></p>
<p>Figure 1. A basic object with a prototype.</p>
<p><strong>Note:</strong> objects may store also <em>symbols</em>. You can get more info on symbols in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank">this documentation</a>.</p>
<p>The prototype objects are used to implement <em>inheritance</em> with the mechanism of <em>dynamic dispatch</em>. Let’s consider the <em>prototype chain</em> concept to see this mechanism in detail.</p>
<h2 id="prototype"><a href="#prototype" target="_blank">Prototype</a></h2>
<p>Every object, when is created, receives its <em>prototype</em>. If the prototype is not set <em>explicitly</em>, objects receive <em>default prototype</em> as their <em>inheritance object</em>.</p>
<p>
  <b>Def. 2: Prototype:</b> A <em>prototype</em> is a delegation object used to implement <em>prototype-based inheritance</em>.
</p>
<p>The prototype can be set <em>explicitly</em> via either the <code>__proto__</code> property, or <code>Object.create</code> method:</p>
<div><div id="highlighter_195231"><table><tbody><tr><td></td><td><div><div><code>// Base object.</code></div><div><code>let</code> <code>point = {</code></div><div><code>x: 10,</code></div><div><code>y: 20,</code></div><div><code>};</code></div><div><code>// Inherit from `point` object.</code></div><div><code>let</code> <code>point3D = {</code></div><div><code>z: 30,</code></div><div><code>__proto__: point,</code></div><div><code>};</code></div><div><code>console.log(</code></div><div><code>point3D.x, </code><code>// 10, inherited</code></div><div><code>point3D.y, </code><code>// 20, inherited</code></div><div><code>point3D.z  </code><code>// 30, own</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p><strong>Note:</strong> by default objects receive <code>Object.prototype</code> as their inheritance object.</p>
<p>Any object can be used as a prototype of another object, and the prototype itself can have its own prototype. If a prototype has a non-null reference to its prototype, and so on, it is called the <em>prototype chain</em>.</p>
<p>
  <b>Def. 3: Prototype chain:</b> A <em>prototype chain</em> is a <em>finite</em> chain of objects used to implement <em>inheritance</em> and <em>shared properties</em>.
</p>
<p><img src="/wp-content/uploads/2017/11/prototype-chain.png" width="600" alt="Figure 2. A prototype chain." title="Figure 2. A prototype chain." /></p>
<p>Figure 2. A prototype chain.</p>
<p>The rule is very simple: if a property is not found in the object itself, there is an attempt to <em>resolve</em> it in the prototype; in the prototype of the prototype, etc. — until the whole prototype chain is considered.</p>
<p>Technically this mechanism is known as <em>dynamic dispatch</em> or <em>delegation</em>.</p>
<p>
  <b>Def. 4: Delegation:</b> a mechanism used to resolve a property in the inheritance chain. The process happens at runtime, hence is also called <strong><em>dynamic dispatch</em></strong>.
</p>
<p><strong>Note:</strong> in contrast with <em>static dispatch</em> when references are resolved at <em>compile time</em>, <em>dynamic dispatch</em> resolves the references at <em>runtime</em>.</p>
<p>And if a property eventually is not found in the prototype chain, the <code>undefined</code> value is returned:</p>
<div><div id="highlighter_611822"><table><tbody><tr><td></td><td><div><div><code>// An "empty" object.</code></div><div><code>let</code> <code>empty = {};</code></div><div><code>console.log(</code></div><div><code>// function, from default prototype</code></div><div><code>empty.toString,</code></div><div><code>// undefined</code></div><div><code>empty.x,</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>As we can see, a default object is actually <em>never empty</em> — it always inherits <em>something</em> from the <code>Object.prototype</code>. To create a <em>prototype-less dictionary</em>, we have to explicitly set its prototype to <code>null</code>:</p>
<div><div id="highlighter_914450"><table><tbody><tr><td></td><td><div><div><code>// Doesn't inherit from anything.</code></div><div><code>let</code> <code>dict = Object.create(</code><code>null</code><code>);</code></div><div><code>console.log(dict.toString); </code><code>// undefined</code></div></div></td></tr></tbody></table></div></div>
<p>The <em>dynamic dispatch</em> mechanism allows <em>full mutability</em> of the inheritance chain, providing an ability to change the delegation object:</p>
<div><div id="highlighter_997109"><table><tbody><tr><td></td><td><div><div><code>let</code> <code>protoA = {x: 10};</code></div><div><code>let</code> <code>protoB = {x: 20};</code></div><div><code>// Same as `let objectC = {__proto__: protoA};`:</code></div><div><code>let</code> <code>objectC = Object.create(protoA);</code></div><div><code>console.log(objectC.x); </code><code>// 10</code></div><div><code>// Change the delegate:</code></div><div><code>Object.setPrototypeOf(objectC, protoB);</code></div><div><code>console.log(objectC.x); </code><code>// 20</code></div></div></td></tr></tbody></table></div></div>
<p><strong>Note:</strong> even though the <code>__proto__</code> property is standardized today, and is easier to use for explanations, on practice prefer using API methods for prototype manipulations, such as <code>Object.create</code>, <code>Object.getPrototypeOf</code>,<br />
 <code>Object.setPrototypeOf</code>, and similar on the <code>Reflect</code> module.</p>
<p>On the example of <code>Object.prototype</code>, we see that the <em>same prototype</em> can be shared across <em>multiple objects</em>. On this principle the <em>class-based inheritance</em> is implemented in ECMAScript. Let’s see the example, and look under the hood of the “class” abstraction in JS.</p>
<h2 id="class"><a href="#class" target="_blank">Class</a></h2>
<p>When several objects share the same initial state and behavior, they form a <em>classification</em>.</p>
<p>
  <b>Def. 5: Class:</b> A <em>class</em> is a formal abstract set which specifies initial state and behavior of its objects.
</p>
<p>In case we need to have <em>multiple objects</em> inheriting from the same prototype, we could of course create this one prototype, and explicitly inherit it from the newly created objects:</p>
<div><div id="highlighter_914635"><table><tbody><tr><td></td><td><div><div><code>// Generic prototype for all letters.</code></div><div><code>let</code> <code>letter = {</code></div><div><code>getNumber() {</code></div><div><code>return</code> <code>this</code><code>.number;</code></div><div><code>}</code></div><div><code>};</code></div><div><code>let</code> <code>a = {number: 1, __proto__: letter};</code></div><div><code>let</code> <code>b = {number: 2, __proto__: letter};</code></div><div><code>// ...</code></div><div><code>let</code> <code>z = {number: 26, __proto__: letter};</code></div><div><code>console.log(</code></div><div><code>a.getNumber(), </code><code>// 1</code></div><div><code>b.getNumber(), </code><code>// 2</code></div><div><code>z.getNumber(), </code><code>// 26</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>We can see these relationships on the following figure:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/shared-prototype.png"  alt="Figure 3. A shared prototype." title="Figure 3. A shared prototype." /></div></p>
<p>Figure 3. A shared prototype.</p>
<p>However, this is obviously <em>cumbersome</em>. And the class abstraction serves exactly this purpose — being a <em>syntactic sugar</em> (i.e. a construct which <em>semantically does the same</em>, but in a much <em>nicer syntactic form</em>), it allows creating such multiple objects with the convenient pattern:</p>
<div><div id="highlighter_659061"><table><tbody><tr><td></td><td><div><div><code>class</code> <code>Letter {</code></div><div><code>constructor(number) {</code></div><div><code>this</code><code>.number = number;</code></div><div><code>}</code></div><div><code>getNumber() {</code></div><div><code>return</code> <code>this</code><code>.number;</code></div><div><code>}</code></div><div><code>}</code></div><div><code>let</code> <code>a = </code><code>new</code> <code>Letter(1);</code></div><div><code>let</code> <code>b = </code><code>new</code> <code>Letter(2);</code></div><div><code>// ...</code></div><div><code>let</code> <code>z = </code><code>new</code> <code>Letter(26);</code></div><div><code>console.log(</code></div><div><code>a.getNumber(), </code><code>// 1</code></div><div><code>b.getNumber(), </code><code>// 2</code></div><div><code>z.getNumber(), </code><code>// 26</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p><strong>Note:</strong> <em>class-based inheritance</em> in ECMAScript is implemented on top of the <em>prototype-based delegation</em>.</p>
<p><strong>Note:</strong> a <em>“class”</em> is just a <em>theoretical abstraction</em>. Technically it can be implemented with the <em>static dispatch</em> as in Java or C++, or <em>dynamic dispatch (delegation)</em> as in JavaScript, Python, Ruby, etc.</p>
<p>Technically a “class” is represented as a <em>“constructor function + prototype”</em> pair. Thus, a constructor function <em>creates objects</em>, and also <em>automatically</em> sets the <em>prototype</em> for its newly created instances. This prototype is stored in the <code>&lt;ConstructorFunction&gt;.prototype</code> property. </p>
<p>
  <b>Def. 6: Constructor:</b> A <em>constructor</em> is a function which is used to create instances, and automatically set their prototype.
</p>
<p>It is possible to use a constructor function explicitly. Moreover, before the class abstraction was introduced, JS developers used to do so not having a better alternative (we can still find a lot of such legacy code allover the internets):</p>
<div><div id="highlighter_763319"><table><tbody><tr><td></td><td><div><div><code>function</code> <code>Letter(number) {</code></div><div><code>this</code><code>.number = number;</code></div><div><code>}</code></div><div><code>Letter.prototype.getNumber = </code><code>function</code><code>() {</code></div><div><code>return</code> <code>this</code><code>.number;</code></div><div><code>};</code></div><div><code>let</code> <code>a = </code><code>new</code> <code>Letter(1);</code></div><div><code>let</code> <code>b = </code><code>new</code> <code>Letter(2);</code></div><div><code>// ...</code></div><div><code>let</code> <code>z = </code><code>new</code> <code>Letter(26);</code></div><div><code>console.log(</code></div><div><code>a.getNumber(), </code><code>// 1</code></div><div><code>b.getNumber(), </code><code>// 2</code></div><div><code>z.getNumber(), </code><code>// 26</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>And while creating a single-level constructor was pretty easy, the inheritance pattern from parent classes required much more boilerplate. Currently this boilerplate is hidden as an <em>implementation detail</em>, and that exactly what happens under the hood when we create a class in JavaScript.</p>
<p><strong>Note:</strong> <em>constructor functions</em> are just <em>implementation details</em> of the class-based inheritance.</p>
<p>Let’s see the relationships of the objects and their class:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/js-constructor.png" alt="Figure 4. A constructor and objects relationship." title="Figure 4. A constructor and objects relationship." /></div></p>
<p>Figure 4. A constructor and objects relationship.</p>
<p>The figure above shows that <em>every object</em> has an associated prototype. Even the constructor function (class) <code>Letter</code> has its own prototype, which is <code>Function.prototype</code>. Notice, that <code>Letter.prototype</code> is the prototype of the Letter <em>instances</em>, that is <code>a</code>, <code>b</code>, and <code>z</code>.</p>
<p><strong>Note:</strong> the <em>actual</em> prototype of <em>any</em> object is <em>always</em> the <code>__proto__</code> reference. And the explicit <code>prototype</code> property on the constructor function is just a reference to the prototype of its <em>instances</em>; from instances it’s still referred by the <code>__proto__</code>. See details <a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/#explicit-codeprototypecode-and-implicit-codeprototypecode-properties" target="_blank">here</a>.</p>
<p>You can find a detailed discussion on generic OPP concepts (including detailed descriptions of the class-based, prototype-based, etc) in the <a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/" target="_blank">ES3. 7.1 OOP: The general theory</a> article.</p>
<p>Now when we understand the basic relationships between ECMAScript objects, let’s take a deeper look at JS <em>runtime system</em>. As we will see, almost everything there can also be presented as an object.</p>
<h2 id="execution-context"><a href="#execution-context" target="_blank">Execution context</a></h2>
<p>To execute JS code and track its runtime evaluation, ECMAScript spec defines the concept of an <em>execution context</em>. Logically execution contexts are maintained using a <em>stack</em> (the <em>execution context stack</em> as we will see shortly), which corresponds to the generic concept of a <em>call-stack</em>.</p>
<p>
  <b>Def. 7: Execution context:</b> An <em>execution context</em> is a specification device that is used to track the runtime evaluation of the code.
</p>
<p>There are several types of ECMAScript code: the <em>global code</em>, <em>function code</em>, <em><code>eval</code> code</em>, and <em>module code</em>; each code is evaluated in its execution context. Different code types, and their appropriate objects may affect the structure of an execution context: for example, <em>generator functions</em> save their <em>generator object</em> on the context.</p>
<p>Let’s consider a recursive function call:</p>
<div><div id="highlighter_160816"><table><tbody><tr><td></td><td><div><div><code>function</code> <code>recursive(flag) {</code></div><div><code>// Exit condition.</code></div><div><code>if</code> <code>(flag === 2) {</code></div><div><code>return</code><code>;</code></div><div><code>}</code></div><div><code>// Call recursively.</code></div><div><code>recursive(++flag);</code></div><div><code>}</code></div><div><code>// Go.</code></div><div><code>recursive(0);</code></div></div></td></tr></tbody></table></div></div>
<p>When a function is called, a <em>new execution context</em> is created, and <em>pushed</em> onto the stack — at this point it becomes <em>an active execution context</em>. When a function returns, its context is <em>popped</em> from the stack.</p>
<p>A context which calls another context is called a <em>caller</em>. And a context which is being called, accordingly, is a <em>callee</em>. In our example the <code>recursive</code> function plays both roles: of a callee and a caller — when calls itself recursively.</p>
<p>
  <b>Def. 8: Execution context stack:</b> An <em>execution context stack</em> is a LIFO structure used to maintain control flow and order of execution.
</p>
<p>For our example from above we have the following stack <em>“push-pop”</em> modifications:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/execution-stack.png" alt="Figure 5. An execution context stack." title="Figure 5. An execution context stack." /></div></p>
<p>Figure 5. An execution context stack.</p>
<p>As we can also see, the <em>global context</em> is always at the bottom of the stack, it is created prior execution of any other context.</p>
<p>You can find more details on execution contexts in the <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank">appropriate chapter</a>.</p>
<p>In general, the code of a context <em>runs to completion</em>, however as we mentioned above, some objects — such as <em>generators</em>, may violate LIFO order of the stack. A generator function may suspend its running context, and <em>remove</em> it from the stack <em>before completion</em>. Once a generator is activated again, its context is <em>resumed</em> and again is <em>pushed</em> onto the stack:</p>
<div><div id="highlighter_562079"><table><tbody><tr><td></td><td><div><div><code>function</code> <code>*gen() {</code></div><div><code>yield</code> <code>1;</code></div><div><code>return</code> <code>2;</code></div><div><code>}</code></div><div><code>let</code> <code>g = gen();</code></div><div><code>console.log(</code></div><div><code>g.next().value, </code><code>// 1</code></div><div><code>g.next().value, </code><code>// 2</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>The <code>yield</code> statement here returns the value to the caller, and pops the context. On the second <code>next</code> call, the <em>same context</em> is pushed again onto the stack, and is <em>resumed</em>. Such context may <em>outlive</em> the caller which creates it, hence the violation of the LIFO structure.</p>
<p><strong>Note:</strong> you can read more about generators and iterators in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank">this documentation</a>.</p>
<p>We shall now discuss the important components of an execution context; in particular we should see how ECMAScript runtime manages <em>variables storage</em>, and <em>scopes</em> created by nested blocks of a code. This is the generic concept of <em>lexical environments</em>, which is used in JS to store data, and solve the <em>“Funarg problem”</em> — with the mechanism of <em>closures</em>.</p>
<h2 id="environment"><a href="#environment" target="_blank">Environment</a></h2>
<p>Every execution context has an associated <em>lexical environment</em>.</p>
<p>
  <b>Def. 9: Lexical environment:</b> A <em>lexical environment</em> is a structure used to define association between <em>identifiers</em> appearing in the context with their values. Each environment can have a reference to an <em>optional parent environment</em>.
</p>
<p>So an environment is a <em>storage</em> of variables, functions, and classes defined in a scope.</p>
<p>Technically, an environment is a <em>pair</em>, consisting of an <em>environment record</em> (an actual storage table which maps identifiers to values), and a reference to the parent (which can be <code>null</code>).</p>
<p>For the code:</p>
<div><div id="highlighter_408352"><table><tbody><tr><td></td><td><div><div><code>let</code> <code>x = 10;</code></div><div><code>let</code> <code>y = 20;</code></div><div><code>function</code> <code>foo(z) {</code></div><div><code>let</code> <code>x = 100;</code></div><div><code>return</code> <code>x + y + z;</code></div><div><code>}</code></div><div><code>foo(30); </code><code>// 150</code></div></div></td></tr></tbody></table></div></div>
<p>The environment structures of the <em>global context</em>, and a context of the <code>foo</code> function would look as follows:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/environment-chain.png"  alt="Figure 6. An environment chain." title="Figure 6. An environment chain." /></div></p>
<p>Figure 6. An environment chain.</p>
<p>Logically this reminds us of the <em>prototype chain</em> which we’ve discussed above. And the rule for <em>identifiers resolution</em> is very similar: if a variable is <em>not found</em> in the <em>own</em> environment, there is an attempt to lookup it in the <em>parent environment</em>, in the parent of the parent, and so on — until the whole <em>environment chain</em> is considered.</p>
<p>
  <b>Def. 10: Identifier resolution:</b> the process of resolving a variable <em>(binding)</em> in an environment chain. An unresolved binding results to <code>ReferenceError</code>.
</p>
<p>This explains why variable <code>x</code> is resolved to <code>100</code>, but not to <code>10</code> — it is found directly in the <em>own</em> environment of <code>foo</code>; why we can access parameter <code>z</code> — it’s also just stored on the <em>activation environment</em>; and also why we can access the variable <code>y</code> — it is found in the parent environment.</p>
<p>Similarly to prototypes, the same parent environment can be shared by several child environments: for example, two global functions share the same global environment.</p>
<p><strong>Note:</strong> you can get detailed information about lexical environment in <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank">this article</a>.</p>
<p>Environment records differ by <em>type</em>. There are <strong><em>object</em></strong> environment records and <strong><em>declarative</em></strong> environment records. On top of the declarative record there are also <strong><em>function</em></strong> environment records, and <strong><em>module</em></strong> environment records. Each type of the record has specific only to it properties. However, the generic mechanism of the identifier resolution is common across all the environments, and doesn’t depend on the type of a record.</p>
<p>An example of an <em>object environment record</em> can be the record of the <em>global environment</em>. Such record has also associated <em>binding object</em>, which may store some properties from the record, but not the others, and vice-versa. The binding object can also be provided as <code>this</code> value.</p>
<div><div id="highlighter_201309"><table><tbody><tr><td></td><td><div><div><code>// Legacy variables using `var`.</code></div><div><code>var</code> <code>x = 10;</code></div><div><code>// Modern variables using `let`.</code></div><div><code>let</code> <code>y = 20;</code></div><div><code>// Both are added to the environment record:</code></div><div><code>console.log(</code></div><div><code>x, </code><code>// 10</code></div><div><code>y, </code><code>// 20</code></div><div><code>);</code></div><div><code>// But only `x` is added to the "binding object".</code></div><div><code>// The binding object of the global environment</code></div><div><code>// is the global object, and equals to `this`:</code></div><div><code>console.log(</code></div><div><code>this</code><code>.x, </code><code>// 10</code></div><div><code>this</code><code>.y, </code><code>// undefined!</code></div><div><code>);</code></div><div><code>// Binding object can store a name which is not</code></div><div><code>// added to the environment record, since it's</code></div><div><code>// not a valid identifier:</code></div><div><code>this</code><code>['not valid ID</code><code>'] = 30;</code></div><div><code>console.log(</code></div><div><code>this['</code><code>not valid ID'], </code><code>// 30</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>This is depicted on the following figure:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/env-binding-object.png"  alt="Figure 7. A binding object." title="Figure 7. A binding object." /></div></p>
<p>Figure 7. A binding object.</p>
<p>Notice, the binding object exists to cover <em>legacy constructs</em> such as <code>var</code>-declarations, and <code>with</code>-statements, which also provide their object as a binding object. These are historical reason when environments were represented as simple objects. Currently the environments model is much more optimized, however as a result we can’t access binding as properties anymore.</p>
<p>We have already seen how environments are related via the parent link. Now we shall see how an environment can <em>outlive</em> the context which creates it. This is the basis for the mechanism of <em>closures</em> which we’re about to discuss.</p>
<h2 id="closure"><a href="#closure" target="_blank">Closure</a></h2>
<p>Functions in ECMAScript are <em>first-class</em>. This concept is fundamental to <em>functional programming</em>, which aspects are supported in JavaScript.</p>
<p>
  <b>Def. 11: First-class function:</b> a function which can participate as a normal data: be stored in a variable, passed as an argument, or returned as a value from another function.
</p>
<p>With the concept of first-class functions so called <a href="https://en.wikipedia.org/wiki/Funarg_problem" target="_blank">“Funarg problem”</a> is related  (or <em>“A problem of a functional argument”</em>). The problem arises when a function has to deal with <em>free variables</em>.</p>
<p>
  <b>Def. 12: Free variable:</b> a variable which is <em>neither a parameter</em>, <em>nor a local variable</em> of this function.
</p>
<p>Let’s take a look at the Funarg problem, and see how it’s solved in ECMAScript.</p>
<p>Consider the following code snippet:</p>
<div><div id="highlighter_324791"><table><tbody><tr><td></td><td><div><div><code>let</code> <code>x = 10;</code></div><div><code>function</code> <code>foo() {</code></div><div><code>console.log(x);</code></div><div><code>}</code></div><div><code>function</code> <code>bar(funArg) {</code></div><div><code>let</code> <code>x = 20;</code></div><div><code>funArg(); </code><code>// 10, not 20!</code></div><div><code>}</code></div><div><code>// Pass `foo` as an argument to `bar`.</code></div><div><code>bar(foo);</code></div></div></td></tr></tbody></table></div></div>
<p>For the function <code>foo</code> the variable <code>x</code> is free. When the <code>foo</code> function is activated (via the <code>funArg</code> parameter) — where should it resolve the <code>x</code> binding? From the <em>outer scope</em> where the function was <em>created</em>, or from the <em>caller scope</em>, from where the function is <em>called</em>? As we see, the caller, that is the <code>bar</code> function, also provides the binding for <code>x</code> — with the value <code>20</code>. </p>
<p>The use-case described above is known as <strong><em>downward funarg problem</em></strong>, i.e. an <em>ambiguity</em> at determining a <em>correct environment</em> of a binding: should it be an environment of the <em>creation time</em>, or environment of the <em>call time</em>?</p>
<p>This is solved by an agreement of using <em>static scope</em>, that is the scope of the <em>creation time</em>.</p>
<p>
  <b>Def. 13: Static scope:</b> a language implements <em>static scope</em>, if only by looking at the source code one can determine in which environment a binding is resolved.</p>
<p>The static scope sometimes is also called <em>lexical scope</em>, hence the <em>lexical environments</em> naming.</p>
<p>Technically the static scope is implemented by <em>capturing the environment</em> where a function is <em>created</em>.</p>
<p><strong>Note:</strong> you can read about <em>static</em> and <em>dynamic</em> scopes in <a href="https://codeburst.io/js-scope-static-dynamic-and-runtime-augmented-5abfee6223fe" target="_blank">this article</a>.</p>
<p>In our example, the environment captured by the <code>foo</code> function, is the <em>global environment</em>:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/closure.png"  alt="Figure 8. A closure." title="Figure 8. A closure." /></div></p>
<p>Figure 8. A closure.</p>
<p>We can see that an environment references a function, which in turn reference the environment <em>back</em>.</p>
<p>
  <b>Def. 14: Closure:</b> A <em>closure</em> is a function which <em>captures the environment</em> where it’s <em>defined</em>. Further this environment is used for <em>identifier resolution</em>.</p>
<p><strong>Note:</strong> a function is <em>called</em> in a <em>fresh activation environment</em> which stores <em>local variables</em>, and <em>arguments</em>. The <em>parent environment</em> of the activation environment is set to the <em>closured environment</em> of the function, resulting to the <em>lexical scope</em> semantics.</p>
<p>The second sub-type of the Funarg problem is known as the <strong><em>upward funarg problem</em></strong>. The only difference here is that a capturing environment <em>outlives</em> the context which creates it.</p>
<p>Let’s see the example:</p>
<div><div id="highlighter_451133"><table><tbody><tr><td></td><td><div><div><code>function</code> <code>foo() {</code></div><div><code>let</code> <code>x = 10;</code></div><div><code>// Closure, capturing environment of `foo`.</code></div><div><code>function</code> <code>bar() {</code></div><div><code>return</code> <code>x;</code></div><div><code>}</code></div><div><code>// Upward funarg.</code></div><div><code>return</code> <code>bar;</code></div><div><code>}</code></div><div><code>let</code> <code>x = 20;</code></div><div><code>// Call to `foo` returns `bar` closure.</code></div><div><code>let</code> <code>bar = foo();</code></div><div><code>bar(); </code><code>// 10, not 20!</code></div></div></td></tr></tbody></table></div></div>
<p>Again, technically it doesn’t differ from the same exact mechanism of capturing the definition environment. Just in this case, hadn’t we have the closure, the activation environment of <code>foo</code> <em>would be destroyed</em>. But we <em>captured</em> it, so it <em>cannot be deallocated</em>, and is preserved — to support <em>static scope</em> semantics.</p>
<p>Often there is an incomplete understanding of closures — usually developers think about closures only in terms of the upward funarg problem (and practically it really makes more sense). However, as we can see, technical mechanism for <em>downward</em> and <em>upward funarg problem</em> is <em>exactly the same</em> — and is the <em>mechanism of static scope</em>.</p>
<p>As we mentioned above, similarly to prototypes, the same parent environment can be <em>shared</em> across <em>several</em> closures. This allows accessing and mutating the shared data:</p>
<div><div id="highlighter_692004"><table><tbody><tr><td></td><td><div><div><code>function</code> <code>createCounter() {</code></div><div><code>let</code> <code>count = 0;</code></div><div><code>return</code> <code>{</code></div><div><code>increment() { count++; </code><code>return</code> <code>count; },</code></div><div><code>decrement() { count--; </code><code>return</code> <code>count; },</code></div><div><code>};</code></div><div><code>}</code></div><div><code>let</code> <code>counter = createCounter();</code></div><div><code>console.log(</code></div><div><code>counter.increment(), </code><code>// 1</code></div><div><code>counter.decrement(), </code><code>// 0</code></div><div><code>counter.increment(), </code><code>// 1</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>Since both closures, <code>increment</code> and <code>decrement</code>, are created within the scope containing the <code>count</code> variable, they <em>share</em> this <em>parent scope</em>. That is, capturing always happens <em>“by-reference”</em> — meaning the <em>reference</em> to the <em>whole parent environment</em> is stored.</p>
<p>We can see this on the following picture:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/shared-environment.png"  alt="Figure 9. A closure." title="Figure 9. A shared environment." /></div></p>
<p>Figure 9. A shared environment.</p>
<p>Some languages may capture <em>by-value</em>, making a copy of a captured variable, and do not allow changing it in the parent scopes. However in JS, to repeat, it is always the <em>reference</em> to the parent scope.</p>
<p><strong>Note:</strong> implementations may optimize this step, and do not capture the whole environment. Capturing <em>only used</em> free-variables, they though still maintain invariant of mutable data in parent scopes.</p>
<p>You can find a detailed discussion on closures and the Funarg problem in the <a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank">appropriate chapter</a>.</p>
<p>So all identifiers are statically scoped. There is however <em>one</em> value which is <em>dynamically scoped</em> in ECMAScript. It’s the value of <code>this</code>.</p>
<h2 id="this"><a href="#this" target="_blank">This</a></h2>
<p>The <code>this</code> value is a special object which is <em>dynamically</em> and <em>implicitly</em> passed to the code of a context. We can consider it as an <em>implicit extra parameter</em>, which we can access, but cannot mutate.</p>
<p>The purpose of the <code>this</code> value is to executed the same code for multiple objects.</p>
<p>
  <b>Def. 15: This:</b> an implicit <em>context object</em> accessible from a code of an execution context — in order to apply the same code for multiple objects.</p>
<p>The major use-case is the class-based OOP. An instance method (which is defined on the prototype) exists in <em>one exemplar</em>, but is <em>shared</em> across <em>all the instances</em> of this class.</p>
<div><div id="highlighter_728589"><table><tbody><tr><td></td><td><div><div><code>class</code> <code>Point {</code></div><div><code>constructor(x, y) {</code></div><div><code>this</code><code>._x = x;</code></div><div><code>this</code><code>._y = y;</code></div><div><code>}</code></div><div><code>getX() {</code></div><div><code>return</code> <code>this</code><code>._x;</code></div><div><code>}</code></div><div><code>getY() {</code></div><div><code>return</code> <code>this</code><code>._y;</code></div><div><code>}</code></div><div><code>}</code></div><div><code>let</code> <code>p1 = </code><code>new</code> <code>Point(1, 2);</code></div><div><code>let</code> <code>p2 = </code><code>new</code> <code>Point(3, 4);</code></div><div><code>// Can access `getX`, and `getY` from</code></div><div><code>// both instances (they are passed as `this`).</code></div><div><code>console.log(</code></div><div><code>p1.getX(), </code><code>// 1</code></div><div><code>p2.getX(), </code><code>// 3</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>When the <code>getX</code> method is activated, a new environment is created to store local variables and parameters. In addition, <em>function environment record</em> gets the <code>[[ThisValue]]</code> passed, which is bound <em>dynamically</em> depending how a function is <em>called</em>. When it’s called with <code>p1</code>, the <code>this</code> value is exactly <code>p1</code>, and in the second case it’s <code>p2</code>.</p>
<p>Another application of <code>this</code>, is <em>generic interface functions</em>, which can be used in <em>mixins</em> or <em>traits</em>.</p>
<p>In the following example, the <code>Movable</code> interface contains generic function <code>move</code>, which expects the users of this mixin to implement <code>_x</code>, and <code>_y</code> properties:</p>
<div><div id="highlighter_803685"><table><tbody><tr><td></td><td><div><div><code>// Generic Movable interface (mixin).</code></div><div><code>let</code> <code>Movable = {</code></div><div><code>/**</code></div><div><code>* This function is generic, and works with any</code></div><div><code>* object, which provides `_x`, and `_y` properties,</code></div><div><code>* regardless of the class of this object.</code></div><div><code>*/</code></div><div><code>move(x, y) {</code></div><div><code>this</code><code>._x = x;</code></div><div><code>this</code><code>._y = y;</code></div><div><code>},</code></div><div><code>};</code></div><div><code>let</code> <code>p1 = </code><code>new</code> <code>Point(1, 2);</code></div><div><code>// Make `p1` movable.</code></div><div><code>Object.assign(p1, Movable);</code></div><div><code>// Can access `move` method.</code></div><div><code>p1.move(100, 200);</code></div><div><code>console.log(p1.getX()); </code><code>// 100</code></div></div></td></tr></tbody></table></div></div>
<p>As an alternative, a mixin can also be applied at <em>prototype level</em> instead of <em>per-instance</em> as we did in the example above.</p>
<p>Just to show the dynamic nature of <code>this</code> value, consider this example, which we leave to a reader as an exercise to solve:</p>
<div><div id="highlighter_207111"><table><tbody><tr><td></td><td><div><div><code>function</code> <code>foo() {</code></div><div><code>return</code> <code>this</code><code>;</code></div><div><code>}</code></div><div><code>let</code> <code>bar = {</code></div><div><code>foo,</code></div><div><code>baz() {</code></div><div><code>return</code> <code>this</code><code>;</code></div><div><code>},</code></div><div><code>};</code></div><div><code>// `foo`</code></div><div><code>console.log(</code></div><div><code>foo(),       </code><code>// global or undefined</code></div><div><code>bar.foo(),   </code><code>// bar</code></div><div><code>(bar.foo)(), </code><code>// bar</code></div><div><code>(bar.foo = bar.foo)(), </code><code>// global</code></div><div><code>);</code></div><div><code>// `bar.baz`</code></div><div><code>console.log(bar.baz()); </code><code>// bar</code></div><div><code>let</code> <code>savedBaz = bar.baz;</code></div><div><code>console.log(savedBaz()); </code><code>// global</code></div></div></td></tr></tbody></table></div></div>
<p>Since only by looking at the source code of the <code>foo</code> function we <em>cannot tell</em> what value of <code>this</code> will it have <em>in a particular call</em>, we say that <code>this</code> value is <em>dynamically scoped</em>.</p>
<p><strong>Note:</strong> you can get a detailed explanation how <code>this</code> value is determined, and why the code from above works the way it does, in the <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank">appropriate chapter</a>.</p>
<p>The <strong><em>arrow functions</em></strong> are special in terms of <code>this</code> value: their <code>this</code> is <em>lexical (static)</em>, but <em>not dynamic</em>. I.e. their function environment record <em>does not provide <code>this</code> value</em>, and it’s taken from the <em>parent environment</em>.</p>
<div><div id="highlighter_890051"><table><tbody><tr><td></td><td><div><div><code>var</code> <code>x = 10;</code></div><div><code>let</code> <code>foo = {</code></div><div><code>x: 20,</code></div><div><code>// Dynamic `this`.</code></div><div><code>bar() {</code></div><div><code>return</code> <code>this</code><code>.x;</code></div><div><code>},</code></div><div><code>// Lexical `this`.</code></div><div><code>baz: () =&gt; </code><code>this</code><code>.x,</code></div><div><code>qux() {</code></div><div><code>// Lexical this within the invocation.</code></div><div><code>let</code> <code>arrow = () =&gt; </code><code>this</code><code>.x;</code></div><div><code>return</code> <code>arrow();</code></div><div><code>},</code></div><div><code>};</code></div><div><code>console.log(</code></div><div><code>foo.bar(), </code><code>// 20, from `foo`</code></div><div><code>foo.baz(), </code><code>// 10, from global</code></div><div><code>foo.qux(), </code><code>// 20, from `foo` and arrow</code></div><div><code>);</code></div></div></td></tr></tbody></table></div></div>
<p>Like we said, in the <em>global context</em> the <code>this</code> value is the <em>global object</em> (the <em>binding object</em> of the <em>global environment record</em>). Previously there was only one global object. In current version of the spec there might be <em>multiple global objects</em> which are part of <em>code realms</em>. Let’s discuss this structure.</p>
<h2 id="realm"><a href="#realm" target="_blank">Realm</a></h2>
<p>Before it is evaluated, all ECMAScript code must be associated with a <em>realm</em>. Technically a realm just provides a global environment for a context.</p>
<p>
  <b>Def. 16: Realm:</b> A <em>code realm</em> is an object which encapsulates a separate <em>global environment</em>.</p>
<p>When an <em>execution context</em> is <em>created</em> it’s <em>associated</em> with a particular <em>code realm</em>, which provides the <em>global environment</em> for this context. This association further <em>stays unchanged</em>.</p>
<p><strong>Note:</strong> a direct realm equivalent in browser environment is the <code>iframe</code> element, which exactly provides a custom global environment. In Node.js it is close to the sandbox of the <a href="https://nodejs.org/api/vm.html" target="_blank">vm module</a>.</p>
<p>Current version of the specification doesn’t provide an ability to explicitly create realms, but they can be created implicitly by the implementations. There is a <a href="https://github.com/tc39/proposal-realms/" target="_blank">proposal</a> though to expose this API to user-code.</p>
<p>Logically though, each context from the stack is always associated with its realm:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/context-realm.png"  alt="Figure 10. A context and realm association." title="Figure 10. A context and realm association." /></div></p>
<p>Figure 10. A context and realm association.</p>
<p>Let’s see the separate realms example, using the <code>vm</code> module:</p>
<div><div id="highlighter_115268"><table><tbody><tr><td></td><td><div><div><code>const vm = require(</code><code>'vm'</code><code>);</code></div><div><code>// First realm, and its global:</code></div><div><code>const realm1 = vm.createContext({x: 10, console});</code></div><div><code>// Second realm, and its global:</code></div><div><code>const realm2 = vm.createContext({x: 20, console});</code></div><div><code>// Code to execute:</code></div><div><code>const code = `console.log(x);`;</code></div><div><code>vm.runInContext(code, realm1); </code><code>// 10</code></div><div><code>vm.runInContext(code, realm2); </code><code>// 20</code></div></div></td></tr></tbody></table></div></div>
<p>Now we’re getting closer to the bigger picture of the ECMAScript runtime. Yet however we still need to see the <em>entry point</em> to the code, and the <em>initialization process</em>. This is managed by the mechanism of <em>jobs</em> and <em>job queues</em>.</p>
<h2 id="job"><a href="#job" target="_blank">Job</a></h2>
<p>Some operations can be postponed, and executed as soon as there is an available spot on the execution context stack.</p>
<p>
  <b>Def. 17: Job:</b> A <em>job</em> is an abstract operation that initiates an ECMAScript computation when <em>no other</em> ECMAScript computation is currently in progress.</p>
<p>Jobs are enqueued on the <strong><em>job queues</em></strong>, and in current spec version there are two job queues: <strong><em>ScriptJobs</em></strong>, and <strong><em>PromiseJobs</em></strong>.</p>
<p>And <em>initial job</em> on the <em>ScriptJobs</em> queue is the <em>main entry point</em> to our program — initial script which is loaded and evaluated: a realm is created, a global context is created and is associated with this realm, it’s pushed onto the stack, and the global code is executed.</p>
<p>Notice, the <em>ScriptJobs</em> queue manages both, <em>scripts</em> and <em>modules</em>.</p>
<p>Further this context can execute <em>other contexts</em>, or enqueue <em>other jobs</em>. An example of a job which can be spawned and enqueued is a <em>promise</em>.</p>
<p>When there is <em>no running</em> execution context and the execution context stack is <em>empty</em>, the ECMAScript implementation removes the first <em>pending job</em> from a job queue, creates an execution context and starts its execution.</p>
<p><strong>Note:</strong> the job queues are usually handled by the abstraction known as the <strong><em>“Event loop”</em></strong>. ECMAScript standard doesn’t specify the event loop, leaving it up to implementations, however you can find an educational example — <a href="https://gist.github.com/DmitrySoshnikov/26e54990e7df8c3ae7e6e149c87883e4" target="_blank">here</a>.</p>
<p>Example:</p>
<div><div id="highlighter_579078"><table><tbody><tr><td></td><td><div><div><code>// Enqueue a new promise on the PromiseJobs queue.</code></div><div><code>new</code> <code>Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 0))</code></div><div><code>.then(value =&gt; console.log(value));</code></div><div><code>// This log is executed earlier, since it's still a</code></div><div><code>// running context, and job cannot start executing first</code></div><div><code>console.log(20);</code></div><div><code>// Output: 20, 10</code></div></div></td></tr></tbody></table></div></div>
<p><strong>Note:</strong> you can read more about promises in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">this documentation</a>.</p>
<p>The <em><strong>async functions</strong></em> can <em>await</em> for promises, so they also enqueue promise jobs:</p>
<div><div id="highlighter_299908"><table><tbody><tr><td></td><td><div><div><code>async </code><code>function</code> <code>later() {</code></div><div><code>return</code> <code>await Promise.resolve(10);</code></div><div><code>}</code></div><div><code>(async () =&gt; {</code></div><div><code>let</code> <code>data = await later();</code></div><div><code>console.log(data); </code><code>// 10</code></div><div><code>})();</code></div><div><code>// Also happens earlier, since async execution</code></div><div><code>// is queued on the PromiseJobs queue.</code></div><div><code>console.log(20);</code></div><div><code>// Output: 20, 10</code></div></div></td></tr></tbody></table></div></div>
<p><strong>Note:</strong> read more about async functions in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank">here</a>.</p>
<p>Now we’re very close to the final picture of the current JS Universe. We shall see now <em>main owners</em> of all those components we discussed, the <em>Agents</em>.</p>
<h2 id="agent"><a href="#agent" target="_blank">Agent</a></h2>
<p>The <em>concurrency</em> and <em>parallelism</em> is implemented in ECMAScript using <em>Agent pattern</em>. The Agent pattern is very close to the <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank">Actor pattern</a> — a <em>lightweight process</em> with <em>message-passing</em> style of communication.</p>
<p>
  <b>Def. 18: Agent:</b> An <em>agent</em> is an abstraction encapsulating execution context stack, set of job queues, and code realms.</p>
<p>Implementation dependent an agent can run on the same thread, or on a separate thread. The <code>Worker</code> agent in the browser environment is an example of the <em>Agent</em> concept.</p>
<p>The agents are <em>state isolated</em> from each other, and can communicate by <em>sending messages</em>. Some data can be shared though between agents, for example <code>SharedArrayBuffer</code>s. Agents can also combine into <em>agent clusters</em>. </p>
<p>In the example below, the <code>index.html</code> calls the <code>agent-smith.js</code> worker, passing shared chunk of memory:</p>
<div><div id="highlighter_879870"><table><tbody><tr><td></td><td><div><div><code>// In the `index.html`:</code></div><div><code>// Shared data between this agent, and another worker.</code></div><div><code>let</code> <code>sharedHeap = </code><code>new</code> <code>SharedArrayBuffer(16);</code></div><div><code>// Our view of the data.</code></div><div><code>let</code> <code>heapArray = </code><code>new</code> <code>Int32Array(sharedHeap);</code></div><div><code>// Create a new agent (worker).</code></div><div><code>let</code> <code>agentSmith = </code><code>new</code> <code>Worker(</code><code>'agent-smith.js'</code><code>);</code></div><div><code>agentSmith.onmessage = (message) =&gt; {</code></div><div><code>// Agent sends the index of the data it modified.</code></div><div><code>let</code> <code>modifiedIndex = message.data;</code></div><div><code>// Check the data is modified:</code></div><div><code>console.log(heapArray[modifiedIndex]); </code><code>// 100</code></div><div><code>};</code></div><div><code>// Send the shared data to the agent.</code></div><div><code>agentSmith.postMessage(sharedHeap);</code></div></div></td></tr></tbody></table></div></div>
<p>And the worker code:</p>
<div><div id="highlighter_770602"><table><tbody><tr><td></td><td><div><div><code>// agent-smith.js</code></div><div><code>/**</code></div><div><code>* Receive shared array buffer in this worker.</code></div><div><code>*/</code></div><div><code>onmessage = (message) =&gt; {</code></div><div><code>// Worker's view of the shared data.</code></div><div><code>let</code> <code>heapArray = </code><code>new</code> <code>Int32Array(message.data);</code></div><div><code>let</code> <code>indexToModify = 1;</code></div><div><code>heapArray[indexToModify] = 100;</code></div><div><code>// Send the index as a message back.</code></div><div><code>postMessage(indexToModify);</code></div><div><code>};</code></div></div></td></tr></tbody></table></div></div>
<p>You can find the full code for the example above in <a href="https://gist.github.com/DmitrySoshnikov/b75a2dbcdb60b18fd9f05b595135dc82" target="_blank">this gist</a>.</p>
<p>(Notice, if you run this example locally, run it in Firefox, since Chrome due to security reasons doesn’t allow loading web workers from a local file)</p>
<p>So below is the picture of the ECMAScript runtime:</p>
<p><div class="readableLargeImageContainer"><img src="/wp-content/uploads/2017/11/agents-1.png"  alt="Figure 11. ECMAScript runtime." title="Figure 11. ECMAScript runtime." /></div></p>
<p>Figure 11. ECMAScript runtime.</p>
<p>And that is it; that’s what happens under the hood of the ECMAScript engine!</p>
<p>Now we come to an end. This is the amount of information on JS core which we can cover within an overview article. Like we mentioned, JS code can be grouped into <em>modules</em>, properties of objects can be tracked by <code>Proxy</code> objects, etc, etc. — there are many user-level details which you can find in different documentations on JavaScript language.</p>
<p>Here though we tried to represent the <em>logical structure</em> of an ECMAScript program itself, and hopefully it clarified these details. If you have any questions, suggestions or feedback, — as always I’ll be glad to discuss them in comments.</p>
<p>I’d like to thank the TC-39 representatives and spec editors which helped with clarifications for this article. The discussion can be found in <a href="https://twitter.com/DmitrySoshnikov/status/930507793047592960" target="_blank">this Twitter thread</a>. </p>
<p>Good luck in studying ECMAScript!</p>
<p><strong>Written by:</strong> Dmitry Soshnikov<br />
<strong>Published on:</strong> November 14th, 2017</p>