<a href="https://medium.com/@wonderboymusic/upgrading-to-relay-modern-or-apollo-ffa58d3a5d59">https://medium.com/@wonderboymusic/upgrading-to-relay-modern-or-apollo-ffa58d3a5d59</a><div id="articleHeader"><h1>Upgrading to Relay Modern or Apollo</h1></div><figure id="47e1"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/75/1*9OG8uXcVQLfM0jfZjv2CZA.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*9OG8uXcVQLfM0jfZjv2CZA.png" /></div></figure><p id="93ae">I wrote previously about how the New York Times is basing its re-platform/redesign on React and GraphQL, and I singled out Relay as our choice of framework for connecting the two.</p><p id="3198">All of those things remain true, but in an ecosystem that moves extremely fast (NPM/Node) and creates epic amounts of <a href="https://en.wikipedia.org/wiki/Vaporware" target="_blank">vaporware</a> and <a href="https://en.wikipedia.org/wiki/Abandonware" target="_blank">abandonware</a>, we must constantly reevaluate all of our decisions and assumptions to make sure we are building a solid foundation for the future.</p><p id="90fe">Relay has now been dubbed <a href="https://facebook.github.io/relay/docs/conversion-playbook.html" target="_blank">Relay Classic</a>, and the new cool kid is <a href="https://facebook.github.io/relay/docs/relay-modern.html" target="_blank">Relay Modern</a>. Migrating from Classic to Modern is not a walk in the park, which I’ll talk about below. We need to know where these platforms are heading, and we thought it would be a good time to compare Relay Modern and <a href="http://dev.apollodata.com/" target="_blank">Apollo</a> to weigh our options for the future.</p><h3 id="7bf1">Disclaimer</h3><p id="03d5">This post is not going to prefer one project or the other, and it is not going to foreshadow any decision on our side. We are in no danger of moving too fast in either direction. In fact, Relay Modern has moved closer to Apollo in a lot of ways, so any pre-requisite work we do to transition our Classic codebase will move us closer to both of them.</p><h3 id="d046">Assumptions</h3><ul><li id="f3fc">GraphQL is the future</li><li id="68c5">We are going to use React to build our UIs</li><li id="ee0d">The app we build has to be <a href="https://blog.nodejitsu.com/scaling-isomorphic-javascript-code/" target="_blank">universal</a>/<a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9" target="_blank">isomorphic</a>: <br />fully-rendered on the server and the client</li><li id="0fee">The app needs capabilities like client-only queries to allow the server response to be cached in a CDN (server-rendering in React <a href="https://medium.com/react-university/4-practical-tips-for-drastically-improved-server-side-rendering-in-react-2df98555a26b" target="_blank">is …. slow</a>) and not rely on cookies</li></ul></section><section><div><div><h3 id="530e">Proof of Concept</h3><p id="528f">The NYT contains a lot of components, all with GraphQL fragments of varying degrees of complexity. Using the NYT codebase to try-out a new framework is not always practical. As such, I wrote an end-to-end product that is much simpler. It is also an open source project I am working on: a headless WordPress “theme” built on GraphQL, with versions for Relay, Apollo, and an app written in React Native. The motivation: I want to use WordPress as my CMS, but I do not like writing UIs in PHP. I do like writing UIs in React, and I think Relay and Apollo are cool.</p><p id="2aa2"><a href="https://github.com/staylor/wp-graphql" target="_blank">The GraphQL server</a> reads its data from the WordPress REST API and exposes a “product schema” that describes the data a WordPress theme probably needs to build a site that has parity with a theme written in PHP using WordPress idioms. The schema could actually be resolved by a backend that is not WordPress, which is the beauty of GraphQL: I describe my product, the data resolution and implementation details are opaque.</p><p id="d053">The WordPress Rest API does not expose enough data by default to build a full theme, so I extended the API with my own endpoints. They are enabled by activating my <a href="https://github.com/staylor/wp-graphql-middleware" target="_blank">WordPress GraphQL Middleware</a> plugin in a WordPress install. The plugin is only available on GitHub right now, as it is still in active development.</p><p id="d332">The GraphQL server is mostly stable. It uses the reference implementation of GraphQL from Facebook, <a href="https://github.com/graphql/graphql-js" target="_blank">graphql-js</a>. I also leaned on <a href="https://facebook.github.io/jest/" target="_blank">Jest</a> for unit-testing, and <a href="https://github.com/facebook/dataloader" target="_blank">DataLoader</a> (a game-changer) for orchestrating batch requests to the REST API.</p><p id="25b3">The first implementation I did was on Relay Modern: <a href="https://github.com/staylor/graphql-wordpress/tree/master/packages/relay-wordpress" target="_blank">relay-wordpress</a>. For our recent Maker Week (work on whatever you want) at the Times, I wrote a React Native version of the same app.</p><p id="3b4a">To play devil’s advocate, I also tried out the same app in Apollo: <a href="https://github.com/staylor/graphql-wordpress/tree/master/packages/apollo-wordpress" target="_blank">apollo-wordpress</a>. I went in with a bias towards Relay and came away with a completely different perspective.</p><p id="2762">It is possible that neither is the right framework, or they are both equally as good. I think it all depends on your evaluation criteria. I will evaluate both of them below. My notes on Relay Classic are based on work I have done at the Times. The examples in Relay Modern and Apollo are drawn from my open source projects.</p></div></section><section><div><div><h3 id="ce03">Picking a Router</h3><p id="2c1d">When using Relay with a Node server like Express, you can typically pipe all routes to the same resolver and have your app’s internal router control the render path. The router might also take props that allow you to specify GraphQL queries associated with the matched path. Example:</p><pre id="5ef7">// routes/index.js</pre><pre id="aeb6">&lt;Route component={App}&gt;<br />  &lt;Route path="/:id" component={Story} queries={{<br />    story: () =&gt; Relay.QL`query { article(id: $id) }`,<br />  }} /&gt;<br />  &lt;Route path="/" component={Home} queries={{<br />    home: () =&gt; Relay.QL`query { home }`,<br />  }} /&gt;<br />&lt;/Route&gt;</pre><p id="e08d">It is essential that the router consumes a static route config that can be read in a repeatable and predictable way. Without knowing the route config, it is not currently possible to extract all queries for a particular route to:</p><p id="a0ef">1) request data on the server<br />2) rehydrate the client with the same data</p><p id="8fcc">This avoids making GraphQL queries on the server and then immediately requesting the data again when the page loads on the client.</p><p id="c978"><strong>Relay Classic</strong>:<br />We need:</p><ul><li id="b70f"><a href="https://github.com/ReactTraining/react-router/tree/v3/docs" target="_blank">React Router v3</a> (RRv3), which is used to compose nested routes using React components (see above) that can be read as a route “config”.</li><li id="d7f5"><a href="https://github.com/denvned/isomorphic-relay-router/" target="_blank">Isomorphic React Router Relay</a> (IRRR), which fetches data based on the props extracted by <code>match()</code> (from RRv3) on the server — this module requires: <a href="https://github.com/denvned/isomorphic-relay" target="_blank">Isomorphic React Relay</a> (IRR) and <a href="https://github.com/relay-tools/react-router-relay" target="_blank">React Router Relay</a>.</li></ul><p id="5ebe">On the client, <code>&lt;Router&gt;</code> from IRRR wraps <code>&lt;Route&gt;</code>s from RRv3. Because we are using IRRR, we know how to read the props on <code>&lt;Route&gt;</code> that specify the Relay queries associated with a given path. IRR supports <a href="https://github.com/denvned/isomorphic-relay/blob/master/examples/star-wars/src/client.js#L11" target="_blank">rehydration</a>, but we had some problems with it (probably self-inflicted).</p><p id="6f9d"><strong>Relay Modern<br /></strong>We use <a href="https://github.com/4Catalyzer/found-relay" target="_blank">Found Relay</a> — there is currently no alternative when you need isomorphic rendering. Found Relay is the <code>&lt;Router&gt;</code> and <code>Route</code>. There is no mix and match. Found Relay has a <a href="https://github.com/4Catalyzer/found-relay/blob/master/examples/todomvc-modern-universal/src/fetcher.js#L3" target="_blank">naive approach</a> to client rehydration that is less than ideal.</p><p id="8e2e">IRRR and IRR have not been updated to work with Relay Modern, and there appear to be no plans for them to do so. Because those libraries are pre-reqs for RRv3 to work with Relay, RRv3 is not an option. <a href="https://reacttraining.com/react-router/" target="_blank">React Router v4</a> does not have any knowledge of Relay, it does not support middleware (RRv3 does), and <code>&lt;Route&gt;</code>s can be rendered anywhere in the component tree. Even if we could do a render pass to extract all of the possible queries from the routes, they still might not be comprehendible — it is entirely possible that nested component query variables are constructed dynamically at runtime.</p><p id="9df3"><strong>Apollo<br /></strong>We would use… any router we want. Queries are not configured on routes. Apollo out-of-the-box does a render pass that can comprehend possible queries. Rehydration works out of the box. Apollo uses <a href="http://redux.js.org/" target="_blank">Redux</a> under the hood, so this whole process is pretty elegant.</p><p id="27b9"><strong>Takeaways</strong>: Apollo takes away a lot of drama here. Found Relay works, but does not have a huge community behind it. The maintainer, <a href="https://medium.com/u/d9593526326a" target="_blank">Jimmy Jia</a>, has been really helpful though and is always open to talk about these technical challenges. React Router v4 is possibly an anti-pattern for isomorphic apps, although it works just fine on React Native.</p></div></section><section><div><div><h3 id="777f">Environment</h3><p id="c991">The “environment” is the layer that actually encapsulates network fetching, the store, and caching.</p><p id="8eb2"><strong>Relay Classic</strong><br />There is a <code>Relay.DefaultNetworkLayer</code> that can be configured to talk to GraphQL using <code>fbjs/lib/fetch</code>, or you can roll your own (this part is strange in Classic). This initialization only happens on the client, the server uses IRRR’s imperative API.</p><p id="d7c1"><strong>Relay Modern</strong><br />You create an instance of <code>Environment</code> that contains instances of other pieces, including an instance of <code>Network</code>, which you pass your Fetch implementation to. The <code>fetch()</code> implementation can be really simple, basically the version you get from “Hello, World” will work for querying your GraphQL server. <a href="https://github.com/facebook/relay/tree/master/packages/relay-runtime" target="_blank">relay-runtime</a> also exposes a <code>QueryResponseCache</code> object that accepts TTLs that you can use in your fetch implementation. The caching is nice for React Native apps, where constant data-fetching is less necessary. Invalidation can become too complicated otherwise, unless you are just using low TTLs for performance. Persisted queries in Relay are currently a roll-your-own-imlementation (<a href="https://github.com/staylor/graphql-wordpress/blob/master/packages/relay-wordpress/tools/persistedQueries.js" target="_blank">I did it here</a>). The logic to send an ID instead of the query text <a href="https://github.com/staylor/graphql-wordpress/blob/master/packages/relay-wordpress/src/relay/fetcher.js" target="_blank">lives in the fetcher</a>.</p><p id="c154">Example using Found Relay and its <code>Resolver</code>:</p><pre id="ec5e">export function createResolver(fetcher) {<br />  const environment = new Environment({<br />    network: Network.create((...args) =&gt; fetcher.fetch(...args)),<br />    store: new Store(new RecordSource()),<br />  });<br />  return new Resolver(environment);<br />}</pre><p id="d135">Example using React Native:</p><pre id="3312">const source = new RecordSource();<br />const store = new Store(source);</pre><pre id="0b39">const network = Network.create(fetchQuery);</pre><pre id="2f8b">const environment = new Environment({<br />  network,<br />  store,<br />});</pre><pre id="eec2">export default environment;</pre><p id="fdae"><strong>Apollo<br /></strong>This logic is tucked away in <code>ApolloClient</code> on the server and the client. <code>ApolloClient</code> is also where persisted queries can be configured. Apollo doesn’t need your GraphQL schema, but this is also where you specify the JSON config for your <code>fragmentMatcher</code>, which lists all of your <code>Union</code> and <code>Interface</code> types. Without this, Apollo will throw a bunch of warnings that it is using heuristics to determine types at runtime. Example:</p><pre id="82f8">// server<br />const client = new ApolloClient({<br />  ssrMode: true,<br />  networkInterface: new PersistedQueryNetworkInterface({    <br />    queryMap,<br />    uri,<br />  }),<br />  fragmentMatcher,<br />});</pre><pre id="fd27">// client <br />const client = new ApolloClient({<br />  initialState: window.__APOLLO_STATE__,<br />  networkInterface: new PersistedQueryNetworkInterface({        <br />    queryMap,<br />    uri,<br />  }),<br />  fragmentMatcher,<br />});</pre><p id="3c19"><strong>Takeaways</strong>: Apollo has an elegant solution. Relay Modern works out of the box with React Native, needs some 3rd-party love on the web.</p></div></section><section><div><div><h3 id="1e9d">Fragments</h3><p id="7932">GraphQL fragments are typically co-located with React components. <a href="https://facebook.github.io/react/docs/higher-order-components.html" target="_blank">Higher-Order Components (HOCs)</a> (via <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank">ES7 decorators</a> or an imperative API) glue the components together with their “fragment container.”</p><p id="0f57"><strong>Relay Classic</strong><br />Fragments are atomic units. They are lazily constructed via a thunk that returns the result of the <code>Relay.QL</code> tagged template literal. Unless I am mistaken, the <a href="https://facebook.github.io/relay/docs/guides-babel-plugin.html" target="_blank">Relay Classic Babel plugin</a> intercedes here and turns the result into an AST at runtime, a <code>GraphQLTaggedNode</code>. Nested Components fragments can be included via <code>Component.getFragment(‘node’)</code> calls, and are subject to Data Masking: which means Relay will hide the portion of the query from all components except the one that required the specific slice of data represented by the <code>getFragment</code> call. Here’s a concrete example:</p><pre id="cd32">fragments: {<br />    card: () =&gt; Relay.QL`<br />      fragment Card_card on Asset {<br />        __typename<br />        ... on CardInterface {<br />          card_type<br />          promo_media_emphasis<br />          news_status<br />          promotional_media {<br />            __typename<br />            ... on AssetInterface {<br />              promotional_media {<br />                __typename<br />              }<br />            }<br />          }<br />        }<br />        ... on AssetInterface {<br />          last_modified_timestamp<br />          last_major_modification_timestamp<br />        }<br />        ${CardMeta.getFragment('card')}<br />        ${HeadlineCardContent.getFragment('card')}<br />        ${VideoHeadlineCardContent.getFragment('card')}<br />      }<br />    `,<br />  },</pre><p id="c169">WARNING: these fragments, in addition to allowing the inclusion of other component’s fragments (by design), also allow interpolation of string literals, and can be informed by variables local to the HOC itself via <code>initialVariables</code> and <code>prepareParams</code>, props that also lived on <code>Relay.Route</code>, back when Relay was a routing framework at Facebook.</p><p id="20c2">Because these fragments can take local variables, the result of this fragment can not be known statically, as <code>prepareParams</code> can construct literally whatever it wants. Even more dangerous: the inclusion of fragments from another container can also be informed by these same variables. Example:</p><div><pre id="11f0">{<br />  initialVariables: {<br />    crop: ‘jumbo’,<br />  },<br />  copy<code>prepareParams: () =&gt; {  // set crop based on runtime },</code><br />  fragments: {<br />    media: ({ crop }) =&gt; Relay.QL`<br />      fragment on Media {<br />        ${NestedComponent.getFragment(‘media’, { crop })}<br />      }<br />    `,<br />  },<br />}</pre></div><p id="7db7">These types of fragments cannot be statically analyzed, and cause cascading complexity as they are passed down.</p><p id="3381"><strong>Relay Modern<br /></strong>The tagged template literal around fragments is <code>graphql</code>. Fragments are strings with no interpolation. <code>${Component.getFragment(‘node’)}</code> becomes, simply, <code>...Component_node</code>. The actual component whose fragments you are spreading does even need to be in scope, so it is possible you can import fewer modules. A caveat: all fragments now need to be named. <br /><code>fragment on Media { ... }</code> needs to be:<br /><code>fragment Component_media on Media { ... }</code>.</p><p id="bb8b">The naming convention is not arbitrary. It is: <code>{FileName}_{prop}</code>. If you use <code>index.js</code> as the name of your file, the name will be the name of the parent folder.</p><p id="87bf">Why do all of this? <br />All fragments and queries are known at build time this way, and can be statically analyzed when your app builds, so no runtime parsing has to take place.</p><p id="b480">Relay Modern has a compiler called <a href="https://facebook.github.io/relay/docs/relay-compiler.html" target="_blank">relay-compiler </a>that introduces a build step to your app. The build step generates artifacts. The <a href="https://facebook.github.io/relay/docs/babel-plugin-relay.html" target="_blank">Babel plugin for Relay Modern</a> (not the same plugin as Classic!) causes your <code>graphql</code> tagged template calls to lazy-require the artifact files that look like: <br /><code>Component/__generated__/Component_media.graphql.js</code>.</p><p id="07f2"><strong>Apollo</strong><br />The tagged template literal for fragments is <code>gql</code>. The default pattern for specifying fragments for a component is via a static member on the component class called <code>fragments</code>. Apollo uses the <code>...Component_media</code> syntax for spreading fragments of other components, but it also requires you to add the actual fragment to the bottom via string interpolation. Example:</p><pre id="6e24">fragment Component_media on Media {<br />  id<br />  ...Image_image<br />}<br />${Image.fragments.image}</pre><p id="7b49">Apollo does not enforce Data Masking, and doesn’t require co-locating your fragments, so fragment “snippets” (an anti-pattern and probably dangerous as pertains to compatibility) are more share-able by default. You can actually place the fragments in their own <code>.graphql</code> files and use the <a href="https://github.com/apollographql/graphql-tag" target="_blank">graphl-tag</a> module to load them. Instead of including the fragments from other components, you use the <code>#import</code> syntax exposed by the Webpack loader:</p><pre id="11ec">// Component_media.graphql</pre><pre id="4381">#import "./Image_image.graphql"</pre><pre id="babe">fragment Component_media on Media {<br />  id<br />  ...Image_image<br />}</pre><p id="5cef">An advantage to this approach is syntax-highlighting in your editor.</p><p id="1cc4"><strong>Takeaways</strong>: Fragments in Relay Modern are much cleaner and enable static queries. The ergonomics of fragments in Apollo are different, and possibly better when fragments are placed in separate files. However, this breaks the idea of co-locating fragments with React components. So, this may be a religious debate. What is most obvious to me: dynamic fragments in Relay Classic have to go.</p></section><section><div><div><h3 id="d565">Queries</h3><p id="39fb"><strong>Relay Classic</strong><br />The queries for a given path live in the route config, and all of the fragments in the component tree below specify which parts they are interested in. A implicit component hierarchy is necessary, and is strictly enforced by <a href="https://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking" target="_blank">Data Masking</a>. You never specify the whole query in one place, you simply say: <code>query { asset(id: $id) }</code> and the rest is mostly magic.</p><p id="c1d4"><strong>Relay Modern<br /></strong>Since Found Relay is our only option for routing right now, you specify the query fragment on the route, via a <code>graphql</code> tagged template, or by including the module that exposes the query. I actually suggest that you place all top-level queries in a folder called <code>queries</code>. The query can be statically analyzed at build time:</p><pre id="8a8d">// queries/Story_Query.js</pre><pre id="4eb6">import { graphql } from 'react-relay';</pre><pre id="55d2">export default graphql`<br />  query Story_Query($id: ID!) {<br />    ...Story_whatever<br />  }<br />`;</pre><p id="d043">Data Masking is still enforced, but this query is represented in the AST as an entire query. The build artifact exports what is called a <code>ConcreteBatch</code>, which contains a node called <code>text</code>, which contains the plaintext GraphQL query. Because the text for the query is known, and the process for retrieving it is nominal, an ID can be assigned to the text representation, and sent in place of the query, so long as the GraphQL server knows this is happening and is able to turn the ID into the full query text.</p><p id="dd0b">Both servers, Relay and GraphQL, have to be set up to comprehend this exchange.</p><p id="2cd1">Instead of your fragments containing dynamic fragments, your queries take top-level variables. This may require rethinking portions of your app that wanted to remain dynamic at runtime. You may also have to request more data than you did in Classic and filter data at runtime.</p><p id="b9d5">In our Classic example above that had a fragment variable called <code>crop</code>, we need to transition that fragment to receive a variable from the query itself. Here’s what it might look like after transition:</p><pre id="a38c">graphql`<br />  fragment Component_node on Media {<br />    crop(size: $crop) {<br />      url<br />      width<br />      height<br />    } <br />  }<br />`</pre><p id="3dd4">It might be hard or weird to transition some of your components in this way, but the payoff is use of a leaner Relay core and no expensive runtime query parsing.</p><p id="8edf">Relay Modern exposes a Component called <code><a href="https://facebook.github.io/relay/docs/query-renderer.html" target="_blank">QueryRenderer</a></code>. <code>&lt;QueryRenderer&gt;</code> can be dropped anywhere in your component tree and given your Relay <code>Environment</code> instance, a query, and variables, make a request to your GraphQL server that is passed to a function exposed on the render prop. From the Relay Modern docs:</p><pre id="78f0">import { QueryRenderer, graphql } from 'react-relay';<br /><br />// Render this somewhere with React:<br />&lt;QueryRenderer<br />  environment={environment}<br />  query={graphql`<br />    query ExampleQuery($pageID: ID!) {<br />      page(id: $pageID) {<br />        name<br />      }<br />    }<br />  `}<br />  variables={{<br />    pageID: '110798995619330',<br />  }}<br />  render={({error, props}) =&gt; {<br />    if (error) {<br />      return &lt;div&gt;{error.message}&lt;/div&gt;;<br />    } else if (props) {<br />      return &lt;div&gt;{props.page.name} is great!&lt;/div&gt;;<br />    }<br />    return &lt;div&gt;Loading&lt;/div&gt;;<br />  }}<br />/&gt;</pre><p id="78a5">In React Native, this is great, and makes your choice of routing solution less critical. There is no server/client scenario in native apps, which is why Relay Modern “just works” there.</p><p id="eafb">On the web, and specifically for universal rendering, this is a problem. Because these queries can live somewhere other than your route config, it can become impossible to know all of your queries ahead of time to request data properly for server rendering your app. This is the task IRR did in Classic. As such, <code>QueryRenderer</code> can only be used for client-only queries.</p><p id="b92a">Client-only queries are not a first-class citizen in universal Relay apps, so <code>QueryRenderer</code> should NOT be used for queries tied to routes, <a href="https://github.com/4Catalyzer/found-relay/blob/master/examples/todomvc-modern-universal/src/router.js#L36" target="_blank">Found Relay will handle those queries</a>. <code>QueryRenderer</code> is only to be used for “extra” data that might be a result of a user interaction or page scroll. Found Relay attempts to implement the insides of <code>QueryRenderer</code> when it resolves data on the server.</p><p id="8e6d"><strong>Apollo<br /></strong>Queries can live anywhere via the <code>graphql</code> HOC, typically used as an ES7 decorator. On the server, Apollo does an initial render pass that only extracts data. Example:</p><pre id="af58">import { graphql } from 'react-apollo';<br />import PageQuery from 'graphql/Page_Query.graphql';</pre><pre id="186a">@graphql(PageQuery, {<br />  options: ({ params: { slug } }) =&gt; ({<br />    variables: {<br />      slug,<br />    },<br />  }),<br />})<br />export default class Page extends Component { ... }</pre><p id="e7dd"><strong>Takeaways</strong>: all three solutions query data in wildly different ways. Something to note: the trend is towards one Query per route. This can easily be accomplished if you make a top-level GraphQL type called <code>Viewer</code> and specify all possible queries as fields below it.</p></div></section><section><div><div><h3 id="dc53">Mutations</h3><p id="7841"><strong>Relay Classic<br /></strong>Mutations are constructed via configuration, some of which uses Flux idioms. They are confusing and weird. The “store” is updated via a Flux config. The whole process is very black hole. Rather than dive in here, just <a href="https://facebook.github.io/relay/docs/api-reference-relay-mutation.html" target="_blank">peruse the docs</a>.</p><p id="f393"><strong>Relay Modern<br /></strong>Mutations use an imperative API that is very similar to Apollo’s. Updating the store is mostly a manual process that requires interacting with the <code>ConnectionHandler</code> API. Mutations still require a config object, but one that is (slightly) less confusing. Optimistic updates use the same data you passed to create the mutation. Mutations require your instance of <code>Environment</code>. The documentation for interacting with the store is basically non-existent. Changes to the store cause UI to re-render. <em>Editor’s Note</em>: I just checked the docs, and they have now included references in Relay Modern to the Flux-style configs. <a href="https://facebook.github.io/relay/docs/mutations.html" target="_blank">Good Luck</a>. I’m not even sure that looking at code makes this easier to understand, but <a href="https://github.com/staylor/graphql-wordpress/tree/master/packages/relay-wordpress/src/mutations" target="_blank">here are some mutations</a> I added to perform CRUD on a post’s comments.</p><p id="59d9"><strong>Apollo<br /></strong>Uses an imperative API. Interacting with the store is kinda strange — this is not a knock. Changes are made manually and then committed back. Although they claim that data is more consistent in their store, I can see how developer error can mess this up. Mutations are specified using the <code>graphql</code> HOC (like queries), and I like how this encourages the creation of atomic components to handle each mutation. For instance, rather than having a button that calls a method on its parent component triggering a mutation on click, the button itself can become a component that is wrapped in a HOC. The HOC provides the wrapped component with a <code>mutate</code> prop. Here is my <a href="https://github.com/staylor/graphql-wordpress/blob/master/packages/apollo-wordpress/src/components/Comments/Comment/DeleteButton.js" target="_blank">Delete Comment button</a>.</p><p id="e12b"><strong>Takeaways</strong>: Relay Modern moves closer to Apollo, but seems to not be able to quit the confusing Flux configs. Apollo has a pretty nice solution but a different Store implementation. Reading and writing are really different across Relay and Apollo. Optimistic UI updates are pretty similar. I also like how Apollo allows you to specify <code>refetchQueries</code> when calling a mutation. That way, your mutation can return a small amount of data needed for the UI update, and the refetch queries can keep your store up to date.</p></div></section><section><div><div><h3 id="3036">Refetching</h3><p id="e47c">There may be times where you want to “refetch” a route’s top-level query with new query variables. For me, the most obvious reason is a feature like Search. In a single page app, I want to do as much as possible without a full page reload. Refetch behavior makes this possible.</p><p id="4904"><strong>Relay Classic</strong><br />If you want to “refetch” the query on the client based on new input or client-only flags being set, you call <code>this.props.relay.setVariables({ ... })</code> in a component. This will either affect the variables of the fragment they are called in, or cascade down the chain. <code>setVariables()</code> also triggers a store lookup and is when the cryptic “node” query is triggered. I am actually not sure if calling this function in a nested component can affect ancestor component variables, and I really don’t want to try to find out.</p><p id="da8d"><strong>Relay Modern<br /></strong>There are different types of “containers” — in Classic, <code>Relay.createContainer()</code> is the HOC. In Modern, Fragment Containers are created with <code>createFragmentContainer()</code>, and Refetch Containers are created via <code>createRefetchContainer()</code>. Creating a Refetch Container enables the following method: <code>this.props.relay.refetch({ ... })</code>. When creating the Refetch Container, you specify what query you are refetching. Example, I created my own decorator to call <code>createRefetchContainer</code>:</p><pre id="ae9f">// decorators/RefetchContainer.js</pre><pre id="6ffd">import { createRefetchContainer } from 'react-relay'; </pre><pre id="2bc9">export default (spec, refetch) =&gt; component =&gt;   <br />  createRefetchContainer(component, spec, refetch);</pre><pre id="303a">// routes/Search.js</pre><pre id="5d19">@RefetchContainer(graphql`<br />  fragment Search_viewer on Viewer {<br />    posts(search: $search, first: $count) {        <br />      edges {<br />        node {<br />          ...Post_post<br />        }          <br />        cursor        <br />      }        <br />      pageInfo {          <br />        startCursor          <br />        endCursor          <br />        hasPreviousPage          <br />        hasNextPage        <br />      }      <br />    }    <br />  }  <br />`,<br />SearchQuery)<br />export default class Search extends Component { ... }</pre><p id="bab4">I do not remember what happens if you don’t specify the query. Maybe it refetches the same query? The Relay docs market this HOC as useful for “Load More”, but as you’ll see below, there is also a Pagination Container, which is also concerned with Loading More. I prefer to think of the Refetch Container as a place to perform inline updates, or to refetch the query with client-only data.</p><p id="1817"><strong>Apollo<br /></strong>You always have access to a prop called <code>data</code> in wrapped components, and <code>data</code> has a method called <code>refetch()</code> that works like Relay Modern. Example:</p><pre id="bf9a">doRefetch = debounce(() =&gt; {<br />  this.props.data.refetch({<br />    ...this.props.data.variables,<br />    search: this.state.term, <br />  }).catch(e =&gt; {<br />    if (e) {<br />      console.log(e);<br />    }<br />  }).then(() =&gt; {<br />    this.input.blur();<br />  });<br />}, 600);</pre><p id="4377"><strong>Takeaways</strong>: Apollo doesn’t require doing anything new or different. The Relay Modern approach is useful and only requires a small amount of configuration. Relay Modern highlights the need to have your queries in a separate file so you DRY, as they may be needed in multiple places.</p></div></section><section><div><div><h3 id="1136">Pagination Containers</h3><p id="82af">Most apps, especially something like a blog, need pagination and/or Infinite Scroll. All implementations make this easy.</p><p id="6cfa"><strong>Relay Classic<br /></strong>Pagination is mostly a roll-your-own solution using something like: <code>this.props.relay.setVariables({ count: prevCount + 10 })</code></p><p id="5ab1"><strong>Relay Modern<br /></strong>You use <code>createPaginationContainer()</code>, which requires a lot of config, but then you get <code>this.props.relay.hasMore()</code> and <code>this.props.relay.loadMore(10)</code>. Example:</p><pre id="1ee7">export default createPaginationContainer(<br />  Term,<br />  graphql`<br />    fragment Term_viewer on Viewer {<br />      term(slug: $slug, taxonomy: $taxonomy) {<br />        id<br />        name<br />        slug<br />        taxonomy {<br />          rewrite {<br />            slug<br />          }<br />          labels {<br />            singular<br />            plural<br />          }<br />        }<br />      }<br />      posts(term: $slug, taxonomy: $taxonomy, after: $cursor, first: $count)<br />        <a href="http://twitter.com/connection" title="Twitter profile for @connection" target="_blank">@connection</a>(key: "Term_posts") {<br />        edges {<br />          node {<br />            ...Post_post<br />          }<br />          cursor<br />        }<br />        pageInfo {<br />          startCursor<br />          endCursor<br />          hasNextPage<br />          hasPreviousPage<br />        }<br />      }<br />    }<br />  `,<br />  {<br />    direction: 'forward',<br />    getConnectionFromProps(props) {<br />      return props.viewer && props.viewer.posts;<br />    },<br />    getVariables(props, { count, cursor }, fragmentVariables) {<br />      return {<br />        ...fragmentVariables,<br />        count,<br />        cursor,<br />      };<br />    },<br />    getFragmentVariables(vars, totalCount) {<br />      return {<br />        ...vars,<br />        count: totalCount,<br />      };<br />    },<br />    query: TermQuery,<br />  }<br />);</pre><p id="e462">Yes, this configuration is confusing and weird. When Relay Modern first dropped, some of the configuration values were missing from the docs! I have <a href="https://github.com/facebook/relay/pull/1679/files" target="_blank">a PR merged in Relay</a> for this. As a trade-off, you just call <code>loadMore()</code> and you’re done. All of the connection merging happens automatically.</p><p id="3077"><strong>Apollo</strong></p><p id="c599">The <code>data</code> prop always has a method called <code>fetchMore()</code>, but you are responsible for merging the results with your previous results, which can be dangerous and weird. Example:</p><pre id="ea66">const Archive = ({ variables, fetchMore = null, posts: { pageInfo, edges } }) =&gt;<br />  &lt;section&gt;<br />    &lt;ul&gt;<br />      {edges.map(({ cursor, node }) =&gt;<br />        &lt;li key={cursor}&gt;<br />          &lt;Post post={node} /&gt;<br />        &lt;/li&gt;<br />      )}<br />    &lt;/ul&gt;<br />    {fetchMore &&<br />      pageInfo.hasNextPage &&<br />      &lt;button<br />        className={styles.button}<br />        onClick={() =&gt;<br />          fetchMore({<br />            variables: {<br />              ...variables,<br />              cursor: pageInfo.endCursor,<br />            },<br />            updateQuery: (previousResult, { fetchMoreResult }) =&gt; {<br />              const { edges: previousEdges } = previousResult.viewer.posts;<br />              const { edges: newEdges } = fetchMoreResult.viewer.posts;<br />              const newViewer = {<br />                viewer: {<br />                  ...fetchMoreResult.viewer,<br />                  posts: {<br />                    ...fetchMoreResult.viewer.posts,<br />                    edges: [...previousEdges, ...newEdges],<br />                  },<br />                },<br />              };<br />              return newViewer;<br />            },<br />          })}<br />      &gt;<br />        MORE<br />      &lt;/button&gt;}<br />  &lt;/section&gt;;</pre><p id="c389"><strong>Takeaways</strong>: Sometimes things are very similar in both frameworks. Other times, they are equally as strange. I would note that both are probably better than the current Bring Your Own Implementation solutions that have been written in jQuery from days of yore.</p><h3 id="7558">Conclusion</h3><p id="152e">Rather than spending a ton of time trying to pick the perfect solution before building anything, I have tried both, and am able to create what I want in both. I still want to try Apollo on React Native, and I still want to mix my React Native code with native mobile platform code. I think both will work just fine.</p><p id="d70b">Relay Modern works like a dream in React Native. Using it on the web is possible with the tools I outlined above.</p><p id="ec4a">Apollo has an ecosystem around it, and its own ideas about how to do things. Facebook created GraphQL and Relay, but does not actively provide ALL of the tools you need.</p><p id="cf5f">My prediction: I could rewrite this post every 6 months with lots of new learnings based on changes and pivots from every corner of the ecosystem. GraphQL and React will probably remain “stable.” I think the frameworks around them are just getting started.</p></div></section>