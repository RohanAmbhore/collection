<a href="https://medium.com/@duhroach/how-png-works-f1174e3cc7b7">https://medium.com/@duhroach/how-png-works-f1174e3cc7b7</a><div id="articleHeader"><h1>How PNG Works</h1></div><p id="42f0">The <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" target="_blank">Portable Network Graphics</a> (PNG) has become a staple for App development over the past few decades. It’s creeped up everywhere from game development, to web development, and Android development, which means that it’s widely adopted, but also has the opportunity to be widely <em>abused</em>.</p><p id="f161">And as <a href="https://www.youtube.com/watch?v=2TUvmlGoDrw&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&index=52" target="_blank">I’ve discussed before</a>, PNG provides a nice, high resolution image format, but that means that there’s lots of room for improvement for data compression. But before we can start talking about <em>how</em> to compress PNG files further, we have to first talk about <em>how the format works</em>.</p><h3 id="2964">Understanding the Compression</h3><p id="6214">PNG’s compression process is entirely lossless; meaning that the compressed file can reconstruct the source image exactly. Done in two stages: Prediction (aka filtering) and then Compression.</p><h3 id="983b">#1 Filtering (prediction)</h3><p id="5432">Delta encoding is one of the most powerful numeric compression methods out there. The basic idea is that you can represent any value as a difference from the previous value. So,</p><p id="ebf2">[2,3,4,5,6,7,8] can become [2,1,1,1,1,1,1], where</p><p id="06cd">[2, 3–2=1, 4–3=1, 5–4=1, 6–5=1, 7–6=1, 8–7=1]</p><p id="77f6">The reason this is so powerful, is that if the data is linearly correlated (that is, value has some low-difference from the previous value) then you end up transforming values of your dataset into lots of duplicate, low values, which are more compressible.</p><p id="9dbf">The PNG format makes use of delta encoding in a format that it calls “filtering”. Basically, for each scan-line of pixels, a current pixel is encoded in some relation to the pixel to the left, the pixel above, and the pixel above-left.</p><figure id="faf4"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/0*9ZmTLC3rBj95db63.?q=20" /><img src="https://cdn-images-1.medium.com/max/2000/0*9ZmTLC3rBj95db63." /></div></figure><p id="39b3">For example if we encoded a given pixel by listing its difference between the average of A and B (X-((A+B)/2)then we’d get:</p><figure id="c2d0"><div><img src="https://cdn-images-1.medium.com/max/2000/1*9DREStZ3sX45FZFt_SwDfg.png" /></div></figure><p id="ec91">The filtering takes ABC, and uses that to <em>predict</em> what the value of x is. The value that we replace x with, is the difference between the prediction, and the actual value.</p><p id="6506">Now, it’s worth noting that each line may be a little different, which is why PNG allows 1 of 5 different modes to be chosen, per line:</p><ul><li id="a0bd">No filtering</li><li id="c6cc">Difference between X and A</li><li id="042e">Difference between X and B</li><li id="54e5">Difference between X and (A + B)/2 (aka average)</li><li id="53c4"><a href="https://www.w3.org/TR/PNG-Filters.html" target="_blank">Paeth</a> predictor (linear function of A,B,C)</li></ul><p id="ca37">The intention here, is that each line can choose the best filtering method, for itself, such that it can produce the lowest number of unique symbols. Here’s our original example with each mode:</p><figure id="d706"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*x-yXQnUD4Vjjq10ALPyirQ.png?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*x-yXQnUD4Vjjq10ALPyirQ.png" /></div><figcaption>An example of applying filtering to two rows of pixel values. The impacted pixels are highlighted in blue.</figcaption></figure><p id="f431">And, it’s important to note that these filters are done, <em>per channel</em> not per-pixel. Meaning that the filter is applied to all the red values of a pixel for a scanline, and then separately for all the blue values for a scanline (although all the colors in a row will use the <em>same</em> filter).</p><p id="05fe">And the PNG format has some nifty ways to pick which filter to use on a channel; While brute force is the most direct, it’s simply right out. Instead, the developers experimented on different image types and came up with some rules of thumb, that are close to optimal; like use None filters for palette images, and sub-8 bit grayscale images. And for the other images, choose the filter that minimizes the sum of absolute differences; Rather than using modulo-256, instead to standard signed math, then take the abs value, and add them all together for a given row, and compare the sums for the other filter types. Choose the filter that gives the smallest sum.</p><h3 id="59bc">#2 Compression (DEFLATE)</h3><p id="6017">Once filtering has occurred on a scan-line, it’s passed off to a descendant of the LZ77 algorithm, known as DEFLATE; This algorithm combines LZ77 coding alongside a Huffman coder. Which is almost identical to compressors like PKWARE, PKZIP, GZip etc. The implementation is out-of-the-box standard, but has some interesting caveats when it comes to image data.</p><ol><li id="85bb">Deflate limits match lengths between 3 and 258 symbols; which puts the maximum conceivable compression ratio around 1032:1.</li><li id="df4f">If the match is less than 3 symbols, then you incur some overhead to represent the symbol</li></ol><p id="6081">The result of these two, means that the size of your image can have an impact in if matches are found in a scanline.</p><p id="34e5">Consider this image below, The 270x90 version is only 20k, however the 270x92 version is 2x larger.</p><figure id="b9da"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/0*EYssBxmJP27Gya81.?q=20" /><div class="readableLargeImageContainer float"><img src="https://cdn-images-1.medium.com/max/2000/0*EYssBxmJP27Gya81." /></div></figure><p id="6d76">Logically this seems wrong. Adding 540 pixels to an image shouldn’t cause a 2x bloat in compression. However when we look a little closer, we can see why this is occurring; The following heat map of the images represents how compressed a given pixel is. Deep blue = very compressed, yellow/red = not very compressed</p><figure id="6e2c"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/0*XQUFZC5ajMekUkkl.?q=20" /><div class="readableLargeImageContainer float"><img /></div></figure><p id="8eee">What’s occurring here, is that in the smaller image, there’s more matches in the scanlines, and thus there’s better compression. However, adjusting the size, slightly, changes the type of matching that can occur; some potential candidates for matching are now outside of our LZ window, and thus aren’t matched, resulting in a larger file.</p><p id="339b">If you’re looking to see how well your own images compressed with PNG, check out <a href="http://encode.ru/threads/1725-pngthermal-pseudo-thermal-view-of-PNG-compression-efficiency" target="_blank">PNGThermal</a>.</p><h3 id="be24">Understanding the format</h3><p id="10f7">Now, it’s worth noting that PNG is more than just the filtering & compression stages. It’s a pretty extensible container format, that can support all sorts of image types and added data.</p><p id="11f0">Let’s first start with the fact that the PNG file format can support a series of chunks inside of it which can include various types of data. For example, you’ve got the <strong>PNG Header chunk</strong> which contains simple information about the image like width, height, bit depth & color-type.</p><p id="b041">The<strong> Image data chunk</strong> contains the actual image information itself (oh, and note, this information can exist in multiple chunks). Then for color paletted images, there’s a separate chunk for that.</p><p id="193c">And finally an <strong>end-of-file chunk</strong>. And those are the main chunks, but there’s also a whole slew of <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics#.22Chunks.22_within_the_file" target="_blank">other chunks</a> like:</p><ul><li id="d515">Default background color</li><li id="088e">Chroma coordinates on how to display white-points</li><li id="8774">Gamma spec</li><li id="aba3">Histogram info</li><li id="a54f">Text data, with language or Metadata info</li><li id="987f">Color space information</li><li id="82e2">Stereo-image data</li><li id="0c72">A chunk which notes the last time the file was changed</li><li id="b2ae">And Transparency data.</li></ul><p id="02a4">Now, these chunks are where you need to watch out, because lots of junk gets put in there by your photo editing app. For example, saving a PNG file from Photoshop results in a chunk that says “<em>this image was made in photoshop.</em>” That chunk has nothing to do with the visible pixel data, but yet it’s included in the file itself. As such, REMOVING useless chunks is critical to ensuring small file sizes. The image below shows you a 16x16 pixel image, <strong>saved</strong> from Photoshop as a regular PNG, and the other-one, using the “<strong>export to web</strong>” option of photoshop, which removes all the gobbledygook.</p><figure id="680d"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/105/1*Pu_D0jQ8ef52C8IKFMcWYw.png?q=20" /><div class="readableLargeImageContainer"><img /></div><figcaption>The left image was saved regularly through Photoshop, the right image was saved via “export to web.” the difference in sizes comes from removal of meta data from the file.</figcaption></figure><h3 id="d00b">Pixel format</h3><p id="0af1">The PNG format can ALSO support various types of pixel formats so you can create an optimal</p><p id="7dd6">Indexed = 1 channel, can be 1,2,4,8 bpc</p><p id="5e0c">Grayscale = 1 channel, can be 1,2,4,8,16 bpc</p><p id="9f51">Gray+Alpha = 2 channel, can be 8 or 16 bpc</p><p id="66e7">Truecolor(RGB) = 3 channel, can be 8 or 16 bpc</p><p id="9e99">RGBA = 4 channel, can be 8 or 16 bpc</p><p id="3d1c">Pixel formats are selected by the author of the image file. So it’s not too interesting to discuss, other than making sure you’ve chosen the right pixel format; Storing a greyscale image as a truecolor w/ alpha, is a bad idea.</p><h3 id="9b7c">Story : GIF and the birth of <a href="http://www.libpng.org/pub/png/book/LCH-png-chapter.pdf" target="_blank">PNG</a></h3><p id="cf93">When it comes to the relentless bulk of web content, images are by far the largest load bearer today (although there’s an argument to be made that videos have become king as of late).</p><p id="c42b">But what’s truly interesting is that as much as compression information can help solve some of the congestion, there’s a massive amount of human problems that keep compression from making its way into everyone’s hands.</p><p id="d657">Let’s take a trip back to 1985, when Unisys filed a patent for the LZW compression algorithm, nothing too interesting at the time. A few years later, when CompuServe invented the 89a format (which later became the GIF format), they used LZW as its backbone, not realizing that it was a patented. Unisys didn’t care about this until 1993, when the Netscape browser added support for the IMG HTML tag, alongside with support for the 89a format. Within a year, animated images became all the craze on the internet, and Unisys started enforcing its patent. CompuServe and Unisys eventually reached a court agreement in December of 1994, announcing that Unisys would start collecting royalties from all software that used the 89a graphics format. In the months following this decision, a group of engineers developed an entirely new, patent-free format known as the Portable Network Graphics or PNG format.</p><p id="40d3">In 2004, the patent on LZW finally expired, but for a whole decade, the GIF/PNG image format debate was a hot one among internet folks.</p><h3 id="2624">In closing</h3><p id="081e">PNG is a very flexible and powerful image format type that’s become popular on the web due to it’s ability to support transparency. But it’s not right for _every_ situation; Basically, make sure you’re using the best tool for the job. If your image is photographic and absolute losslessness is not required, then JPG or an equivalent lossy method would be more efficient than any lossless approach. On the other hand If you need a smaller bit-format, or need transparency, than PNG would be a dominant win over JPG.</p><p id="ffd5">And if you’re interested in seeing the most bare-bones implementation of a PNG coder, check out this <a href="https://gist.github.com/mmalex/908299" target="_blank">awesome gist</a>, which packs the whole thing into ~40 lines of code.</p><p id="4c63">Of course, then there’s WebP, which will give you both.. But that’s separate article ;)</p><h4 id="50eb"><strong>HEY</strong>!</h4><p id="2266">Want to shrink your PNG files even smaller? Check out <a href="https://medium.com/@duhroach/reducing-png-file-size-8473480d0476#.si2b8jger" target="_blank">Smaller PNG Files</a> follow up post.</p><p id="7735">Want to know how <a href="https://medium.freecodecamp.com/how-jpg-works-a4dbd2316f35" target="_blank">JPG files work</a>, and how to <a href="https://medium.com/@duhroach/reducing-jpg-file-size-e5b27df3257c" target="_blank">make them smaller</a>?</p><p id="71b4">Want more data compression goodness? <a href="http://shop.oreilly.com/product/0636920052036.do" target="_blank">Buy my book</a>!</p>