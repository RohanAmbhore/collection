<a href="https://blog.apollographql.com/query-components-with-apollo-ec603188c157">https://blog.apollographql.com/query-components-with-apollo-ec603188c157</a><div id="articleHeader"><h1>Query Components with¬†Apollo</h1></div><p id="5edc">A couple of months ago, we started to use Apollo Client (+React Native) at <a href="https://werkspot.nl" target="_blank">Werkspot</a>. From the very beginning, Apollo overwhelmed us by the simplicity and flexibility it provides. It inspired us to create our own vision about technology and experiment with various approaches to data fetching that we think are worth sharing.</p><p id="3924">Enjoy the ride! üöÄ</p><div><figure id="36e5"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*jWjWcYFrb7dw1PSyNssrhQ.jpeg?q=20" /><div class="readableLargeImageContainer"><img /></div><figcaption>Apollo + Query Components hype¬†rocket!</figcaption></figure><div><h3 id="060c">Anatomy of Query Components</h3><p id="e520">One of the very powerful concepts that we found for ourselves with Apollo is Query Components. These components are meant to express a domain-specific data logic in a clear, declarative way:</p><figure id="ef10"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F2273613%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="fb5c"><code>CitiesQuery</code> component is an oversimplified example of an average Query Component. It exports a <code>Component</code>, enhanced by a <code>graphql</code> wrapper for fetching data. After Apollo takes care of fetching and mapping props to query parameters, query component uses ‚Äúfunction-as-a-child‚Äù approach to expose a child-independent API with injected data.</p><p id="3bc0">Comparing to the standard approach where you add a <code>graphql</code> wrapper to your higher-order components, query components have a set of advantages:</p><ul><li id="0e63"><strong>Testability</strong>. Unless you have a very good reason, you can test your components without any data management logic.</li><li id="c1e7"><strong>Separation of concerns</strong>. From now on, higher-order components are no longer concerned about the way data is fetched/pushed to the server.</li><li id="14b5"><strong>Abstraction over data management layer</strong>. Frankly speaking, it doesn‚Äôt really matter which library you use under the hood. Query Components abstracts out your data management layer so you can focus on business logic and change underlying implementation if needed.</li></ul><p id="cdb3">Once a Query Component is defined, it can be used as any other component in your application:</p><figure id="b3c1"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F2273613%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="5143">A nice side effect of decoupling higher-order components into Query Components is minimizing bloat. If the data management layer grows, it won‚Äôt affect presenter components unless they have to reflect new data properties.</p><h3 id="78d8">Mutations with Query Components</h3><p id="d2f7">Mutations are not that straightforward as queries. When a query component is mounted, Apollo immediately tries to fetch. However, when we talk about mutations, there is no need (in 99% of our cases) to perform any mutations at the mount time. This idea brings us to the point that we should have a way to control a moment when we execute our mutations. For example:</p><figure id="4750"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F2273613%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="3eec">Therefore, you can use this component in a similar way:</p><figure id="fe26"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F2273613%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="329c">So the concept is the same: Query Component receives a bunch of props that are later on used as parameters for the mutation query.</p><div><figure id="5773"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/90/1*AWcvWxN7S2ykK0bvKAVVVA.jpeg?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/1*AWcvWxN7S2ykK0bvKAVVVA.jpeg" /></div><figcaption>Testing Query Components like a pro¬†üòé</figcaption></figure><div><h3 id="d024">How to test Query Components?</h3><p id="3873">When it comes to testing, Apollo-based components have a bunch of features that we need to take into account. The most complicated one is related to React context and Apollo Client reference in particular. All components that intent to use Apollo should be put into the subtree of <code>&lt;ApolloProvider /&gt;</code> which gives them a reference to the client through the React context. Hopefully, if we use Enzyme and shallow rendering, we can supply context object as one of the options.</p><h4 id="8957">Assertions</h4><p id="533c">One of the very first things we would like to test is that every Query Component is able to produce variables, required by a query. To ensure that, we check a shape of resulting variables.</p><p id="32b8">Another assertion that we would like to make is about response shape. In other words, we check if given <code>data.x</code> complies with the shape of the mock that was passed to the fake client during initialization.</p><p id="d435">And the last, but not least: query component should call a function that we pass as a child with the data pulled from Apollo. Altogether, the test suit looks like this:</p><figure id="6f9e"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F2273613%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="f60a">The very last uncovered function is <code>makeFakeClient</code>. It is a self-written helper that generates an Apollo Client with a fake link:</p><figure id="6243"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F2273613%3Fs%3D400%26v%3D4&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div></figure><p id="3451">This should be more or less it. I didn‚Äôt cover mutation components testing, but it isn‚Äôt anyhow different. The only thing I can foresee is an additional assertion that <code>execute</code> handler triggers Apollo fetcher, but I‚Äôll leave it to the reader.</p><h3 id="9a29">Where to go from¬†here</h3><ul><li id="0f09"><a href="http://engineering.khanacademy.org/posts/creating-query-components-with-apollo.htm" target="_blank">A great blog post from Khan Academy about their approach writing Query and Mutation components</a></li></ul></section><section><div><div><p id="9c8d">Don‚Äôt hesitate to ask questions, challenge this approach and share your ideas about Apollo and GraphQL overall. You can always find me on <a href="https://twitter.com/kureevalexey" target="_blank">Twitter</a> or Discord (<code>kureev</code> on <code>#reactiflux</code>).</p><p id="f8bf">Oh yeah, and last but not least: if you like this or any other of my articles, don‚Äôt hesitate to <a href="https://www.patreon.com/kureevalexey" target="_blank">become a part of it</a>! Your support is greatly appreciated!</p></div></section>