<a href="https://medium.com/actualbudget/the-horror-of-blocking-electrons-main-process-351bf11a763c">https://medium.com/actualbudget/the-horror-of-blocking-electrons-main-process-351bf11a763c</a><div id="articleHeader"><h1>The Horror of Blocking Electronâ€™s MainÂ Process</h1></div><div><figure id="8de6"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/66/0*TcjfH6PwzZqyh1-w.?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/2000/0*TcjfH6PwzZqyh1-w." /></div><figcaption>Photo by <a href="https://unsplash.com/@cadop?utm_source=medium&utm_medium=referral" target="_blank">Mathew Schwartz</a> onÂ <a href="https://unsplash.com?utm_source=medium&utm_medium=referral" target="_blank">Unsplash</a></figcaption></figure><div><p id="daf2"><em>Update: Somebody gave </em><a href="https://twitter.com/NumaanAshraf/status/968496732278374400" target="_blank"><em>an in-depth answer</em></a><em> on twitter about why this happens and you should read it (after reading this, of course)</em></p><p id="f80c">Apps need to feel smooth. Itâ€™s part of the illusion of softwareâ€Šâ€”â€Šthat what you are looking at is something youâ€™re actually interacting with, not made up by electrical pulses. Whenever I build a feature for <a href="http://actualbudget.com/" target="_blank">Actual</a>, I spend as much time as I can afford to make sure itâ€™s fast. Because Iâ€™m short on time, itâ€™s not perfect, but I felt like it was generally in a good place.</p><p id="9ede">Until last Thursday. I pulled up the latest version of the app with my finances which has 2 years worth of data. As I updated my budget, something felt off. The table wasnâ€™t updating fast enough. I poked around some more and my heart sank. Everything was slow. It felt like it begrudgingly performed tasks.</p><p id="1da5">The app is built with <a href="https://electronjs.org/" target="_blank">Electron</a>, which makes it easy to use web technologies to build desktop apps. Most of my performance work happened outside of itâ€Šâ€”â€Šrunning components with a huge amount of data in a normal browser. Maybe something in the Electron environment is slowing it down?</p><p id="0597">I immediately thought of this comment I wrote in the entry point for the app:</p><pre id="981c">// TODO: Evidently, I shouldnâ€™t actually be running all of this on <br />// the main process. For it to be truly async I need to run it<br />// within its own process. See<br />// <a href="https://github.com/electron-userland/electron-remote/blob/master/src/renderer-require.js#L42" target="_blank">https://github.com/electron-userland/electron-remote/blob/master/src/renderer-require.js#L42</a></pre><p id="177d">There are two processes in a basic Electron app: the main process and the renderer process. The main process is where you manage OS-level stuff like windows, and the renderer process is where the UI lives. I had previously misunderstood the role of the main process. Actual has a node backend, and I assumed that I should run the backend in the main process. Last April (almost a year ago!) I started to realize I shouldnâ€™t do that, and wrote the above comment.</p><p id="092f">Something strange was going on with the app, so maybe this is the root of the problem? Apparently, the main process can block the renderer process rather easily, so they arenâ€™t simply two processes operating asynchronously.</p><p id="dcc8">The problem is that I couldnâ€™t find any information as to why the main process would be blocking the UI. The link in the comment above doesnâ€™t make sense anymore, but the project itself solve problems with the <code>remote</code> module, which I donâ€™t use at all. All the information I could find talked about how the the renderer process is blocked on the main process in certain conditions: certain OS-level APIs are called, transparently invoking modules with <code>remote</code>, etc. None of which Iâ€™m doing.</p><p id="a5fb">I wanted a clear answer if the main process always blocks the renderer process when itâ€™s busy. So I wrote the following code to slow it down:</p><pre id="666e">function slowdown() {<br />  for (var i = 0; i &lt; 100000; i++) {<br />    const x = {<br />      y:<br />        Math.ceil(i) +<br />        â€˜sdsfjdlfjlkMNFONnsdnoâ€™.slice(4, (Math.random() * 20) | 0)<br />    };<br />    eval(â€˜(â€˜ + JSON.stringify(x) + â€˜)â€™);<br />  }<br />}</pre><p id="792a">On the frontend, I added a page with a button and a number. When the button is pressed, it invokes <code>slowdown</code> by sending a message to the backend using the <code>ipcRenderer</code> module <strong>and</strong> starts incrementing a number every 100ms. What I <em>want</em> to happen is the number continues to increment while the server slogs through my evil code.</p><p id="7b70">Sure enough, the UI is blocked! The number would update once and then the whole UI would completely block for a few seconds until the server responded. What!? ðŸ˜²</p><p id="69c2">This reminds me of when I discovered synchronous ajax requests really are that horrible:</p><figure id="ff72"><div><div><img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FUzE955UJUVU%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07&width=40" /></div><figcaption>Never, ever block the main thread</figcaption></figure><p id="b147">I knew exactly why Actual felt slow. Actual is powered by sqlite, and something as simple as updating a transaction triggers several queries (updating account balances, budget categories, budget totals, etc). While Iâ€™ve optimized these queries, if running a single sqlite query blocks the UI, thereâ€™s no way youâ€™re going to make it smooth.</p><p id="583f">Excitedly, I moved the backend to its own process and implemented a new way to communicate to it, and it fixed everything! Seriously, the results <strong>far exceeded</strong> my expectations. I had no idea how badly this was impacting performance! And it only took me 3 hours to do this (thanks to abstracting out the communication layer). Us engineers live for this kind of thing.</p><p id="0316">Here are a few examples of before and after. Look closely at how the app stutters and janks in the before gif:</p><figure id="1d36"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/66/1*1WvmNQc0ZoUgw_WVKTpgmA.gif?q=20" /><div class="readableLargeImageContainer"><img src="https://cdn-images-1.medium.com/max/1760/1*1WvmNQc0ZoUgw_WVKTpgmA.gif" /></div><figcaption>Before</figcaption></figure><figure id="7010"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/66/1*AKW3XhcqPhnYY9n92JRpYA.gif?q=20" /><div class="readableLargeImageContainer"><img /></div><figcaption>After</figcaption></figure><figure id="522a"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/66/1*vy6tgTHecJ4blUgOb2nL8A.gif?q=20" /><div class="readableLargeImageContainer"><img /></div><figcaption>Before</figcaption></figure><figure id="84ee"><div><div><img src="https://cdn-images-1.medium.com/freeze/max/66/1*JwpxvACrv0XZhkijpAn8Kg.gif?q=20" /><div class="readableLargeImageContainer"><img /></div><figcaption>After</figcaption></figure><p id="55e6">Itâ€™s hard to show just how different it feels. If you look closely, the after gifs show a much more consistent and snappy experience. (Ignore the fact that just moving around the transactions triggers updatesâ€Šâ€”â€Šthat could be optimized but honestly I like taking the worst case scenarios and making sure those are fast.)</p><h4 id="ad99">Technical Deets</h4><p id="b695">A pleasant side effect of this change is the new way the backend and UI communicate. Previously, they talked to each other through Electronâ€™s <a href="https://electronjs.org/docs/api/ipc-renderer" target="_blank">ipcRenderer</a> and <a href="https://github.com/electron/electron/blob/master/docs/api/ipc-main.md" target="_blank">ipcMain</a> APIs (using the appropriate <code>send</code> method which the documentation <em>says</em> is async, but I guess we have different definitions of async).</p><p id="66b7">Now that the backend is in its own process, I needed a way to have the UI process and backend talk to each other. It seemed silly to make all the messages go back to the main process only to be forwarded to the other. Instead, the backend starts its own websocket server and the frontend connects directly to it.</p><p id="5770">Not only is this much simpler and more performant, I have total control over how messages are serialized. Apparently the IPC APIs only support JSON-serializable objects (if you send a string it will automatically call <code>JSON.parse</code> on it). Now I can encode and decode my data with a more efficient strategy. Long-term, the backend may even be native and sending binary messages.</p><p id="fd18">Lastly, itâ€™s very easy for me to develop completely outside of electron. All I need to do is start the backendâ€™s websocket server with node directly, and load the frontend in a browser. I already develop most of the components in the browser using a separate design tool, but doing that may be nice for debugging the whole system.</p><h4 id="8f55">Downsides</h4><p id="62cc">Thereâ€™s always downsides. The major thing is that unfortunately Actual will take up more memory. Weâ€™ve created a second renderer process which is not lightweight. While I havenâ€™t tracked memory closely, a quick test seems to take up about 40MB (going from 150MB to 190MB). There could have simply been an unrelated difference between my tests as well. Regardless, I havenâ€™t done any memory profiling at all so I can probably reduce this with care.</p><p id="610b">Right now the websocket server listens on a port. Thereâ€™s a small chance of conflict with something already listening on that port, so I might need to implement a way to choosing a port thatâ€™s free. Ideally, I could avoid ports and run it as a local socket somehow (via a file descriptor) but Iâ€™m not sure nodeâ€™s websocket libraries handle that.</p><h4 id="dc23">Conclusion</h4><p id="3955">Keep as much as you can off the UI thread. Even when you do that, make sure that the UI thread isnâ€™t synchronously blocking on anything else.</p>