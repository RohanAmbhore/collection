<a href="https://www.reddit.com/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4/?context=3">https://www.reddit.com/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4/?context=3</a><div id="articleHeader"><h1>Redux is not an architecture or design pattern, it is just a library. </h1></div><div><div><div id="t1_d509k5n"><div><div><div><div><p>At my company, we recently started rebuilding parts of our existing Marionette.js and Backbone.js SPA in React, Redux, Immutable.js, redux-promise, and a smattering of other packages.</p><p>React is easy - components, props, and JSX. Redux itself is easy, and easy to scale and test. Using a package like <a href="https://github.com/acdlite/redux-actions" target="_blank">redux-actions</a> removes a lot of boilerplate, which is nice. It's also easy to plug Immutable.js into the mix.</p><p>What gets complex and <em>really</em> hard to manage is duplicate entities <strong>and their relationships</strong> in a redux store. Libraries like <a href="https://github.com/paularmstrong/normalizr" target="_blank">normalizer</a> help aggregate and reduce entities in a store by using ID references where appropriate, and <a href="https://github.com/reactjs/reselect" target="_blank">reselect</a> using memo-ized functions to read something out of the store efficiently.</p><p>But using all this together with a standard (albeit well-documented and internally maintained) REST API gets crazy. Combining and managing two sets of entities in the store where they have a one-to-many relationship raises a lot of questions, simply "how the hell do we do this", and has resulted in some seriously messy spaghetti code, in my opinion.</p><p>Throw something like <a href="https://github.com/yelouafi/redux-saga" target="_blank">redux-saga</a> into the mix like we did recently and it's almost table-flipping time. We're slowly going through and refactoring what we have so that while we might not have a fully normalized store, we can at least read the code and easily do what we need to do with data before and after it gets merged into the store.</p><p>My advice? Stick to React, Redux, Immutable.js, and a Promise-based HTTP redux library (like redux-promise), and that's it. Sagas are cool, normalizr is a neat idea, and reselect promises some big efficiency gains, but using all of them together is a recipe for headaches right now. Give these tools more time to mature and I think there'll be some better patterns come out of it.</p><p>tl;dr; redux is awesome, just stick with it and only it and you'll enjoy it.</p></div></div></div></div></div></div></div><div><div><div id="t1_d50pui9"><div><div><div><div><p>As an addendum: my own personal advice is to <em>not</em> use Immutable.js.  I don't think it's worth the tradeoffs.  Better to stick with plain JS objects, and maybe use just a bit of sugar over updating them properly.</p></div></div></div></div></div></div></div><div><div><div id="t1_d51cqs3"><div><div><div><div><p>Hey acemarke, nice to see you here too (I recognise you from Discord). It'd taken me a while to realise the advantages of using Immutability.js are basically just saving verbosity when modifying the state object. This sounds good enough to me but what do you mean by tradeoff, how's Immutability.js a drawback?</p></div></div></div></div></div></div></div><div><div><div id="t1_d51g4k4"><div><div><div><div><a href="/user/acemarke" target="_blank">acemarke</a></div>8 points·<a href="/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4/" id="CommentTopMeta--Created--t1_d51g4k4" target="_blank">1 year ago</a>·edited 1 year ago</div><div><div><p>First caveat: I have not directly used Immutable.js myself in my own projects, so my opinions are based strictly on my reading.  Second, I'm going with the assumption that someone is trying to use Immutable.js with Redux specifically.  Third, this is about the Immutable.js library, not the concept of immutable data as a whole.</p><p>That said, here's my general thoughts:</p><ul><li><p>The primary reason many people offer for using Immutable.js is performance.  True, it can certainly give you cheap reference comparisons if you're implementing <code>shouldComponentUpdate</code>.  However, I've seen a number of anti-patterns pop up in how people use it.  In particular, I've seen many people calling <code>toJS</code> inside of their <code>mapStateToProps</code> functions.  From everything I've read, that is a <em>bad</em> idea for performance.  <code>mapState</code> needs to be as fast as possible, and Lee Byron (Immutable.js's primary author) has said that calling <code>toJS</code> is expensive and should be avoided.  In addition, by calling <code>toJS</code> in <code>mapState</code>, it's returning brand-new object references (thus defeating the shallow-equality checks inside of <code>connect</code>).  That also defeats the idea of shallow-equality checks if you implement your own <code>shouldComponentUpdate</code>, because of both new object references as well as losing the ability to use Immutable's own comparison functions.  So if you don't call <code>toJS</code> in <code>mapState</code>, you instead have to use the accessor methods the Immutable types offer.  Which leads to:</p></li><li><p>Using Immutable.js sort of "infects" your codebase with its API.  Because everything goes through its specialized <code>getIn/setIn</code>-type functions, you generally have to make sure your entire codebase knows what's an Immutable type and what's not.  It also precludes the ability to use some more standard JS syntax, and can require more work to interop with libraries that are expecting plain JS objects.  So, in order to get the most benefit, you really need to be passing Immutable objects from <code>mapState</code> all the way into your components, which means your components are now tied to use of Immutable.js</p></li><li><p>I'm also not entirely clear on exactly how much performance benefit Immutable's structural sharing gives you in the first place.  Admittedly, that's something I'm still kinda hazy on.  However, if you're just looking for "handle data in an immutable fashion", that's entirely feasible with plain JS.  It can be done with just simple careful coding (double-check any time you're doing an assignment statement to make sure it's only happening with a copy, always use array methods like <code>concat</code> instead of <code>push</code>, etc).  If you're worried about making mistakes, there's a couple dozen utility libraries that abstract out the process of making immutable updates to data, or it's trivial to write your own update wrapper functions.</p></li><li><p>Debugging gets a bit harder because the objects aren't plain JS, but rather specialized data structures, so it's not as easy to see the contents</p></li></ul><p>So overall, my impression is that the performance benefits are overrated, it's too easy to make mistakes in usage that are actually a net performance negative, and you either have to go all-in on the API everywhere in your codebase or be very sure you know when you're using Immutable types vs plain JS and do conversions all over the place.</p><p>I've got a few articles on performance considerations with Immutable.js listed over at <a href="https://github.com/markerikson/react-redux-links/blob/master/react-performance.md#immutable-data" target="_blank">https://github.com/markerikson/react-redux-links/blob/master/react-performance.md#immutable-data</a> that you might want to glance through for reference.  I've also got links to numerous other options for managing Javascript data immutably at <a href="https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md" target="_blank">https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md</a>.</p></div></div></div></div></div></div></div><div><div><div id="t1_d51yfi8"><div><div><div><div><p>These are some really excellent points acemarke, and in my use of Immutable.js over the past 6 months I've committed pretty much every sin in the book :)</p><p>My 2 cents:</p><ul><li><p>I find reducer logic really nice to read/write when they are all Immutable.js. I personally would stick to either all Immutable or none, for consistency and to avoid context-switching.</p></li><li><p>The performance gains can be really notable, especially if things change based on mouse interactions (not many things do, but Immutable is really helpful in some scenarios).</p></li><li><p>@connect implements <code>shouldComponentUpdate</code>, so I like to take advantage of that fact with my 'selectors' (mapStateToProps) returning immutable props.</p></li></ul><p>How I personally avoid your two biggest good points: 'Infection' and 'toJS':</p><ul><li><p>ALL reducer state is Immutable.</p></li><li><p>ALL 'selectors' return Immutable maps/lists OR primitive strings/numbers/bools</p></li><li><p>ONLY 'smart' components are allowed to use @connect/selectors to get their data. (for me, this is mostly <code>react-router</code> <code>&lt;Route&gt;</code> components)</p></li><li><p>My smart components are wrapped in <code>@connect(selector)</code> and then a custom decorator called <code>@toJS(...list of props keys)</code>. This way I get the performance benefits without the <code>render()</code> code needing to know that the data was ever immutable.</p></li><li><p>One exception to the above is with lists of things that will re-render a ton. In that case I pass immutable objects to the children and they use the <code>@pureRender</code> and <code>@toJS</code> to extract the data.</p></li></ul><p>Anyhow, I agree with you that there are a lot of bad habits you can easily fall into, and I wouldn't recommend Immutable.js for a first-time redux user. Better to get a feel for the flow and add technology once you've identified how/where it can help you.</p></div></div></div></div></div></div></div><div><div><div id="t1_d5mhluv"><div><div><div><div><p>Do you happen to have a code example for this? Like on github?</p></div></div></div></div></div></div></div><div><div><div id="t1_d5rtb1d"><div><div><div><div><p>Do you by chance have open sourced that deocrator you are talking about?</p></div></div></div></div></div></div></div><div><div><div id="t1_d5rw0p9"><div><div><div><div><p>Its in here <a href="https://gist.github.com/cpsubrian/79e97b6116ab68bd189eb4917203242c#file-tojs-js" target="_blank">https://gist.github.com/cpsubrian/79e97b6116ab68bd189eb4917203242c#file-tojs-js</a></p><p>I don't have a modularized version of it (yet). I'm working out the kinks of our 'framework' and would like to modularize all this at some point. Pretty much my whole workflow is in that gist but I didn't post ALL the code, you should get the idea though.</p></div></div></div></div></div></div></div><div><div><div id="t1_d5rw2q2"><div><div><div><div><p>Note: with that decorator you can use <code>@toJS</code> or <code>@toJS(map of prop names)</code>. Thats why it looks sorta complicated because it supports both invocations.</p></div></div></div></div></div></div></div><div><div><div id="t1_d5s6aum"><div><div><div><div><p>It's axually quite easy to debug with use of Immutable.js Object Formatter for Chrome.</p></div></div></div></div></div></div></div>